/***************************************************************************
 *   datamap.cpp                                                           *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This class stores the bitmap associated with a particular type of data  *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/

#include <new>
#include <math.h>
#include "raster.h"
#include "datamap.h"

#define COLOR_WHEEL_SPAN         5.999999999999999999999
#define DEG_0_TO_LESS_60         0
#define DEG_60_TO_LESS_120       1
#define DEG_120_TO_LESS_180      2
#define DEG_180_TO_LESS_240      3
#define DEG_240_TO_LESS_300      4
#define DEG_300_TO_LESS_360      5
#define MAX_VAL                  255
#define MIN_VAL                  0
#define HUE_TRUNCATE             0.7
#define FONT_NAME            "/usr/share/fonts/TTF/DejaVuSans.ttf"

dataMap::dataMap() {
  // initialize values
  m_dataType = fileType::Null;
  m_mapType = Blank;
  m_orientation = Astronomical;
  m_colorScheme = Linear;
  m_pageAspect = 4.0 / 3.0;
  m_Xpage = 800;
  m_Ypage = (long)(m_Xpage / m_pageAspect);
}

dataMap::dataMap(FILETYPE type) {
  dataMap();
  m_dataType = type;
}

dataMap::dataMap(dataMap* from) {
  m_dataType    = from->dataType();
  m_mapType     = from->mapType();
  m_orientation = from->orientation();
  m_colorScheme = from->colorScheme();
  m_map         = from->map();
  m_mask        = from->mask();
  m_color       = from->color();
  m_Xpage       = from->Xpage();
  m_Ypage       = from->Ypage();
  m_pageAspect  = from->pageAspect();
  m_Xmap        = from->Xmap();
  m_Ymap        = from->Ymap();
  m_aspect      = from->aspect();
  m_maxValue    = from->max();
  m_minValue    = from->min();
  m_title       = from->title();
}

dataMap& dataMap::operator=(dataMap& other) {
  m_dataType    = other.dataType();
  m_mapType     = other.mapType();
  m_orientation = other.orientation();
  m_colorScheme = other.colorScheme();
  m_map         = other.map();
  m_mask        = other.mask();
  m_color       = other.color();
  m_Xpage       = other.Xpage();
  m_Ypage       = other.Ypage();
  m_pageAspect  = other.pageAspect();
  m_Xmap        = other.Xmap();
  m_Ymap        = other.Ymap();
  m_aspect      = other.aspect();
  m_maxValue    = other.max();
  m_minValue    = other.min();
  m_title       = other.title();
  
  return *this;
}

long dataMap::initialize(long x,long y) {
  m_Xpage = x;
  m_Ypage = y;
  m_pageAspect = (double)m_Xpage / (double)m_Ypage;

  m_Xmap = (long)(0.98 * (double)m_Xpage);
  m_Ymap = (long)(m_Xmap / m_aspect);

  if ((long)(m_Ymap * m_aspect) != m_Xmap)
    m_Ymap++;

  reset();

  m_map = arr2<double>(m_Xmap,m_Ymap);
  m_map.fill(0.0);
  m_mask = arr2<bool>(m_Xmap,m_Ymap);
  m_mask.fill(false);

  m_maxValue = m_minValue = 0.0;

  return m_map.size();
}

void dataMap::reset() {
  m_map.dealloc();
  m_mask.dealloc();
  m_maxValue = 0.0;
  m_minValue = 0.0;
}

void dataMap::createColorBar() {
  int width        = (int)(0.7 * m_Xpage);  // color bar spans 70% of page
  int height       = (int)(0.05 * m_Ypage); // color bar is 5% of page height
  int nHues        = 250;
  int pixelsPerHue = 1;

  if (width < nHues) {
    if (nHues < m_Xpage)
      width = nHues;
    else
      nHues = width;
  }
  else {
    pixelsPerHue = width / nHues;

    if ((pixelsPerHue*nHues < width) && ((pixelsPerHue+1)*nHues < m_Xpage)) {
      ++pixelsPerHue;
      width = pixelsPerHue * nHues;
    }
  }

  m_color = arr2<double>(width,height);

  int hues, pixels, depth;

  for (hues = 0; hues < nHues; ++hues)
    for (pixels = 0; pixels < pixelsPerHue; ++pixels)
      for (depth = 0; depth < height; ++depth)
        m_color[hues * pixelsPerHue + pixels][depth] = hues;
}

/* Should not be necessary any longer (done in mapper) */
void dataMap::findExtremes() {
  long i, j;

  for (i = m_Xmap-1; i>=0 ; --i)
    for (j = m_Ymap-1; j>=0 ; --j)
      if (m_mask[i][j]) {
        if (m_map[i][j] > m_maxValue)
          m_maxValue = m_map[i][j];
        if (m_map[i][j] < m_minValue)
          m_minValue = m_map[i][j];
     }
}

unsigned char *dataMap::transferRGBData() {
  unsigned char *bitmap = new(std::nothrow) unsigned char[m_Xpage * m_Ypage * 3];
  bmp_param bm;
  arry_param ar;
  trans_param tr;
  double label_offset;

  /* For color bar... */
  int n = 0;
  int width  = (int)(0.7 * m_Xpage);  // color bar spans 70% of page
  int height = (int)(0.05 * m_Ypage); // color bar is 5% of page height
  double val_span = fabs(m_maxValue - m_minValue);
  arr2<double> *bar;
  Raster *rl;
  char val[40];

  if (!bitmap)
    return 0;

  /* Set background of bitmap to pure white... */
  memset(bitmap,255,m_Xpage * m_Ypage * 3);

  /* Setup the bitmap copy parameters... */
  bm.ptr       = bitmap;
  bm.width     = m_Xpage;
  bm.height    = m_Ypage;

  ar.ptr       = &m_map;
  ar.mask_ptr  = &m_mask;
  ar.width     = m_Xmap;
  ar.height    = m_Ymap;

  tr.clr_fn    = m_colorScheme;
  tr.min_val   = m_minValue;
  tr.max_val   = m_maxValue;
  tr.src_xorig = 0;
  tr.src_yorig = 0;
  tr.src_xend  = m_Xmap - 1;
  tr.src_yend  = m_Ymap - 1;
  tr.dst_xorig = (m_Xpage - m_Xmap)/2;
  tr.dst_yorig = (m_Ypage - m_Ymap)/2;
  tr.dst_xend  = tr.dst_xorig + m_Xmap - 1;
  tr.dst_yend  = tr.dst_yorig + m_Ymap - 1;

  writeRGB(&bm,&ar,&tr);

  bar = new(std::nothrow) arr2<double>(width,1);
  if (bar) {
    while (n < width) {
      (*bar)[n][0] = m_minValue + ((double)n)/width * val_span;
      n++;
    }

    ar.ptr       = bar;
    ar.mask_ptr  = 0;
    ar.width     = width;
    ar.height    = 1;

    tr.clr_fn    = Linear;
    tr.src_xend  = width - 1;
    tr.src_yend  = 0;
    tr.dst_xorig = (m_Xpage - width)/2;
    tr.dst_yorig = m_Ypage * .89;
    tr.dst_xend  = tr.dst_xorig + width - 1;
    tr.dst_yend  = tr.dst_yorig + height - 1;

    writeRGB(&bm,&ar,&tr);

    delete bar;
  }

  rl = new Raster(m_Xpage,m_Ypage,3,bitmap);
  rl->bitmapFontFace(FONT_NAME,40);
  label_offset = rl->bitmapFontLength(m_title.c_str())/2;
  rl->translate(m_Xpage * .5 - label_offset,m_Ypage *.05);
  rl->color(0,0,0);
  rl->bitmapFontString(m_title.c_str());

  rl->bitmapFontFace(FONT_NAME,15);
  rl->identity();
  sprintf(val,"%.4e",m_minValue);
  label_offset = rl->bitmapFontLength(val)/2;
  rl->translate((m_Xpage - width)/2 - label_offset,m_Ypage * .97);
  rl->bitmapFontString(val);
  sprintf(val,"%.4e",m_maxValue);
  rl->translate(width,0);
  rl->bitmapFontString(val);

  delete rl;
  return bitmap;
}

/* All-in-one function which handles coloration, and scaled copy... */
void dataMap::writeRGB(bmp_param *bm, arry_param *ar, trans_param *tr) {
  unsigned wheel_sector;
  unsigned char partial, *pix_ptr = 0;
  int x, y, yspan, xspan;
  int dx = 0, dy = 0, dst_x, dst_y, fill_x, fill_y, fill_to_x, fill_to_y;
  rgb_value *pix = 0, *pix_mark = 0;
  double value, norm_value, fraction;
  double data_span, log_max, s_log_max;
  double x_ratio, y_ratio;

  if (!bm || !bm->ptr || !ar || !ar->ptr || !tr) {
    printf("parameter error.\n");
    return;
  }

  /* Check for valid parameters... */
  if (tr->dst_xend >= bm->width || tr->src_xend >= ar->width ||
      tr->dst_yend >= bm->height || tr->src_yend >= ar->height ||
      tr->dst_xorig < 0 || tr->src_xorig < 0 ||
      tr->dst_yorig < 0 || tr->src_yorig < 0 ||
      tr->dst_xend < tr->dst_xorig || tr->dst_yend < tr->dst_yorig ||
      tr->src_xend < tr->src_xorig || tr->src_yend < tr->src_yorig) {
    printf("image bounds or tranfer area error.\n");
    return;
  }

  /* Calculate the color functions max/min values... */
  data_span = fabs(tr->max_val - tr->min_val);
  log_max   = log10(data_span + 1.0);
  s_log_max = log10(log10(data_span + 1.0) + 1.0);

  /* We will do assigment relative to the source array indices... */
  yspan   = tr->src_yend - tr->src_yorig + 1;
  xspan   = tr->src_xend - tr->src_xorig + 1;
  x_ratio = ((double)(tr->dst_xend - tr->dst_xorig + 1))/xspan;
  y_ratio = ((double)(tr->dst_yend - tr->dst_yorig + 1))/yspan;

  if (x_ratio > 1)
    dx = (int)x_ratio;
  if (y_ratio > 1)
    dy = (int)y_ratio;

  y = 0;
  while (y < yspan) {
    x = 0;
    while (x < xspan) {
      /* See if this pixel is masked... */
      if (ar->mask_ptr && !(*ar->mask_ptr)[tr->src_xorig + x][tr->src_yorig + y]) {
        x++;
        continue;
      }
      value = (*ar->ptr)[tr->src_xorig + x][tr->src_yorig + y];

      /* Hue-value transfer functions... */
      switch (tr->clr_fn) {
        default:
        case Linear:
          norm_value = (value - tr->min_val)/data_span;
          break;
        case Log:
          norm_value = log10(value - tr->min_val + 1)/log_max;
          break;
        case SuperLog:
          norm_value = log10(log10(value - tr->min_val + 1) + 1)/s_log_max;
          break;
      }

      if (norm_value > 1)
        norm_value = 1;
      if (norm_value < 0)
        norm_value = 0;

      /* using reverse coloration... */
      norm_value   = 1 - norm_value;

      norm_value  *= HUE_TRUNCATE;
      wheel_sector = norm_value * COLOR_WHEEL_SPAN;
      fraction     = (COLOR_WHEEL_SPAN * norm_value) - wheel_sector;
      partial      = ((MAX_VAL - MIN_VAL) * fraction) + MIN_VAL;

      /* Translate the current array location into a bitmap index using
      3 bytes per index/pixel and the scaling factors (x_ratio, y_ratio),
      We cast the unsigned char pointer to a rgb_value struct for
      assignment ease/clarity... */

      dst_y   = tr->dst_yorig + ((int)(y * y_ratio));
      dst_x   = tr->dst_xorig + ((int)(x * x_ratio));
      pix_ptr = bm->ptr + 3 * ((dst_y * bm->width) + dst_x);
      pix     = (rgb_value*)pix_ptr;

      /* These cases correspond to sectors on the standard color wheel.
         See illustration at:
            http://en.wikipedia.org/wiki/File:HSV-RGB-comparison.svg  */

      switch (wheel_sector) {
        case DEG_0_TO_LESS_60:
          pix->r = MAX_VAL;
          pix->g = partial;
          pix->b = MIN_VAL;
          break;
        case DEG_60_TO_LESS_120:
          pix->r = MAX_VAL - partial;
          pix->g = MAX_VAL;
          pix->b = MIN_VAL;
          break;
        case DEG_120_TO_LESS_180:
          pix->r = MIN_VAL;
          pix->g = MAX_VAL;
          pix->b = partial;
          break;
        case DEG_180_TO_LESS_240:
          pix->r = MIN_VAL;
          pix->g = MAX_VAL - partial;
          pix->b = MAX_VAL;
          break;
        case DEG_240_TO_LESS_300:
          pix->r = partial;
          pix->g = MIN_VAL;
          pix->b = MAX_VAL;
          break;
        case DEG_300_TO_LESS_360:
          pix->r = MAX_VAL;
          pix->g = MIN_VAL;
          pix->b = MAX_VAL - partial;
          break;
      }

      /* If upscaled, fill in the missing destination pixel info.
         By default, any  x or y upscale will cause an adjacent
         pixel copy, even if it is not required for this particular
         interation--this insures that no empty areas are left due to
         double->int conversion issues.*/

      if (dx || dy) {
        fill_x    = dst_x;
        fill_y    = dst_y;
        fill_to_x = dst_x + dx + 1;
        fill_to_y = dst_y + dy + 1;
        pix_mark  = pix;

        if (fill_to_x > bm->width)
          fill_to_x = bm->width;
        if (fill_to_y > bm->height)
          fill_to_y = bm->height;

        if (dx) {
          fill_x++;

          while (fill_x < fill_to_x) {
            pix_ptr = bm->ptr + 3 * ((dst_y * bm->width) + fill_x);
            pix     = (rgb_value*)pix_ptr;
            *pix    = *pix_mark;
            fill_x++;
          }
        }

        if (dy) {
          fill_y++;

          if (!dx && fill_to_x < bm->width)
            fill_to_x++;

          while (fill_y < fill_to_y) {
            fill_x = dst_x;

            while (fill_x < fill_to_x) {
              pix_ptr = bm->ptr + 3 * ((fill_y * bm->width) + fill_x);
              pix     = (rgb_value*)pix_ptr;
              *pix    = *pix_mark;
              fill_x++;
            }
            fill_y++;
          }
        }
      }

      x++;
    }
    y++;
  }
}

