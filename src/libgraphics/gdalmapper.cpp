/****************************************************************************
                              \gdalmapper.cpp
Description:\brief (put short description here)

Begin    : Tue Jun 7 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#include <iostream>
#include <math.h>
#include <ogr_srs_api.h>
#include <healpix_cxx/healpix_base.h>
// extern "C" {
//   #include "chealpix.h"
// }

#include "../libanalyzer/healpix.h"

#include "gdalmapper.h"
#include "datamap.h"
#include "../libanalyzer/basedata.h"
#include "../libanalyzer/vectordata.h"
#include "../libanalyzer/inputmatrixdata.h"

GDALMapper::GDALMapper()
           : Mapper() {
  m_aspect         = 2.0;
  m_edge           = 1.02;
//  m_threadingContext      = proj_context_create();
  m_geodetic       = 0;
  m_projection     = 0;
  m_coordTransform = 0;
//  m_geodeticCoords.lpzt.z = 0.0;
//  m_geodeticCoords.lpzt.t = HUGE_VAL;
  m_active         = false;
}

GDALMapper::GDALMapper(GDALMapper* from)
           : Mapper(from) {
//  m_threadingContext = from->threadingContext();
  m_projection      = from->projection();
  m_geodetic        = from->geodetic();
  m_coordTransform  = from->coordTransform();
  m_projString      = from->projString();
}

GDALMapper::~GDALMapper() {
  clear();
}

/* Allows selection of alternate pixelizer, removes checks from map loop... */
int GDALMapper::makeMap(dataMap *map, FILETYPE dataTypes, association* dataClasses) {
  if (!dataClasses)
    return 0;
  if (!dataClasses->exists(dataTypes))
    return 0;

  /* save data type to associated map */
  map->dataType(dataTypes);
  switch (dataTypes) {
    /* Data types which require pixelizer and defined pixelized data... */
    case fileType::PixelizedData:
    case fileType::WeightedPixel:
    case fileType::PixelizedWeights:
    case fileType::PixelOccupancy:
    case fileType::PixelizedNoise:
    case fileType::PixelizedFilter:
    case fileType::PixelizedBeam:
      if (!dataClasses->exists(dataTypes))
        break;
      if (dataTypes == fileType::PixelOccupancy) {
        if (((vectorData<int>*)dataClasses->getData(dataTypes))->pixelScheme() == HealPIX)
          return makeMapHealpix(map,dataTypes,dataClasses);
      }
      else {
        if (((vectorData<double>*)dataClasses->getData(fileType::PixelizedData))->pixelScheme() == HealPIX)
          return makeMapHealpix(map,dataTypes,dataClasses);
      }
      break;
    /* Data types which require pixelizer only... */
    case fileType::InverseData:
    case fileType::InverseWeights:
      if (((vectorData<double>*)dataClasses->getData(dataTypes))->pixelScheme() == HealPIX)
        return makeMapHealpix(map,dataTypes,dataClasses);
      break;
    /* Map operation is undefined on these data types... */
    case fileType::TransformedNoise:
    case fileType::TransformedBeam:
    case fileType::TransformedFilter:
    case fileType::TransformedData:
    case fileType::TransformedWeights:
    case fileType::SpectralData:
    case fileType::AlmData:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
    case fileType::Null:
      break;
    /* Doesn't matter--data type will not use pixelizer... */
    default:
      return makeMapHealpix(map,dataTypes,dataClasses);
  }

  /* Error condition: return size zero. */
  return 0;
}

int GDALMapper::makeMapHealpix(dataMap *map, FILETYPE dataTypes, association* dataClasses) {
  matrixData<double> *mat_dat_ptr = 0, *mat_wht_ptr = 0;
  vectorData<double> *vec_dat_ptr = 0, *vec_wht_ptr = 0;
  vectorData<int>    *vec_int_ptr = 0;
  Healpix_Base       *healpix     = 0;
  pointing           *ang         = 0;
  int                count        = 0;
  long               max          = map->Xmap() * map->Ymap();

  /* Set data pointers... */
  switch (dataTypes) {
    case fileType::InputData:
      mat_dat_ptr = dataClasses->inputData();
      break;
    case fileType::InputWeights:
      mat_wht_ptr = dataClasses->inputWeights();
      break;
    case fileType::WeightedData:
      mat_dat_ptr = dataClasses->inputData();
      mat_wht_ptr = dataClasses->inputWeights();
      break;
    case fileType::PixelizedData:
      vec_dat_ptr = dataClasses->pixelizedData();
      break;
    case fileType::PixelizedWeights:
      vec_wht_ptr = dataClasses->pixelizedWeights();
      break;
    case fileType::WeightedPixel:
      vec_dat_ptr = dataClasses->pixelizedData();
      vec_wht_ptr = dataClasses->pixelizedWeights();
       break;
    case fileType::PixelOccupancy:
      vec_int_ptr = dataClasses->pixelOccupancy();
      vec_wht_ptr = dataClasses->pixelizedWeights();
      break;
    case fileType::InverseData:
      vec_dat_ptr = dataClasses->inverseData();
      break;
    case fileType::InverseWeights:
      vec_wht_ptr = dataClasses->inverseWeights();
      break;
    default:
      break;
  }

  /* Do Healpix configuration... */
  switch (dataTypes) {
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::PixelOccupancy:
      healpix = new Healpix_Base();
      healpix->SetNside((const int)(dataClasses->pixelizedData()->sides()),(Healpix_Ordering_Scheme)(dataClasses->pixelizedData()->layout() - 1));
      break;
    case fileType::InverseData:
    case fileType::InverseWeights:
      healpix = new Healpix_Base();
      healpix->SetNside((const int)(dataClasses->inverseData()->sides()),(Healpix_Ordering_Scheme)(dataClasses->inverseData()->layout() - 1));
      break;
    default:
      break;
  }

  /* Find center of map */
  int xCenter      = (map->Xmap() - 1)/2;
  int yCenter      = (map->Ymap() - 1)/2;
  int dx           = (map->Xmap() - 1) - xCenter;
  int dy           = (map->Ymap() - 1) - yCenter;

  double direction = (map->orientation() == Terrestrial) ? 1.0 : -1.0;
  double max_val   = 0.0;
  double min_val   = 0.0;
  long i           = 0;
  long j           = 0;

  /* Create CRS for flat array */
  if (m_geodetic) {
    m_geodetic->Release();
    m_geodetic = 0;
  }
  m_geodetic = new OGRSpatialReference();
  m_geodetic->SetGeogCS("Celestial Sphere",
                        "World Geodtic System 1984",  // use this datum but set the inverse flattening to 0
                        "Modified spheroid with zero flattening to emulate celestial sphere",
                        SRS_WGS84_SEMIMAJOR,          // corresponds to the radius of the Earth, 6378137.0 meters. Should not matter in creating map
                        1.0E308,                      // make this a big number since the flattening is ideally zero
                        "Spring equinox",
                        0.0,
                        SRS_UA_DEGREE,
                        180.0/M_PI);
  /* Create map */
  switch (m_mapType) {
    case Mollweide:
      m_projString = "+proj=moll +type=crs";
      break;
    case Aitoff:
      m_projString = "+proj=aitoff +type=crs";
      break;
    case Gnomonic:
      m_projString = "+proj=gnom +type=crs";
      break;
    default:
      break;
  }
  if (m_projection) {
    m_projection->Release();
    m_projection = 0;
  }
  m_projection = new OGRSpatialReference();
  m_projection->importFromProj4(m_projString.c_str());
  if (m_coordTransform) {
    m_coordTransform->DestroyCT(m_coordTransform);
    m_coordTransform = 0;
  }
  m_coordTransform = OGRCreateCoordinateTransformation(m_geodetic,m_projection);


  //replace this part
  for (count = 0; count < max; count++) {
    double u     = map->aspect() * ((double)(i - xCenter))/(double)(dx/m_edge);
    double v     = (double)(j - yCenter)/(double)(dy/m_edge);
    double point = u * u / 4 + v * v;

    if (point <= 1.0) {
      double angle = asin(M_2_PI * (asin(v) + v * sqrt((1.0 - v) * (1.0 + v))));
      double lat   = M_PI_2 + angle;
      double test  = sqrt((1.0 - v) * (1.0 + v));
      double denom = (test < 1.0e-6) ? 1.0e-6 : test;
      double lon   = (direction * M_PI_2 * u / denom) + M_PI;
      double value = 0;
      long xPos, yPos;

      switch (dataTypes) {
        case fileType::InputData:
          /* Convert latitude and longitude to degrees... */
          lat *= 180.0/M_PI;
          lon *= 180.0/M_PI;
          lat  = lat - 90.0;
          lon  = 180.0 - lon;

          mat_dat_ptr->angle2bin(lat,lon,xPos,yPos);
//          if ((*mat_dat_ptr)[xPos][yPos] > 0)
//            double position = (*mat_dat_ptr)[xPos][yPos];
          value = (*mat_dat_ptr)[xPos][yPos];
          if (mat_wht_ptr)
            value *= (*mat_wht_ptr)[xPos][yPos];
          break;
        case fileType::InputWeights:
          /* Convert latitude and longitude to degrees... */
          lat *= 180.0/M_PI;
          lon *= 180.0/M_PI;
//          lat  = lat - 90.0;
//          lon  = 180.0 - lon;
          mat_wht_ptr->angle2bin(lat,lon,xPos,yPos);
          value = (*mat_wht_ptr)[xPos][yPos];
          break;
        case fileType::WeightedData:
          /* Convert latitude and longitude to degrees... */
          lat *= 180.0/M_PI;
          lon *= 180.0/M_PI;
//          lat  = lat - 90.0;
//          lon  = 180.0 - lon;
          mat_dat_ptr->angle2bin(lat,lon,xPos,yPos);
          value = (*mat_dat_ptr)[xPos][yPos] * (*mat_wht_ptr)[xPos][yPos];
          break;
        case fileType::PixelizedData:
          lon  = M_PI - lon;
          xPos = (long)(healpix->ang2pix(pointing(lat,lon)));
          value = (*vec_dat_ptr)[xPos];
          break;
        case fileType::PixelizedWeights:
          lon  = M_PI - lon;
          xPos = (long)(healpix->ang2pix(pointing(lat,lon)));
          value = (*vec_wht_ptr)[xPos];
          break;
        case fileType::WeightedPixel:
          lon  = M_PI - lon;
          xPos = (long)(healpix->ang2pix(pointing(lat,lon)));
          value = (*vec_dat_ptr)[xPos] * (*vec_wht_ptr)[xPos];
          break;
        case fileType::PixelOccupancy:
          lon  = M_PI - lon;
          xPos = (long)(healpix->ang2pix(pointing(lat,lon)));
          if (vec_wht_ptr)
            value = (*vec_int_ptr)[xPos] * (*vec_wht_ptr)[xPos];
          else
            value = (*vec_int_ptr)[xPos];
          break;
        case fileType::InverseData:
          lon  = M_PI - lon;
          xPos = (long)(healpix->ang2pix(pointing(lat,lon)));
          value = (*vec_dat_ptr)[xPos];
          break;
        case fileType::InverseWeights:
          lon  = M_PI - lon;
          xPos = (long)(healpix->ang2pix(pointing(lat,lon)));
          value = (*vec_wht_ptr)[xPos];
          break;
        default:
          break;
      }

      map->mask()[i][j] = true;
      map->map()[i][j] += value;

      if (value > max_val)
        max_val = value;
      if (value < min_val)
        min_val = value;
    }

    j++;
    if (j == map->Ymap()) {
      i++;
      j = 0;
    }
  }

  /* Addition of max/min direct write to datamap... */
  map->max(max_val);
  map->min(min_val);

  if (healpix)
    delete healpix;

  m_active = true;

  return count;
}

void GDALMapper::clear() {
//  proj_destroy(m_projection);
//  proj_destroy(m_geodetic);
//  proj_destroy(m_projTransform);
//  proj_context_destroy(m_threadingContext);
//  m_projString.clear();
  Mapper::clear();
}
