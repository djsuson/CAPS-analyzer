/***************************************************************************
 *   dataspectrum.cpp                                                      *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include "dataspectrum.h"
#include "raster.h"

#define FONT_NAME    "/usr/share/fonts/TTF/DejaVuSans.ttf"
#define AREA_SPAN    0.85
#define RGB_SIZE     3
#define AREA_OFFSET  0.1
#define SCALE_OFFSET 0.02
#define MAJOR_TICK   0.01
#define MINOR_TICK   0.005
#define X_AXIS_DIVS  4
#define Y_AXIS_DIVS  5
#define SUB_DIVS     5

dataSpectrum::dataSpectrum() {
  // initialize values
  m_dataType   = fileType::Null;
  m_title      = "Spectral Data";
  m_xtitle     = "Angular Scale Index";
  m_ytitle     = "Spectral Strength";
  m_minIndex   = 0;
  m_maxIndex   = 0;
  m_minValue   = 0.0;
  m_maxValue   = 0.0;
  m_pageAspect = 4.0 / 3.0;
  m_Xpage      = 800;
  m_Ypage      = (long)(m_Xpage / m_pageAspect);
}

dataSpectrum::dataSpectrum(FILETYPE type) {
  dataSpectrum();
  m_dataType = type;
  switch (m_dataType) {
    case fileType::TransformedNoise:
      m_title = "Noise Data Spectrum";
      break;
    case fileType::TransformedFilter:
      m_title = "Filter Data Spectrum";
      break;
    case fileType::TransformedBeam:
      m_title = "Beam Data Spectrum";
      break;
    case fileType::TransformedData:
      m_title = "Transformed Data Spectrum";
      break;
    case fileType::TransformedWeights:
      m_title = "Transformed Weights Spectrum";
      break;
    case fileType::SpectralData:
      m_title = "Extrapolated Data Spectrum";
      break;
    default:
      break;
  }
}

dataSpectrum::dataSpectrum(dataSpectrum* from) {
  m_dataType   = from->dataType();
  m_minIndex   = from->minIndex();
  m_maxIndex   = from->maxIndex();
  m_minValue   = from->minValue();
  m_maxValue   = from->maxValue();
  m_Xpage      = from->Xpage();
  m_Ypage      = from->Ypage();
  m_pageAspect = from->pageAspect();
  m_Xgraph     = from->Xgraph();
  m_Ygraph     = from->Ygraph();
  m_aspect     = from->aspect();
  m_title      = from->title();
  m_xtitle     = from->xtitle();
  m_ytitle     = from->ytitle();
  m_graph      = from->graph();
}

dataSpectrum& dataSpectrum::operator=(dataSpectrum& other) {
  m_dataType   = other.dataType();
  m_minIndex   = other.minIndex();
  m_maxIndex   = other.maxIndex();
  m_minValue   = other.minValue();
  m_maxValue   = other.maxValue();
  m_Xpage      = other.Xpage();
  m_Ypage      = other.Ypage();
  m_pageAspect = other.pageAspect();
  m_Xgraph     = other.Xgraph();
  m_Ygraph     = other.Ygraph();
  m_aspect     = other.aspect();
  m_title      = other.title();
  m_xtitle     = other.xtitle();
  m_ytitle     = other.ytitle();
  m_graph      = other.graph();
  
  return *this;
}

void dataSpectrum::reset() {
  m_graph.dealloc();
  m_minIndex = m_maxIndex = 0;
  m_minValue = m_maxValue = 0.0;
}

long int dataSpectrum::initialize(long int x, long int y) {
  m_Xpage = x;
  m_Ypage = y;
  m_pageAspect = (double)m_Xpage / (double)m_Ypage;

  m_Xgraph = (long)(AREA_SPAN * (double)m_Xpage);
  m_Ygraph = (long)(m_Xgraph / m_aspect);

  if ((long)(m_Ygraph * m_aspect) != m_Xgraph)
    m_Ygraph++;

  reset();

  m_graph = arr<double>(m_Xgraph);
  m_graph.fill(0.0);

  m_maxIndex = m_minIndex = 0;
  m_minValue = m_maxValue = 0.0;

  return m_graph.size();
}

void dataSpectrum::title(std::string value) {
  m_title = value + " Spectrum";
}

unsigned char* dataSpectrum::transferRGBData() {
  Raster *rl;
  double label_offset, max_value, min_value, value_div;
  int n, max_index;
  char label[40];

  unsigned char* bitmap = new(std::nothrow) unsigned char[m_Xpage * m_Ypage * RGB_SIZE];
  if (!bitmap)
   return 0;

  // make bitmap background white
  memset(bitmap,255,m_Xpage * m_Ypage * RGB_SIZE);
   
  rl = new(std::nothrow) Raster(m_Xpage,m_Ypage,RGB_SIZE,bitmap);
  if (!rl)
    return 0;

  /* Translate and normalize to grid area */
  rl->pixelMode(RASTER_NEAREST);
  rl->translate(m_Xpage * AREA_OFFSET, m_Ypage * AREA_OFFSET/2);
  rl->scale(m_Xgraph,m_Ygraph);

  /* Make the grid... */
  n = 0;
  while (n < 25) {
    if (!(n%5))
      rl->color(.6,.6,.6);
    else
      rl->color(.9,.9,.9);
    rl->begin(RASTER_LINES);
    rl->vertex(0,n * .04);
    rl->vertex(1,n * .04);
    rl->end();
    n++;
  }

  n = 0;
  while (n < 20) {
    if (!(n%5))
      rl->color(.6,.6,.6);
    else
      rl->color(.9,.9,.9);
    rl->begin(RASTER_LINES);
    rl->vertex(n * .05,0);
    rl->vertex(n * .05,1);
    rl->end();
    n++;;
  }

  /* Make the border... */
  rl->color(0,0,0);
  rl->pointSize(2);
  rl->begin(RASTER_LINE_LOOP);
  rl->vertex(0,0);
  rl->vertex(0,1);
  rl->vertex(1,1);
  rl->vertex(1,0);
  rl->end();

  /* Make the scale ticks */
  rl->color(0,0,1);
  rl->pointSize(1);

  rl->undoLast();
  rl->translate(-m_Xpage * (SCALE_OFFSET - MINOR_TICK),0);
  rl->scale(m_Xpage * MINOR_TICK, m_Ygraph);

  n = 0;
  while (n <= 25) {
    rl->begin(RASTER_LINES);
    rl->vertex(0 - !(n%5),n * .04);
    rl->vertex(1,n * .04);
    rl->end();
    n++;
  }

  rl->begin(RASTER_LINES);
  rl->vertex(1,0);
  rl->vertex(1,1);
  rl->end();

  rl->undoLast();
  rl->undoLast();
  rl->translate(0, m_Ygraph + m_Xpage * (SCALE_OFFSET - MAJOR_TICK));
  rl->scale(m_Xgraph, m_Xpage * MINOR_TICK);

  n = 0;
  while (n <= 20) {
    rl->begin(RASTER_LINES);
    rl->vertex(n * .05,0);
    rl->vertex(n * .05,1 + !(n%5));
    rl->end();
    n++;
  }

  rl->begin(RASTER_LINES);
  rl->vertex(0,0);
  rl->vertex(1,0);
  rl->end();

  /* All Labels... */
  rl->bitmapFontFace(FONT_NAME,15);
  rl->color(0,0,1);

  rl->identity();
  label_offset = rl->bitmapFontLength(m_ytitle.c_str())/2;
  rl->translate(m_Xpage * .02, m_Ypage * AREA_OFFSET/2 + m_Ygraph/2 + label_offset);
  rl->rotate(-90);
  rl->bitmapFontString(m_ytitle.c_str());

  rl->identity();
  label_offset = rl->bitmapFontLength(m_xtitle.c_str())/2;
  rl->translate(m_Xpage * AREA_OFFSET + m_Xgraph/2 - label_offset, m_Ypage - (m_Ypage * .03));
  rl->bitmapFontString(m_xtitle.c_str());

  rl->bitmapFontFace(FONT_NAME,25);
  rl->color(0,0,0);
  rl->identity();
  label_offset = rl->bitmapFontLength(m_title.c_str())/2;
  rl->translate(m_Xpage * .5 - label_offset, 25);
  rl->bitmapFontString(m_title.c_str());

  max_index = m_maxIndex - m_minIndex;

  /* Adds a buffer area to top of graph... */
  max_value = m_maxValue * 1.1;
  value_div = max_value/5;

  /* Y axis labels... */
  rl->bitmapFontFace(FONT_NAME,10);
  rl->identity();
  rl->translate(m_Xpage * AREA_OFFSET, m_Ypage * AREA_OFFSET/2);
  rl->translate(-m_Xpage * SCALE_OFFSET * 1.25, 5);

  n = 0;
  while (n < 5) {
    sprintf(label,"%.3e",max_value - n * value_div);
    label_offset = rl->bitmapFontLength(label);
    rl->translate(-label_offset, m_Ygraph * n/5.0);
    rl->bitmapFontString(label);
    rl->undoLast();
    n++;
  }

  label_offset = rl->bitmapFontLength("0");
  rl->translate(-label_offset, m_Ygraph);
  rl->translate(0, 1);
  rl->bitmapFontString("0");

   /* X axis labels... */
  rl->identity();
  rl->translate(m_Xpage * AREA_OFFSET, m_Ypage * AREA_OFFSET/2);
  rl->translate(0, m_Ygraph + m_Xpage * SCALE_OFFSET + 15);

  label_offset = rl->bitmapFontLength("0")/2;
  rl->translate(-label_offset,0);
  rl->bitmapFontString("0");
  rl->undoLast();

  n = 1;
  while (n < 5) {
    sprintf(label,"%d",(n * max_index)/4);
    label_offset = rl->bitmapFontLength(label)/2;
    rl->translate(-label_offset + m_Xgraph * n/4.0, 0);
    rl->bitmapFontString(label);
    rl->undoLast();
    n++;
  }

  /* graph actual data */
  rl->identity();
  rl->translate(m_Xpage * AREA_OFFSET, m_Ypage * AREA_OFFSET/2);
  rl->translate(0, m_Ygraph);
  rl->scale(m_Xgraph/max_index, m_Ygraph/max_value);

  rl->color(1,0,0);
  n = 0;

  rl->begin(RASTER_LINE_STRIP);
  while (n < m_graph.size()) {
    rl->vertex(n,-m_graph[n]);
    n++;
  }
  rl->end();

  delete rl;
  return bitmap;
}
