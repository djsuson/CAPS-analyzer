/****************************************************************************
                              \mollweide.cpp
Description:\brief (put short description here)

Begin    : Tue Jun 7 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#include <iostream>
#include <math.h>
#include <healpix_cxx/healpix_base.h>
// extern "C" {
//   #include "chealpix.h"
// }

#include "../libanalyzer/healpix.h"

#include "mollweide.h"
#include "datamap.h"
#include "../libanalyzer/basedata.h"
#include "../libanalyzer/vectordata.h"
#include "../libanalyzer/inputmatrixdata.h"

MollweideMapper::MollweideMapper()
                : Mapper() {
  m_mapType = Mollweide;
  m_aspect  = 2.0;
  m_edge    = 1.02;
  m_active  = false;
}

MollweideMapper::MollweideMapper(MollweideMapper* from)
                :Mapper(from) {

}

MollweideMapper::~ MollweideMapper() {
  clear();
}

/* Allows selection of alternate pixelizer, removes checks from map loop... */
int MollweideMapper::makeMap(dataMap *map, FILETYPE dataTypes, association* dataClasses) {
  if (!dataClasses)
    return 0;
  if (!dataClasses->exists(dataTypes))
    return 0;

  /* save data type to associated map */
  map->dataType(dataTypes);
  switch (dataTypes) {
    /* Data types which require pixelizer and defined pixelized data... */
    case fileType::PixelizedData:
    case fileType::WeightedPixel:
    case fileType::PixelizedWeights:
    case fileType::PixelOccupancy:
    case fileType::PixelizedNoise:
    case fileType::PixelizedFilter:
    case fileType::PixelizedBeam:
      if (dataTypes == fileType::PixelOccupancy) {
        if (((vectorData<int>*)dataClasses->getData(dataTypes))->pixelScheme() == HealPIX)
          return makeMapHealpix(map,dataTypes,dataClasses);
      }
      else {
        if (((vectorData<double>*)dataClasses->getData(fileType::PixelizedData))->pixelScheme() == HealPIX)
          return makeMapHealpix(map,dataTypes,dataClasses);
      }
      break;
    /* Data types which require pixelizer only... */
    case fileType::InverseData:
    case fileType::InverseWeights:
    case fileType::WeightedInverse:
    case fileType::InverseNoise:
    case fileType::InverseFilter:
    case fileType::InverseBeam:
      if (((vectorData<double>*)dataClasses->getData(dataTypes))->pixelScheme() == HealPIX)
        return makeMapHealpix(map,dataTypes,dataClasses);
      break;
    /* Map operation is undefined on these data types... */
    case fileType::TransformedNoise:
    case fileType::TransformedBeam:
    case fileType::TransformedFilter:
    case fileType::TransformedData:
    case fileType::TransformedWeights:
    case fileType::SpectralData:
    case fileType::AlmData:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
    case fileType::Null:
      break;
    /* Doesn't matter--data type will not use pixelizer... */
    default:
      return makeMapHealpix(map,dataTypes,dataClasses);
  }

  /* Error condition: return size zero. */
  return 0;
}

int MollweideMapper::makeMapHealpix(dataMap *map, FILETYPE dataTypes, association* dataClasses) {
  matrixData<double> *pri_mat_ptr = 0, *sec_mat_ptr = 0;
  vectorData<double> *pri_vec_ptr = 0, *sec_vec_ptr = 0;
  vectorData<int>    *vec_int_ptr = 0;
  Healpix_Base       *healpix     = 0;
  pointing           *ang         = 0;
  int                count        = 0;
  long               max          = map->Xmap() * map->Ymap();

  /* Set data pointers... */
  switch (dataTypes) {
    case fileType::InputData:
      pri_mat_ptr = dataClasses->inputData();
      break;
    case fileType::InputWeights:
      pri_mat_ptr = dataClasses->inputWeights();
      break;
    case fileType::WeightedData:
      pri_mat_ptr = dataClasses->inputData();
      sec_mat_ptr = dataClasses->inputWeights();
      break;
    case fileType::InputNoise:
      pri_mat_ptr = dataClasses->inputNoise();
      break;
    case fileType::InputFilter:
      pri_mat_ptr = dataClasses->inputFilter();
      break;
    case fileType::InputBeam:
      pri_mat_ptr = dataClasses->inputBeam();
      break;
    case fileType::PixelizedData:
      pri_vec_ptr = dataClasses->pixelizedData();
      break;
    case fileType::PixelizedWeights:
      pri_vec_ptr = dataClasses->pixelizedWeights();
      break;
    case fileType::WeightedPixel:
      pri_vec_ptr = dataClasses->pixelizedData();
      sec_vec_ptr = dataClasses->pixelizedWeights();
       break;
    case fileType::PixelOccupancy:
      vec_int_ptr = dataClasses->pixelOccupancy();
      sec_vec_ptr = dataClasses->pixelizedWeights();
      break;
    case fileType::PixelizedNoise:
      pri_vec_ptr = dataClasses->pixelizedNoise();
      break;
    case fileType::PixelizedFilter:
      pri_vec_ptr = dataClasses->pixelizedFilter();
      break;
    case fileType::PixelizedBeam:
      pri_vec_ptr = dataClasses->pixelizedBeam();
      break;
    case fileType::InverseData:
      pri_vec_ptr = dataClasses->inverseData();
      break;
    case fileType::InverseWeights:
      pri_vec_ptr = dataClasses->inverseWeights();
      break;
    case fileType::WeightedInverse:
      pri_vec_ptr = dataClasses->inverseData();
      sec_vec_ptr = dataClasses->inverseWeights();
      break;
    case fileType::InverseNoise:
      pri_vec_ptr = dataClasses->inverseNoise();
      break;
    case fileType::InverseFilter:
      pri_vec_ptr = dataClasses->inverseFilter();
      break;
    case fileType::InverseBeam:
      pri_vec_ptr = dataClasses->inverseBeam();
      break;
    default:
      break;
  }

  /* Do Healpix configuration... */
  if (pri_vec_ptr || vec_int_ptr) {
    healpix = new Healpix_Base();
    if (pri_vec_ptr)
      healpix->SetNside((const int)(pri_vec_ptr->sides()),(Healpix_Ordering_Scheme)(pri_vec_ptr->layout() - 1));
    else
      healpix->SetNside((const int)(vec_int_ptr->sides()),(Healpix_Ordering_Scheme)(vec_int_ptr->layout() - 1));
  }

  /* Find center of map */
  int xCenter      = (map->Xmap() - 1)/2;
  int yCenter      = (map->Ymap() - 1)/2;
  int dx           = (map->Xmap() - 1) - xCenter;
  int dy           = (map->Ymap() - 1) - yCenter;

  double direction = (map->orientation() == Terrestrial) ? -1.0 : 1.0;
  double max_val   = 0.0;
  double min_val   = 0.0;
  long i           = 0;
  long j           = 0;

  /* Create map */
  for (count = 0; count < max; count++) {
    double u     = map->aspect() * ((double)(i - xCenter))/(double)(dx/m_edge);
    double v     = (double)(j - yCenter)/(double)(dy/m_edge);
    double point = u * u / 4 + v * v;

    if (point <= 1.0) {
      double angle = asin(M_2_PI * (asin(v) + v * sqrt((1.0 - v) * (1.0 + v))));
      double lat   = M_PI_2 + angle;
      double test  = sqrt((1.0 - v) * (1.0 + v));
      double denom = (test < 1.0e-6) ? 1.0e-6 : test;
//      double lon   = (direction * M_PI_2 * u / denom) + M_PI;
      double lon   = (direction * M_PI_2 * u / denom);
      double value = 0;
      long xPos, yPos;

      if (pri_mat_ptr) {
        /* Convert latitude and longitude to degrees... */
        lat *= 180.0/M_PI;
        lon *= 180.0/M_PI;
        lat  = 90.0 - lat;
//        lon  = lon - 180.0;

        pri_mat_ptr->angle2bin(lat,lon,xPos,yPos);
//        if ((*pri_mat_ptr)[xPos][yPos] > 0)
//          double position = (*pri_mat_ptr)[xPos][yPos];
        value = (*pri_mat_ptr)[xPos][yPos];
        if (sec_mat_ptr)
          value *= (*sec_mat_ptr)[xPos][yPos];
      }

      if (pri_vec_ptr || vec_int_ptr) {
        lon  = M_PI - lon;
        xPos = (long)(healpix->ang2pix(pointing(lat,lon)));
        if (pri_vec_ptr)
          value = (*pri_vec_ptr)[xPos];
        else
          value = (*vec_int_ptr)[xPos];
        if (sec_vec_ptr)
          value *= (*sec_vec_ptr)[xPos];
      }

      map->mask()[i][j] = true;
      map->map()[i][j] += value;

      if (value > max_val)
        max_val = value;
      if (value < min_val)
        min_val = value;
    }

    j++;
    if (j == map->Ymap()) {
      i++;
      j = 0;
    }
  }

  /* Addition of max/min direct write to datamap... */
  map->max(max_val);
  map->min(min_val);

  if (healpix)
    delete healpix;

  m_active = true;

  return count;
}

void MollweideMapper::clear() {
  Mapper::clear();
}
