/***************************************************************************
 *   datamap.h                                                             *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This class stores the bitmap associated with a particular type of data  *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#ifndef _DATAMAP_H_
#define _DATAMAP_H_

#include <string>

#include "healpix_cxx/arr.h"
#include "../libanalyzer/basedata.h"
#include "../libanalyzer/vectordata.h"
#include "../libanalyzer/matrixdata.h"

typedef struct { unsigned char r,g,b; } rgb_value;
typedef struct { unsigned char *ptr; int width, height; }  bmp_param;
typedef struct { 
  arr2<double> *ptr;
  arr2<bool> *mask_ptr; 
  int width, height; 
} arry_param;

typedef struct {
  COLORSCHEME clr_fn;
  double min_val, max_val;
  int src_xorig, src_yorig, src_xend, src_yend;
  int dst_xorig, dst_yorig, dst_xend, dst_yend;
} trans_param;


class dataMap {

  public:
    dataMap();
    dataMap(FILETYPE type);
    dataMap(dataMap* from);
    ~dataMap() {reset();}

    /**
     * overload = operator
     */
    dataMap& operator=(dataMap& other);
      
    /**
     * access type of data being mapped
     */
    FILETYPE dataType() const {return m_dataType;}
    void dataType(FILETYPE type) {m_dataType = type;}

    /**
     * access type of map
     */
    MAPTYPE mapType() const {return m_mapType;}
    void mapType(MAPTYPE type) {m_mapType = type;}

    /**
     * longitude incrementing convention
     * astronomical increases right to left
     * terrestrial increases left to right
     */
    ORIENTATION orientation() const {return m_orientation;}
    void orientation(ORIENTATION type) {m_orientation = type;}

    /**
     * access color scheme of data being mapped
     */
    COLORSCHEME colorScheme() const {return m_colorScheme;}
    void colorScheme(COLORSCHEME type) {m_colorScheme = type;}

    /**
     * access size of page in X direction
     */
    long Xpage() const {return m_Xpage;}

    /**
     * access size of page in Y direction
     */
    long Ypage() const {return m_Ypage;}

    /**
     * access page aspect
     */
    double pageAspect() const {return m_pageAspect;}

    /**
     * access size of map in X direction
     */
    long Xmap() const {return m_Xmap;}

    /**
     * access size of map in Y direction
     */
    long Ymap() const {return m_Ymap;}

    /**
     * access maximum data value of map
     */
    double max() const   { return m_maxValue; }
    void max(double val) { m_maxValue = val; }

    /**
     * access minimum data value of map
     */
    double min() const {return m_minValue;}
    void min(double val) { m_minValue = val; }

    /**
     * access aspect ratio of map
     */
    double aspect() const {return m_aspect;}
    void aspect(double value) {m_aspect = value;}

    /**
     * access map margins
     * top and bottom margin is 1% of page height
     * side margins is 1% of page width
     */
    long topMargin() const {return (long)(m_Ypage * 0.01);}
    long sideMargin() const {return (long)(m_Xpage * 0.01);}

    /**
     * access map spacers and buffers
     * titleBlock is 9% of page height
     * space between map and color bar is 6% of page height
     * space between color bar and labels is 2% of page height
     */
    long titleBlock() const {return (long)(m_Ypage * 0.09);}
    long mapSpacer() const {return (long)(m_Ypage * 0.06);}
    long colorBarSpacer() const {return (long)(m_Ypage * 0.02);}

    /**
     * access map title
     */
    std::string title() const {return m_title;}
    void title(std::string value) {m_title = value;}

    /**
     * access data map
     */
    arr2<double>& map() {return m_map;}

    /**
     * access color map
     */
    arr2<double>& color() {return m_color;}

    /**
     * access data mask
     */
    arr2<bool>& mask() {return m_mask;}

    /**
     * create map array and initialize to zero
     */
    long initialize() {return initialize(m_Xpage,m_Ypage);}  // use default values
    long initialize(long x,long y);  // use values provided by user

    /**
     * reset the map array
     */
    void reset();

    /**
     * create color bar
     */
    void createColorBar();

    /**
     * find the min and max value within the masked region
     */
    void findExtremes();

    /* Generate and transfer ownership of an RGB bitmap */

    unsigned char *transferRGBData();
    void writeRGB(bmp_param *dst, arry_param *src, trans_param *trans);

  private:
    FILETYPE      m_dataType;
    MAPTYPE       m_mapType;
    ORIENTATION   m_orientation;
    COLORSCHEME  m_colorScheme;
    arr2<double>  m_map;
    arr2<bool>    m_mask;
    arr2<double>  m_color;
    long          m_Xpage;
    long          m_Ypage;
    double        m_pageAspect;
    long          m_Xmap;
    long          m_Ymap;
    double        m_aspect;
    double        m_maxValue;
    double        m_minValue;
    std::string   m_title;
};

#endif
