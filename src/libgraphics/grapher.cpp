/***************************************************************************
 *   grapher.cpp                                                           *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include <new>
#include "../libanalyzer/basedata.h"
#include "../libanalyzer/vectordata.h"
#include "raster.h"
#include "grapher.h"

Grapher::Grapher() {
  m_dataType    = fileType::Null;
  m_configured  = false;
  m_active      = false;
  m_graphX      = 0;
  m_graphY      = 0;
  m_aspect      = 2.0;
  m_edge        = 1.02;
}

Grapher::Grapher(Grapher* from) {
  m_dataType   = from->dataType();
  m_configured = from->configured();
  m_active     = from->active();
  m_graphX     = from->width();
  m_graphY     = from->height();
  m_aspect     = from->aspectRatio();
  m_edge       = from->edge();
}

Grapher::~Grapher() {
  clear();
}

void Grapher::clear() {

}

int Grapher::dataDimensions(association* a) {
  if (!a || m_dataType == fileType::Null)
    return 0;

  return a->getData(m_dataType)->dimensions();
}

int Grapher::dataDimensionSize(association* a, int dim) {
  if (!a || m_dataType == fileType::Null)
    return 0;

  switch (dim) {
    case 1:
      return a->getData(m_dataType)->rows();
    case 2:
      return a->getData(m_dataType)->cols();
    case 3:
      return a->getData(m_dataType)->slices();
    case 4:
      return a->getData(m_dataType)->parts();
    default:
      break;
  }

  return 0;
}

int Grapher::makeGraph(dataSpectrum *spect, FILETYPE dataType, association* a) {
  if (!a)
    return 0;

  if (!a->exists(dataType))
    return 0;
   
  vectorData<double> *vec_dat_ptr = 0, *vec_wht_ptr = 0;
  int count = 0;
   
  /* save data type to associated spectrum */
  spect->dataType(dataType);
  
  /* save data to associated spectrum */
  switch (dataType) {
    case fileType::TransformedNoise:
      vec_dat_ptr = a->transformedNoise();
      break;
    case fileType::TransformedFilter:
      vec_dat_ptr = a->transformedFilter();
      break;
    case fileType::TransformedBeam:
      vec_dat_ptr = a->transformedBeam();
      break;
    case fileType::TransformedData:
      vec_dat_ptr = a->transformedData();
      break;
    case fileType::TransformedWeights:
      vec_wht_ptr = a->transformedWeights();
      break;
    case fileType::WeightedTransform:
      vec_dat_ptr = a->transformedData();
      vec_wht_ptr = a->transformedWeights();
      break;
    case fileType::SpectralData:
      vec_dat_ptr = a->spectrumData();
      break;
    default:
      break;
  }
  
  int max_index = 0, min_index = 0;
  if (vec_wht_ptr) {
    max_index = vec_wht_ptr->size();
    min_index = vec_wht_ptr->maskIndex();
  }
  else {
    max_index = vec_dat_ptr->size();
    min_index = vec_dat_ptr->maskIndex();
  }
  int arr_size = max_index - min_index;
  
  double max_value = 0.0;
  double min_value = 0.0;
  double value = 0.0;
  spect->maxIndex(max_index);
  spect->minIndex(min_index);

  spect->graph().resize(arr_size);
  for (count = 0; count < arr_size; count++) {
    switch (dataType) {
      case fileType::TransformedNoise:
      case fileType::TransformedFilter:
      case fileType::TransformedBeam:
      case fileType::TransformedData:
      case fileType::SpectralData:
         value = (*vec_dat_ptr)[count+min_index];
        break;
      case fileType::TransformedWeights:
        value = (*vec_wht_ptr)[count+min_index];
        break;
      case fileType::WeightedTransform:
        value = ((*vec_dat_ptr)[count+min_index] * (*vec_wht_ptr)[count+min_index]);
        break;
      default:
        break;
    }
    
    spect->graph()[count] += value;
    if (spect->minValue() > value)
      spect->minValue(value);
    if (spect->maxValue() < value)
      spect->maxValue(value);
  }
  
  m_active = true;
  
  return count;   
}
