/***************************************************************************
 *   mapper.h                                                              *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This class provides the basic interface to the map making functions.    *
 * Specific map layouts are daughter classes of this one. These classes    *
 * provide a device independent mechanism for creating an image map of     *
 * the various data classes.                                               *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "raster.h"

/* Using C memory allocation functions as the syntax fits better with
user defined linked lists... */

Raster::Raster(int width, int height, int bytes_per_pixel, unsigned char *raster) {
  unsigned black   = 0x00000000;
  m_raster_width   = width;
  m_raster_height  = height;
  m_raster_Bpp     = bytes_per_pixel;
  m_raster         = raster;
  m_point_size     = 1;

  m_mode           = RASTER_NONE;
  m_pixel_mode     = RASTER_LINEAR;
  m_trans_lst      = 0;
  m_verts_lst      = 0;
  m_color          = *((raster_color_t*)&black);

  m_at_x           = 0;
  m_at_y           = 0;

  m_ft2_library    = 0;
  m_ft2_face       = 0;
  m_ft2_pixel_size = 16;
}

Raster::~Raster() {
  raster_point_t *v_ptr;
  raster_trans_t *t_ptr;

  while (m_verts_lst) {
    v_ptr = m_verts_lst->next;
    free(m_verts_lst);
    m_verts_lst = v_ptr;
  }

  while (m_trans_lst) {
    t_ptr = m_trans_lst->next;
    free(m_trans_lst);
    m_trans_lst = t_ptr;
  }

  if (m_ft2_face)
    FT_Done_Face(m_ft2_face);

  if (m_ft2_library)
    FT_Done_FreeType(m_ft2_library);
}


void Raster::begin(raster_enum_t op) {
  if (!m_raster_width || !m_raster_height || !m_raster_Bpp || !m_raster)
    return;

  switch (op) {
    case RASTER_POINT:
    case RASTER_LINES:
    case RASTER_LINE_STRIP:
    case RASTER_LINE_LOOP:
      m_mode = op;
    default:
      break;
  }

  return;
}

void Raster::vertex(double x, double y) {
  raster_point_t *ptr, *add;

  switch (m_mode) {
    default:
    case RASTER_NONE:
      break;
    case RASTER_POINT:
    case RASTER_LINES:
    case RASTER_LINE_STRIP:
    case RASTER_LINE_LOOP:
      add = (raster_point_t*)calloc(1,sizeof(raster_point_t));
      if (!add)
        break;

      ptr = m_verts_lst;
      if (!ptr) {
        m_verts_lst = add;
        ptr = m_verts_lst;
      }
      else {
        while (ptr->next)
          ptr = ptr->next;
        ptr->next = add;
        add->prev = ptr;
      }

      add->x   = x;
      add->y   = y;
      add->clr = m_color;
      break;
  }

  return;
}

void Raster::end() {
  raster_point_t *v_ptr = m_verts_lst, *tmp_ptr;
  raster_trans_t *t_ptr = m_trans_lst;

  /* Apply transformations */
  while (t_ptr) {
    do_op(t_ptr,v_ptr);
    t_ptr = t_ptr->next;
  }

 rasterize();

  /* Free vertices... */
  while (v_ptr) {
    tmp_ptr = v_ptr->next;
    free(v_ptr);
    v_ptr = tmp_ptr;
  }
  m_verts_lst = 0;

  m_mode = RASTER_NONE;
}

#define RADIANS(x) ((x) * .0174533)

void Raster::do_op(raster_trans_t *trans, raster_point_t *vtx_lst) {
  double radius, theta, *x, *y;

  if (!trans)
    return;

  while (vtx_lst) {
    x = &vtx_lst->x;
    y = &vtx_lst->y;

    switch (trans->op) {
      case RASTER_ROTATE:
        radius = sqrt(*x * *x + *y * *y);
        theta  = atan2(*y,*x) + RADIANS(trans->deg);
        *x     = radius * cos(theta);
        *y     = radius * sin(theta);
        break;
      case RASTER_TRANSLATE:
        *x    += trans->x;
        *y    += trans->y;
        break;
      case RASTER_SCALE:
        *x    *= trans->x;
        *y    *= trans->y;
        break;
      default:
        break;
    }

    vtx_lst = vtx_lst->next;
  }
}

void Raster::color(double r, double g, double b, double a) {
  if (r > 1)
    r = 1;
  if (r < 0)
    r = 0;
  m_color.r = r * 255;

  if (g > 1)
    g = 1;
  if (g < 0)
    g = 0;
  m_color.g = g * 255;

  if (b > 1)
    b = 1;
  if (b < 0)
    b = 0;
  m_color.b = b * 255;

  if (a > 1)
    a = 1;
  if (a < 0)
    a = 0;
  m_color.a = a * 255;
}

void Raster::pointSize(int val) {
  if (val < 0)
    val = 1;

  m_point_size = val;
}

void Raster::pixelMode(raster_enum_t mode) {
  switch (mode) {
    case RASTER_LINEAR:
    case RASTER_NEAREST:
      m_pixel_mode = mode;
    default:
      break;
  }
}

void Raster::identity() {
  raster_trans_t *t_ptr = m_trans_lst, *tmp_ptr;

  if (m_mode != RASTER_NONE)
    return;

  /* Free transformations... */
  while (t_ptr) {
    tmp_ptr = t_ptr->next;
    free(t_ptr);
    t_ptr = tmp_ptr;
  }
  m_trans_lst = 0;
}

void Raster::undoLast() {
  raster_trans_t *t_ptr;

  if (!m_trans_lst || m_mode != RASTER_NONE)
    return;

  t_ptr = m_trans_lst->next;

  free(m_trans_lst);

  m_trans_lst = t_ptr;
}

void Raster::rotate(double deg) {
  add_op(RASTER_ROTATE,deg);
}

void Raster::translate(double x, double y) {
  add_op(RASTER_TRANSLATE,0,x,y);
}

void Raster::scale(double x, double y) {
   add_op(RASTER_SCALE,0,x,y);
}

void Raster::add_op(raster_enum_t op, double deg, double x, double y) {
  raster_trans_t *ptr, *add;

  if (m_mode != RASTER_NONE)
    return;

  add = (raster_trans_t*)calloc(1,sizeof(raster_trans_t));
  if (!add)
    return;


  if (m_trans_lst) {
    ptr = m_trans_lst;
    m_trans_lst = add;
    add->next = ptr;
  }
  else
    m_trans_lst = add;


  add->x   = x;
  add->y   = y;
  add->deg = deg;
  add->op  = op;
}

#define round(x) ((((int)(2 * (x))) > 2 * ((int)(x))) ? (int)(x + 1) : (int)x)

void Raster::write_point() {
  static int x, y ,n;
  static unsigned char *at, *pixel, *color;

  if (m_at_x < 0 || m_at_y < 0)
    return;
  if ((int)m_at_x + m_point_size > m_raster_width)
    return;
  if ((int)m_at_y + m_point_size > m_raster_height)
    return;

  x     = (m_pixel_mode == RASTER_NEAREST) ? round(m_at_x) : m_at_x;
  y     = (m_pixel_mode == RASTER_NEAREST) ? round(m_at_y) : m_at_y;
  color = (unsigned char*)&m_color;
  at    = m_raster + ((y * m_raster_width) + x) * m_raster_Bpp;

  y = 0;
  while (y < m_point_size) {
    x = 0;
    pixel = at;
    while (x < m_point_size) {
      n = 0;
      while (n < m_raster_Bpp) {
        *(pixel + n) = *(color + n);
        n++;
      }
      x++;
      pixel += m_raster_Bpp;
    }
    y++;
    at += m_raster_width * m_raster_Bpp ;
  }
}

void Raster::blend_points() {
  int x, y, n, overflow, component, clamp;
  double alpha;
  raster_point_t *vtx = m_verts_lst, *tmp;
  unsigned char *raster_pix, *curr_pix;


  while (vtx) {
    x = vtx->x;
    y = vtx->y;

    if (x > m_raster_width || x < 0 || y > m_raster_height || y < 0) {
      tmp = vtx->next;
      free(vtx);
      vtx = tmp;
      continue;
    }

    raster_pix = m_raster + ((y * m_raster_width) + x) * m_raster_Bpp;
    curr_pix   = (unsigned char*)&vtx->clr;
    alpha      = vtx->clr.a/255.0;

    n     = 0;
    clamp = 0;
    while (n < 3) {
      overflow = *(curr_pix + n) * alpha + *(raster_pix + n) * (1.0 - alpha) - 255;
      if (overflow > clamp)
        clamp = overflow;
      n++;
    }

    n = 0;
    while (n < 3) {
      component = *(curr_pix + n) * alpha + *(raster_pix + n) * (1.0 - alpha) - clamp;
      if (component < 0)
        component = 0;
      *(raster_pix + n) = component;
      n++;
    }

    tmp = vtx->next;
    free(vtx);
    vtx = tmp;
  }

  m_verts_lst = 0;
}


void Raster::rasterize() {
  raster_point_t *vtx = m_verts_lst;
  bool draw = true, end_loop = false;
  double dx, dy, abs_x, abs_y, slope, sav_dep, *indep_v, *dep_v;
  int n, limit, inc;

  if (!m_raster || !m_verts_lst)
    return;

  /* We always write the first point... */
  m_at_x  = vtx->x;
  m_at_y  = vtx->y;
  m_color = vtx->clr;
  write_point();

  vtx = vtx->next;

  while (vtx || end_loop) {
    switch (m_mode) {
      default:
      case RASTER_NONE:
        break;
      case RASTER_POINT:
        m_at_x  = vtx->x;
        m_at_y  = vtx->y;
        m_color = vtx->clr;
        write_point();
        break;
      case RASTER_LINE_LOOP:
      case RASTER_LINES:
      case RASTER_LINE_STRIP:
        if (draw) {
          dx    = vtx->x - m_at_x;
          dy    = vtx->y - m_at_y;
          abs_x = abs(dx);
          abs_y = abs(dy);
          if (abs_x || abs_y) {
            if (abs_x >= abs_y) {
              slope = fabs(dy/dx);
              if (dy < 0)
                slope = -slope;
              inc     = (dx >= 0) ? 1 : -1;
              indep_v = &m_at_x;
              dep_v   = &m_at_y;
              sav_dep = m_at_y;
              limit   = abs_x + 1;
            }
            else {
              slope = fabs(dx/dy);
              if (dx < 0)
                slope = -slope;
              inc     = (dy >= 0) ? 1 : -1;
              indep_v = &m_at_y;
              dep_v   = &m_at_x;
              sav_dep = m_at_x;
              limit   = abs_y + 1;
            }
          }
          else
            break;
          m_color = vtx->clr;
          n = 1;
          while (n < limit) {
            *dep_v    = sav_dep + n * slope;
            *indep_v += inc;
            write_point();
            n++;
          }
          m_at_x = vtx->x;
          m_at_y = vtx->y;
          write_point();

          if (m_mode == RASTER_LINES)
            draw = false;
        }
        else {  /* RASTER_LINES: do not show */
          draw = true;
          m_at_x = vtx->x;
          m_at_y = vtx->y;
          break;
        }
    }

    if (end_loop) {
      end_loop = false;
      vtx = 0;
      continue;
    }

    vtx = vtx->next;

    if (m_mode == RASTER_LINE_LOOP && !vtx) {
      end_loop = true;
      vtx = m_verts_lst;
    }
  }
}

/* Functions adpated from GLUT */
void Raster::vectorFontString(VectorFont font, const char *string) {
  const StrokeCharRec *ch;
  const StrokeRec *stroke;
  const CoordRec *coord;
  StrokeFontPtr fontinfo = (StrokeFontPtr) font;
  double x_offset = 0, y_offset = 0, span;
  int i, j;
  char c;

  if (!fontinfo)
    return;

  span = fontinfo->top - fontinfo->bottom;

  while (c = *string) {
    if (c == '\n') {
      y_offset += span;
      x_offset  = 0;
      string++;
      continue;
    }

    if (c < 0 || c >= fontinfo->num_chars || !(ch = &(fontinfo->ch[c])))
      return;

    i = ch->num_strokes;
    stroke = ch->stroke;

    while (i > 0) {
      begin(RASTER_LINE_STRIP);
      j = stroke->num_coords;
      coord = stroke->coord;
      while (j > 0) {
        vertex(x_offset + coord->x,span - coord->y + y_offset);
        j--;
        coord++;
      }
      end();

      i--;
      stroke++;
    }
    if (font == VECTOR_FONT_ROMAN && c == ' ')
      x_offset += ch->right/2;
    else
      x_offset += ch->right;
    string++;
  }
}

double Raster::vectorFontWidth(VectorFont font, char c) {
  StrokeFontPtr fontinfo = (StrokeFontPtr) font;
  const StrokeCharRec *ch;

  if (c < 0 || c >= fontinfo->num_chars || !(ch = &(fontinfo->ch[c])))
    return 0;
  if (font == VECTOR_FONT_ROMAN && c == ' ')
    return ch->right/2;
  return ch->right;
}

double Raster::vectorFontLength(VectorFont font, const char *string) {
  char c;
  double length = 0;
  StrokeFontPtr fontinfo = (StrokeFontPtr)font;
  const StrokeCharRec *ch;

  while (c = *string) {
    if (c >= 0 && c < fontinfo->num_chars) {
      if (ch = &(fontinfo->ch[c])) {
        if (font == VECTOR_FONT_ROMAN && c == ' ')
          length += ch->right/2;
        else
          length += ch->right;
      }
    }
    string++;
  }
  return length;
}

/* FreeType2 bitmapped fonts... */
void Raster::bitmapFontFace(const char *font, int face_pixels) {
  FT_Error err;

  if (!font || face_pixels < 1) {
    printf("Parameter error...\n");
    return;
  }

  if (!m_ft2_library) {
    err = FT_Init_FreeType(&m_ft2_library);
    if (err) {
      printf("Could not init font lib...\n");
      return;
    }
  }

  if (m_ft2_face) {
    FT_Done_Face(m_ft2_face);
    m_ft2_face = 0;
  }

  err = FT_New_Face(m_ft2_library,font,0,&m_ft2_face);
  if (err == FT_Err_Unknown_File_Format ) {
    printf("Unsupported font face...\n");
    return;
  }
  else if (err) {
    printf("Bad font file or name...\n");
    return;
  }

  err = FT_Set_Pixel_Sizes(m_ft2_face,face_pixels,face_pixels);
  if (err) {
    printf("Bad pixel size...\n");
    return;
  }
  m_ft2_pixel_size = face_pixels;
}

void Raster::bitmapFontString(const char *string) {
  FT_Bitmap *bm;
  FT_GlyphSlot slot;
  FT_Bool use_kerning;
  FT_Vector delta;
  FT_Error err;
  int pen_x = 0, pen_y = 0, x, y, alpha;
  raster_point_t *ptr, *add;
  raster_trans_t *t_ptr;
  char previous = 0;

  if (!string || !m_ft2_face)
    return;

  ptr = m_verts_lst;
  if (ptr) {
    while (ptr->next)
       ptr = ptr->next;
  }

  slot        = m_ft2_face->glyph;
  use_kerning = FT_HAS_KERNING(m_ft2_face);

  while (*string) {
    if (*string == '\n') {
      pen_y += m_ft2_pixel_size * 1.2;
      pen_x = 0;
      string++;
      previous = 0;
      continue;
    }

    err = FT_Load_Char(m_ft2_face,*string,FT_LOAD_RENDER);
    if (err) {
      string++;
      continue;
    }

    if (use_kerning && previous) {
      FT_Get_Kerning(m_ft2_face,previous,*string,FT_KERNING_DEFAULT,&delta);
      pen_x += delta.x >> 6;
    }

    bm = &slot->bitmap;
    y = 0;
    while (y < bm->rows) {
      x = 0;
      while (x < bm->width) {
        alpha = bm->buffer[y * bm->width + x];
        if (!alpha) {
          x++;
          continue;
        }

        add = (raster_point_t*)calloc(1,sizeof(raster_point_t));
        if (!add)
          return;

        if (!ptr)
          m_verts_lst = add;
        else {
          ptr->next = add;
          add->prev = ptr;
        }
        ptr = add;

        ptr->x     = pen_x + slot->bitmap_left + x;
        ptr->y     = pen_y - slot->bitmap_top + y;
        ptr->clr   = m_color;
        ptr->clr.a = alpha;
        x++;
      }
      y++;
    }
    previous = *string;
    string++;
    pen_x += slot->advance.x >> 6;
  }

  ptr   = m_verts_lst;
  t_ptr = m_trans_lst;

  /* Apply transformations */
  while (t_ptr) {
    do_op(t_ptr,ptr);
    t_ptr = t_ptr->next;
  }

  blend_points();
}

double Raster::bitmapFontWidth(char c) {
  FT_GlyphSlot slot;
  FT_Error err;

  if (!c || !m_ft2_face)
    return 0;

  err = FT_Load_Char(m_ft2_face,c,FT_LOAD_DEFAULT);
  if (err)
    return 0;
  else
    return (double)(slot->advance.x >> 6);
}

double Raster::bitmapFontLength(const char *string) {
  FT_GlyphSlot slot;
  FT_Error err;
  FT_Bool use_kerning;
  FT_Vector delta;
  double ret_width = 0;
  double width = 0;
  char previous = 0;

  if (!string || !m_ft2_face)
    return 0;

  slot        = m_ft2_face->glyph;
  use_kerning = FT_HAS_KERNING(m_ft2_face);

  while (*string) {
    if (*string == '\n') {
      if (width > ret_width)
        ret_width = width;
      width = 0;
      string++;
      previous = 0;
      continue;
    }

    err = FT_Load_Char(m_ft2_face,*string,FT_LOAD_DEFAULT);
    if (err) {
      string++;
      continue;
    }

    if (use_kerning && previous) {
      FT_Get_Kerning(m_ft2_face,previous,*string,FT_KERNING_DEFAULT,&delta);
      width += delta.x >> 6;
    }

    width += slot->advance.x >> 6;
    previous = *string;
    string++;
  }

  if (width > ret_width)
    return width;
  else
    return ret_width;
}

void Raster::toBitmapFile(const char* file_name) {
  /* struct definitions from:
     http://en.wikipedia.org/wiki/BMP_file_format */

  struct bmpfile_header {
    unsigned int   filesz;
    unsigned short creator1;
    unsigned short creator2;
    unsigned int   bmp_offset;
  };

  struct bmp_dib_v3_header {
    unsigned int   header_sz;
    int            width;
    int            height;
    unsigned short nplanes;
    unsigned short bitspp;
    unsigned int   compress_type;
    unsigned int   bmp_bytesz;
    int            hres;
    int            vres;
    unsigned int   ncolors;
    unsigned int   nimpcolors;
  };

  struct bmpfile_header hdr;
  struct bmp_dib_v3_header dib;
  unsigned char color, *bm, *bm_ptr, id[2] = {'B', 'M'};
  FILE *file,*test;
  int x, y, wrote, row_size;
  unsigned header_size = 2 + sizeof(hdr) + sizeof(dib);
  unsigned image_size  = m_raster_width * m_raster_height * m_raster_Bpp;
  unsigned file_size   = header_size + image_size;

  if (!m_raster)
    return;

  file = fopen(file_name, "wb");
  if (!file)
    return;

  wrote = fwrite(id,sizeof(char),2,file);
  if (wrote != 2) {
    fclose(file);
    return;
  }

  hdr.filesz     = file_size;
  hdr.creator1   = 0;
  hdr.creator2   = 0;
  hdr.bmp_offset = header_size;

  wrote = fwrite(&hdr,sizeof(hdr),1,file);
  if (wrote != 1) {
    fclose(file);
    return;
  }

  dib.header_sz     = sizeof(dib);
  dib.width         = m_raster_width;
  dib.height        = m_raster_height;
  dib.nplanes       = 1;
  dib.bitspp        = m_raster_Bpp * 8;
  dib.compress_type = 0;
  dib.bmp_bytesz    = image_size;
  dib.hres          = 2835; /* pixels/meter */
  dib.vres          = 2835; /* pixels/meter */
  dib.ncolors       = 0;    /* palette colors */
  dib.nimpcolors    = 0;

  wrote = fwrite(&dib,sizeof(dib),1,file);
  if (wrote != 1) {
    fclose(file);
    return;
  }

  /* We need to swap the image origin and color layout...

  First, swap origin while copying... */
  bm = (unsigned char*)malloc(image_size);
  if (!bm) {
    fclose(file);
    return;
  }

  row_size = m_raster_width * m_raster_Bpp;
  y = m_raster_height - 1;
  bm_ptr = bm;
  while (y >= 0) {
    memcpy(bm_ptr,m_raster + y * row_size,row_size);
    bm_ptr += row_size;
    y--;
  }

  /* Convert RGB -> BGR order... */
  bm_ptr = bm;
  y = 0;
  while (y < m_raster_height) {
    x = 0;
    while (x < m_raster_width) {
      color         = *bm_ptr;
      *bm_ptr       = *(bm_ptr + 2);
      *(bm_ptr + 2) = color;
      bm_ptr += m_raster_Bpp;
      x++;
    }
    y++;
  }

  /* Now write the bitmap out */
  wrote = fwrite(bm,sizeof(char),image_size,file);

  fclose(file);
  free(bm);
  return;
}


