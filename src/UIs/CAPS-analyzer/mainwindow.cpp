/***************************************************************************
 *   mainwindow.cpp                                                        *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   suson@calumet.purdue.edu                                              *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This class defines the main window structure associated with the user   *
 * Qt5 user interface.                                                     *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <QFileInfo>

#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "../libanalyzer/fitsmanager.h"
#include "../libanalyzer/csvmanager.h"

mainWindow::mainWindow() :
            ui(new Ui::MainWindow) {
  /* set up the user interface */
  ui->setupUi(this);

  /* create data stream association */
  QString title, message;

  s_association = 0;
  try {
    s_association = new association();
  }
  catch (const std::overflow_error &e) {
    title = QString(tr("Error code returned"));
    message = QString(tr("The attempt to create a new data association failed.\n The overflow error is %1\n")).arg(e.what());
    QMessageBox::critical(this,title,message);
    return;
  }
  catch (const std::runtime_error &e) {
    title = QString(tr("Error code returned"));
    message = QString(tr("The attempt to create a new data association failed.\n The runtime error is %1\n")).arg(e.what());
    QMessageBox::critical(this,title,message);
    return;
  }
  catch (const std::exception &e) {
    title = QString(tr("Error code returned"));
    message = QString(tr("The attempt to create a new data association failed.\n The exception is %1\n")).arg(e.what());
    QMessageBox::critical(this,title,message);
    return;
  }
  catch (...) {
    title = QString(tr("Error code returned"));
    message = QString(tr("The attempt to create a new data association failed.\n"));
    QMessageBox::critical(this,title,message);
    return;
  }

  /* create dialogs needed to pass signals back and forth */
  ctrlDlg = new controlDataDialog(s_association);
  energyDlg = new energyDialog();
  pixSelectDlg = new pixelizerDialog(s_association);
  healpixDlg = new healpixDialog(s_association);
  transSelectDlg = new transformerDialog(s_association);
  rshtDlg = new rshtDialog(s_association);
  specDlg = new spectrumDialog();
  mapperDlg = new mapperDialog(s_association);
  mapSelectDlg = new mapSelectDialog(s_association);
  graphDlg = new graphDialog(s_association);
  graphSelectDlg = new graphSelectDialog();

  /* initialize progress bar */
  ui->progressBar->reset();
  ui->progressBar->setRange(0,100);
  ui->progressLabel->setText(QString(tr("Ready")));
  s_progressInterface = new progress(this,progressBarWrapper);

  /* set LED indicators */
  selectedDataType = fileType::Null;
  selectedDataStream = genericType::NoGeneric;
  ui->inputDataLED->setState(QLedLabel::missing);
  ui->inputMaskLED->setState(QLedLabel::missing);
  ui->inputNoiseLED->setState(QLedLabel::notNecessary);
  ui->inputFilterLED->setState(QLedLabel::notNecessary);
  ui->inputBeamLED->setState(QLedLabel::notNecessary);
  ui->pixelDataLED->setState(QLedLabel::missing);
  ui->pixelMaskLED->setState(QLedLabel::missing);
  ui->pixelNoiseLED->setState(QLedLabel::notNecessary);
  ui->pixelFilterLED->setState(QLedLabel::notNecessary);
  ui->pixelBeamLED->setState(QLedLabel::notNecessary);
  ui->transDataLED->setState(QLedLabel::missing);
  ui->transMaskLED->setState(QLedLabel::missing);
  ui->transNoiseLED->setState(QLedLabel::notNecessary);
  ui->transFilterLED->setState(QLedLabel::notNecessary);
  ui->transBeamLED->setState(QLedLabel::notNecessary);
  ui->almDataLED->setState(QLedLabel::missing);
  ui->almMaskLED->setState(QLedLabel::missing);
  ui->almNoiseLED->setState(QLedLabel::notNecessary);
  ui->almFilterLED->setState(QLedLabel::notNecessary);
  ui->almBeamLED->setState(QLedLabel::notNecessary);
  ui->inverseDataLED->setState(QLedLabel::missing);
  ui->inverseMaskLED->setState(QLedLabel::missing);
  ui->inverseNoiseLED->setState(QLedLabel::notNecessary);
  ui->inverseFilterLED->setState(QLedLabel::notNecessary);
  ui->inverseBeamLED->setState(QLedLabel::notNecessary);


  /* set up Qt signal/slot connections */
  connect(ui->controlAction, &QAction::triggered, [=](bool open){ctrlDlg->configure(false);});
  connect(ui->openAction, &QAction::triggered, [=](){openFile();});
  connect(ui->saveAction, &QAction::triggered, [=](){saveFile();});
//  connect(ui->informationAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
//  connect(ui->printAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
  connect(ui->clearAction, &QAction::triggered, [=](){reset();});
  connect(ui->exitAction, &QAction::triggered, [=](){close();});
  connect(ui->pixelizeAction, &QAction::triggered, [=](){selectPixelizer();});
  connect(ui->transformAction, &QAction::triggered, [=](){selectTransformer();});
  connect(ui->analyzeAction, &QAction::triggered, [=](){analyze();});
//  connect(ui->inverseAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
  connect(ui->selectMapsAction, &QAction::triggered, [=](){mapSelectDlg->configure();});
  connect(ui->selectGraphsAction, &QAction::triggered, [=](){graphSelectDlg->configure();});
//  connect(ui->zoomInAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
//  connect(ui->zoomOutAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
//  connect(ui->zoomNormalAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
//  connect(ui->configureMapper, Q_SIGNAL(triggered()), this, Q_SLOT(setupMapper()));
//  connect(ui->configurePoxelizer, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
//  connect*ui->configureTransformer, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
//  connect(ui->HandbookAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
//  connect(ui->aboutAnalyzerAction, Q_SIGNAL(triggered(bool)), this, Q_SLOT());
  connect(ctrlDlg, &controlDataDialog::buildControlData, [=](FILETYPE value,bool complete){createControlData(value,complete);});
  connect(this,&mainWindow::selectEnergies,[=](double low, double high){energyDlg->configure(low,high);});
  connect(energyDlg,&energyDialog::energySelected,[=](double low, double high){readData(low,high);});
  connect(mapperDlg, &mapperDialog::mapperReady, [=](){buildMaps();});
  connect(this, &mainWindow::selectMapDisplay, [=](unsigned int selection){mapSelectDlg->configure(selection);});
  connect(mapSelectDlg, &mapSelectDialog::mapSelected, [=](ASSOCIATEDMAP map){displayMap(map);});
  connect(graphDlg, &graphDialog::grapherReady, [=](){buildGraphs();});
  connect(this, &mainWindow::selectGraphDisplay, [=](unsigned int selection){graphSelectDlg->configure(selection);});
  connect(graphSelectDlg, &graphSelectDialog::graphSelected, [=](associatedSpectrum graph){displayGraph(graph);});
  connect(pixSelectDlg, &pixelizerDialog::pixelizerSelected, [=](PIXELSCHEME scheme){configurePixelizer(scheme);});
  connect(transSelectDlg, &transformerDialog::transformerSelected, [=](TRANSFORMERSCHEME scheme){configureTransformer(scheme);});
  connect(healpixDlg, &healpixDialog::pixelizeData, [=](){pixelize();});
  connect(rshtDlg, &rshtDialog::transformData, [=](){transform();});
  connect(specDlg, &spectrumDialog::spectrumReady, [=](){analyze();});
//  connect(this, Q_SIGNAL(redrawMap()), ui->mapTab, Q_SLOT(paintEvent(QPaintEvent*)));
//  connect(ctrlDlg, Q_SIGNAL(controlDataSet()), this, Q_SLOT(checkMapper()));
//  connect(mapperDlg, Q_SIGNAL(mapperSet(MAPTYPE,long,long,ORIENTATION)), this, Q_SLOT(createMaps(MAPTYPE,long,long,ORIENTATION)));
//  connect(this, Q_SIGNAL(imageConfigured(association*,FILETYPE*)), mapSelectDlg, configure(association*,FILETYPE*));
//  connect(this, Q_SIGNAL(mapSelected(QWidget*)), this, drawImage(QWidget*));

  // set initial directory to user's home directory
  directory = QDir::home();

  // create progress interface
//  progressInterface = analyzer_set_progress_callback(this,progressBarWrapper);
}

mainWindow::~mainWindow() {
  // delete primary user interface
  delete ui;

  // delete associated dialog boxes
  delete ctrlDlg;
  delete energyDlg;
  delete pixSelectDlg;
  delete healpixDlg;
  delete transSelectDlg;
  delete rshtDlg;
  delete specDlg;
  delete mapperDlg;
  delete mapSelectDlg;
  delete graphDlg;
  delete graphSelectDlg;

  // delete association
    delete s_association;
}

void mainWindow::progressBarWrapper(void* uiObj, int value)
{
  mainWindow* here = (mainWindow*) uiObj;
  here->updateProgressBar(value);
//  here->ui->progressLabel->setText(QString::fromUtf8(activity));
}

void mainWindow::updateProgressBar(int value)
{
  ui->progressBar->setValue(value);
}

void mainWindow::openFile()
{
  QString title, message;

  QComboBox *dataTypeBox = new QComboBox();
  FILETYPE dataTypes = fileType::Null;
  FORMAT dataFormat = None;
  int types = static_cast<int>(dataTypes);
  unsigned int loadedTypes = 0;

  // add all of the appropriate data types to the combo box list
  while (dataTypes != fileType::FILETYPE_LIMIT)
  {
    if (dataTypes == fileType::Null ||                 // these file types are not opened or saved as a I/O file
        dataTypes == fileType::WeightedData ||
        dataTypes == fileType::WeightedPixel ||
        dataTypes == fileType::PixelOccupancy ||
        dataTypes == fileType::WeightedInverse ||
        dataTypes == fileType::MAP_LIMIT ||
        dataTypes == fileType::WeightedTransform ||
        dataTypes == fileType::GRAPH_LIMIT ||
        dataTypes == fileType::TRANSFORM_LIMIT) {
      dataTypes = static_cast<FILETYPE>(++types);
      continue;
    }
    
    QString dataName = QString(dataTypeNames[(int)dataTypes].c_str());
    dataTypeBox->addItem(dataName);
    dataTypes = static_cast<FILETYPE>(++types);
  }

  // extend the standard QFileDialog by adding the data types as a combo box
  title = QString(tr("Open File"));
  QFileDialog *openDialog = new QFileDialog(this, title, QDir::homePath(), tr("Input Files (*.fits *.csv)"));
  openDialog->setOption(QFileDialog::DontUseNativeDialog);
  openDialog->setAcceptMode(QFileDialog::AcceptOpen);
  openDialog->setDirectory(directory);
  QLayout *layout = openDialog->layout();
  QGridLayout *gridbox = qobject_cast<QGridLayout*>(layout);
  if (gridbox) {
    gridbox->addWidget(new QLabel(tr("Data Type:")));
    gridbox->addWidget(dataTypeBox);
  }
  openDialog->setLayout(gridbox);
  
  // execute the new dialog box
  if (openDialog->exec()) {
    // get current directory
    directory = openDialog->directory();
    // get file name
    QStringList selectedFileNames;
    selectedFileNames = openDialog->selectedFiles();
    if (selectedFileNames.size() > 1) {
      title = QString(tr("File Selection Error"));
      message = QString(tr("Too many file names selected"));
      QMessageBox::critical(this,title,message);
      return;
    }

    // get data type
    selectedDataType = (FILETYPE)(dataTypeBox->currentIndex());
    
    // have to correct data type for removed entries
    selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for Null type
    if (selectedDataType > fileType::WeightedData)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedData type
    if (selectedDataType > fileType::WeightedPixel)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedPixel type
    if (selectedDataType > fileType::PixelOccupancy)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for PixelOccupancy type
    if (selectedDataType > fileType::WeightedInverse)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedInverse type
    if (selectedDataType >= fileType::MAP_LIMIT)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for end of mappable types
    if (selectedDataType > fileType::WeightedTransform)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedTransform type
    if (selectedDataType >= fileType::GRAPH_LIMIT)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for end of graphable types
    if (selectedDataType >= fileType::TRANSFORM_LIMIT)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for end of transformable types

    // set data stream based on data type
    switch (selectedDataType) {
      case fileType::InputData:
      case fileType::PixelizedData:
      case fileType::InverseData:
      case fileType::TransformedData:
      case fileType::AlmData:
        selectedDataStream = genericType::Data;
        break;
      case fileType::InputWeights:
      case fileType::PixelizedWeights:
      case fileType::InverseWeights:
      case fileType::TransformedWeights:
      case fileType::AlmWeights:
        selectedDataStream = genericType::Weights;
        break;
      case fileType::InputNoise:
      case fileType::PixelizedNoise:
      case fileType::InverseNoise:
      case fileType::TransformedNoise:
      case fileType::AlmNoise:
        selectedDataStream = genericType::Noise;
        break;
      case fileType::InputFilter:
      case fileType::PixelizedFilter:
      case fileType::InverseFilter:
      case fileType::TransformedFilter:
      case fileType::AlmFilter:
        selectedDataStream = genericType::Filter;
        break;
      case fileType::InputBeam:
      case fileType::PixelizedBeam:
      case fileType::InverseBeam:
      case fileType::TransformedBeam:
      case fileType::AlmBeam:
        selectedDataStream = genericType::Beam;
        break;
    }

    // check file type
    fileName = selectedFileNames[0];
    double minEnergy = 0.0, maxEnergy = 0.0;

    if (fileName.contains(".fits",Qt::CaseInsensitive))
      dataFormat = Fits;
    if (fileName.contains(".csv",Qt::CaseInsensitive))
      dataFormat = CSV;
    if (fileName.contains(".hdf5",Qt::CaseInsensitive) || (fileName.contains(".h5",Qt::CaseInsensitive)))
      dataFormat = HDF5;

    // get data from file
    if (s_association->exists(dataEngines::fileIO))
      s_association->reset(allTypes::fileIO);
    try {
      s_association->addEngine(dataEngines::fileIO,fileName.toStdString().c_str(),dataFormat,selectedDataType,Read);
    }
    catch (ERRORCODES error) {
      title = QString("Error creating file I/O engine");
      message = QString::fromStdString(s_association->errorDetails());
      QMessageBox::critical(this,title,message);
      return;
    }
    if (s_association->fileIOEngine()->fileFormat() != dataFormat) {
      s_association->reset(allTypes::fileIO);
      s_association->addEngine(dataEngines::fileIO,fileName.toStdString().c_str(),dataFormat,selectedDataType,Read);
    }

    try{
      s_association->fileIOEngine()->open();
    }
    catch (ERRORCODES error) {
      title = QString("Error reading file");
      message = QString::fromStdString(s_association->errorDetails());
      QMessageBox::critical(this,title,message);
      return;
    }

    if (s_association->fileIOEngine()->slices() > 1) {
      minEnergy = s_association->fileIOEngine()->min_energy();
      maxEnergy = s_association->fileIOEngine()->max_energy();

      // let user change energy range before reading data
      Q_EMIT selectEnergies(minEnergy, maxEnergy);
    }
    else
      readData();

    // check if upstream data exists and flag it if it does
    switch (selectedDataStream) {
      case genericType::Data:
        switch (selectedDataType) {
          case fileType::AlmData:
            if (s_association->exists(fileType::TransformedData))
              ui->transDataLED->setState(QLedLabel::outOfDate);
          case fileType::TransformedData:
            if (s_association->exists(fileType::InverseData))
              ui->inverseDataLED->setState(QLedLabel::outOfDate);
          case fileType::InverseData:
            if (s_association->exists(fileType::PixelizedData))
              ui->pixelDataLED->setState(QLedLabel::outOfDate);
          case fileType::PixelizedData:
            if (s_association->exists(fileType::InputData))
              ui->inputDataLED->setState(QLedLabel::outOfDate);
            break;
        }
        break;
      case genericType::Weights:
        switch (selectedDataType) {
          case fileType::AlmWeights:
            if (s_association->exists(fileType::TransformedWeights))
              ui->transMaskLED->setState(QLedLabel::outOfDate);
          case fileType::TransformedWeights:
            if (s_association->exists(fileType::InverseWeights))
              ui->inverseMaskLED->setState(QLedLabel::outOfDate);
          case fileType::InverseWeights:
            if (s_association->exists(fileType::PixelizedWeights))
              ui->pixelMaskLED->setState(QLedLabel::outOfDate);
          case fileType::PixelizedWeights:
            if (s_association->exists(fileType::InputWeights))
              ui->inputMaskLED->setState(QLedLabel::outOfDate);
            break;
        }
        break;
      case genericType::Noise:
        switch (selectedDataType) {
          case fileType::AlmNoise:
            if (s_association->exists(fileType::TransformedNoise))
              ui->transNoiseLED->setState(QLedLabel::outOfDate);
          case fileType::TransformedNoise:
            if (s_association->exists(fileType::InverseNoise))
              ui->inverseNoiseLED->setState(QLedLabel::outOfDate);
          case fileType::InverseNoise:
            if (s_association->exists(fileType::PixelizedNoise))
              ui->pixelNoiseLED->setState(QLedLabel::outOfDate);
          case fileType::PixelizedNoise:
            if (s_association->exists(fileType::InputNoise))
              ui->inputNoiseLED->setState(QLedLabel::outOfDate);
            break;
        }
        break;
      case genericType::Filter:
        switch (selectedDataType) {
          case fileType::AlmFilter:
            if (s_association->exists(fileType::TransformedFilter))
              ui->transFilterLED->setState(QLedLabel::outOfDate);
          case fileType::TransformedFilter:
            if (s_association->exists(fileType::InverseFilter))
              ui->inverseFilterLED->setState(QLedLabel::outOfDate);
          case fileType::InverseFilter:
            if (s_association->exists(fileType::PixelizedFilter))
              ui->pixelFilterLED->setState(QLedLabel::outOfDate);
          case fileType::PixelizedFilter:
            if (s_association->exists(fileType::InputFilter))
              ui->inputFilterLED->setState(QLedLabel::outOfDate);
            break;
        }
        break;
      case genericType::Beam:
        switch (selectedDataType) {
          case fileType::AlmBeam:
            if (s_association->exists(fileType::TransformedBeam))
              ui->transBeamLED->setState(QLedLabel::outOfDate);
          case fileType::TransformedBeam:
            if (s_association->exists(fileType::InverseBeam))
              ui->inverseBeamLED->setState(QLedLabel::outOfDate);
          case fileType::InverseBeam:
            if (s_association->exists(fileType::PixelizedBeam))
              ui->pixelBeamLED->setState(QLedLabel::outOfDate);
          case fileType::PixelizedBeam:
            if (s_association->exists(fileType::InputBeam))
              ui->inputBeamLED->setState(QLedLabel::outOfDate);
            break;
        }
        break;
      default:
        break;
    }
  }
}

void mainWindow::readData(double minEnergy, double maxEnergy) {
  QString title, message;
  fileManager* fm;

  // update energy keys, if necessary
  if (minEnergy < 0.0) {
    title = QString(tr("Invalid minimum energy"));
    message = QString(tr("Minimum energy must be greater than zero"));
    QMessageBox::critical(this,title,message);
    return;
  }
  if (maxEnergy < 0.0) {
    title = QString(tr("Invalid maximum energy"));
    message = QString(tr("Maximum energy must be greater than zero"));
    QMessageBox::critical(this,title,message);
    return;
  }
  if (minEnergy > maxEnergy) {
    title = QString(tr("Energy mismatch"));
    message = QString(tr("The minimum energy must be less than the maximum energy"));
    QMessageBox::critical(this,title,message);
    return;
  }

  fm = s_association->fileIOEngine();

  fm->min_energy(0,minEnergy);
  fm->max_energy(0,maxEnergy);

  // set up progress bar call back
  ui->progressBar->reset();
  ui->progressLabel->setText(QString(tr("Reading Data")));
//  analyzer_get_progress_callback("Reading Data");

  s_association->addData(fm->data());
  s_association->sequenceStep(setSky);
  Q_EMIT dataReady(selectedDataType);
}

void mainWindow::readData() {
  // set up progress bar call back
  ui->progressBar->reset();
  ui->progressLabel->setText(QString(tr("Reading Data")));
//  analyzer_get_progress_callback("Reading Data");

  s_association->addData(s_association->fileIOEngine()->data());
  s_association->sequenceStep(setSky);
  configureDisplay(selectedDataType);
}

void mainWindow::saveFile() {
  QString title, message;
  
  QComboBox *dataTypeBox = new QComboBox();
  FILETYPE dataTypes = fileType::Null;
  int types = static_cast<int>(dataTypes);

  // add all of the appropriate data types to the combo box list
  while (dataTypes != fileType::FILETYPE_LIMIT) {
    if (dataTypes == fileType::Null ||                 // these file types are not opened or saved as a I/O file
        dataTypes == fileType::WeightedData ||
        dataTypes == fileType::WeightedPixel ||
        dataTypes == fileType::PixelOccupancy ||
        dataTypes == fileType::WeightedInverse ||
        dataTypes == fileType::MAP_LIMIT ||
        dataTypes == fileType::WeightedTransform ||
        dataTypes == fileType::GRAPH_LIMIT ||
        dataTypes == fileType::TRANSFORM_LIMIT) {
      dataTypes = static_cast<FILETYPE>(++types);
      continue;
    }

    QString dataName = QString(dataTypeNames[(int)dataTypes].c_str());
    dataTypeBox->addItem(dataName);
    dataTypes = static_cast<FILETYPE>(++types);
  }
  
  // extend the standard QFileDialog by adding the data types as a combo box
  title = QString(tr("Save File"));
  QFileDialog *saveDialog = new QFileDialog(this, title, QDir::homePath(), tr("Fits File (*.fits);; CSV File (*.csv)"));
  saveDialog->setOption(QFileDialog::DontUseNativeDialog);
  saveDialog->setAcceptMode(QFileDialog::AcceptSave);
  saveDialog->setDirectory(directory);
  QLayout *layout = saveDialog->layout();
  QGridLayout *gridbox = qobject_cast<QGridLayout*>(layout);
  if (gridbox) {
    gridbox->addWidget(new QLabel(tr("Data Type:")));
    gridbox->addWidget(dataTypeBox);
  }
  saveDialog->setLayout(gridbox);
  
  // execute the new dialog box
  if (saveDialog->exec()) {
    // get current directory
    directory = saveDialog->directory();
    // get file name
    QStringList selectedFileNames;
    selectedFileNames = saveDialog->selectedFiles();
    if (selectedFileNames.size() > 1) {
      title = QString(tr("File Selection Error"));
      message = QString(tr("Too many file names selected"));
      QMessageBox::critical(this,title,message);
      return;
    }

    // check that file type is a supported type
    FORMAT dataFormat;
    fileName = selectedFileNames[0];
    QString filter = saveDialog->selectedNameFilter();
    if (fileName.contains(".fits",Qt::CaseInsensitive))
      dataFormat = Fits;
    else
      if (filter.contains(".fits",Qt::CaseInsensitive)) {
        fileName += QString(tr(".fits"));
        dataFormat = Fits;
      }
    if (fileName.contains(".fits",Qt::CaseInsensitive)) {
      QFileInfo checkFile(fileName);
      if (checkFile.exists() && checkFile.isFile())
        fileName = "!" + fileName;
    }

    if (fileName.contains(".csv",Qt::CaseInsensitive))
      dataFormat = CSV;
    else
      if(filter.contains(".csv",Qt::CaseInsensitive)) {
        fileName += QString(tr(".csv"));
        dataFormat = CSV;
      }

    if (dataFormat == None) {
      title = QString(tr("Mismatched File Type"));
      message = QString(tr("File type must be .fits or .csv"));
      QMessageBox::critical(this,title,message);
      return;
    }

    // get data type
    selectedDataType = (FILETYPE)(dataTypeBox->currentIndex());
    
    // have to correct data type for removed entries
    selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for Null type
    if (selectedDataType > fileType::WeightedData)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedData type
    if (selectedDataType > fileType::WeightedPixel)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedPixel type
    if (selectedDataType > fileType::PixelOccupancy)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for PixelOccupancy type
    if (selectedDataType > fileType::WeightedInverse)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedInverse type
    if (selectedDataType >= fileType::MAP_LIMIT)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for end of mappable types
    if (selectedDataType > fileType::WeightedTransform)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for WeightedTransform type
    if (selectedDataType >= fileType::GRAPH_LIMIT)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for end of graphable types
    if (selectedDataType >= fileType::TRANSFORM_LIMIT)
      selectedDataType = (FILETYPE)((int)selectedDataType + 1); // add one to account for end of transformable types

    baseData *data = 0;

    if (!(data = s_association->getData(selectedDataType))) {
      title = QString(tr("No data found"));
      message = QString(tr("There isn't any data associated with the selected data set\nSave aborted"));
      QMessageBox::critical(this,title,message);
      return;
    }
    // save data to file
    if (s_association->exists(dataEngines::fileIO))
      s_association->reset(allTypes::fileIO);
    s_association->addEngine(dataEngines::fileIO,fileName.toStdString().c_str(),dataFormat,selectedDataType,Write);
    try {
      s_association->fileIOEngine()->save(selectedDataType);
    }
    catch (ERRORCODES error) {
      title = QString("Error saving file");
      message = QString::fromStdString(s_association->errorDetails());
      QMessageBox::critical(this,title,message);
      return;
    }
  }
}

void mainWindow::createControlData(FILETYPE dataType, bool complete)
{
  QString title, message;

  // check to see if a data chain already exists and is current
  if (s_association->exists(dataType) && s_association->getData(dataType)->current()) {
    title = QString(tr("Replace current data chain?"));
    message = QString(tr("A data chain currently exists.\nDo you want to replace it?"));
    QMessageBox::StandardButton reply = QMessageBox::question(this,title,message,QMessageBox::Yes | QMessageBox::No,QMessageBox::No);
    if (reply == QMessageBox::Yes)
      s_association->discardRelation(dataType);
  }

  // set up progress bar call back
//  ui->progressBar->reset();
//  analyzer_set_progress_callback(this,progressBarWrapper);

  if (!s_association->exists(dataType)) {
    double ra = 0.0, dec = 0.0;

    switch (dataType) {
      case fileType::InputData:
        if (s_association->exists(fileType::InputWeights)) {
          try {
            s_association->getResolution(fileType::InputWeights, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else {
          ra = ctrlDlg->RAResolution();
          dec = ctrlDlg->decResolution();
        }
        break;
      case fileType::InputWeights:
        if (s_association->exists(fileType::InputData)) {
          try {
            s_association->getResolution(fileType::InputData, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else {
          ra = ctrlDlg->RAResolution();
          dec = ctrlDlg->decResolution();
        }
        break;
      case fileType::InputNoise:
        if (s_association->exists(fileType::InputData)) {
          try {
            s_association->getResolution(fileType::InputData, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else if(s_association->exists(fileType::InputWeights)) {
          try {
            s_association->getResolution(fileType::InputWeights, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else {
          ra = ctrlDlg->RAResolution();
          dec = ctrlDlg->decResolution();
        }
        break;
      case fileType::InputFilter:
        if (s_association->exists(fileType::InputData)) {
          try {
            s_association->getResolution(fileType::InputData, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else if(s_association->exists(fileType::InputWeights)) {
          try {
            s_association->getResolution(fileType::InputWeights, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else {
          ra = ctrlDlg->RAResolution();
          dec = ctrlDlg->decResolution();
        }
        break;
      case fileType::InputBeam:
        if (s_association->exists(fileType::InputData)) {
          try {
            s_association->getResolution(fileType::InputData, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else if(s_association->exists(fileType::InputWeights)) {
          try {
            s_association->getResolution(fileType::InputWeights, ra, dec);
          }
          catch (ERRORCODES error) {
            title = QString(tr("Error getting resolution"));
            message = QString(tr("There was an error getting the data set's resolution.\nThe error is %1."))
                              .arg(QString::fromStdString(s_association->errorDetails((int)error)));
            QMessageBox::critical(this,title,message);
            return;
          }
        }
        else {
          ra = ctrlDlg->RAResolution();
          dec = ctrlDlg->decResolution();
        }
        break;
    }
    try {
      s_association->createEmptyDataSet(dataType,ra,dec);
    }
    catch (ERRORCODES error) {
      title = QString(tr("Error encountered creating data set"));
      message = QString(tr("An error was encountered creating the %1 data set.\nThe error was %2"))
                        .arg(QString::fromStdString(s_association->dataNames((int)dataType)))
                        .arg(QString::fromStdString(s_association->errorDetails((int)error)));
      QMessageBox::critical(this,title,message);
      return;
    }
  }

  CONTROLTYPE dataSet = ctrlDlg->dataPattern();
  double signalStrength = ctrlDlg->controlSignalStrength();
  M_OP operation = ctrlDlg->controlOperation();
  double top = ctrlDlg->highDec();
  double bottom = ctrlDlg->lowDec();
  double from = ctrlDlg->lowRA();
  double to = ctrlDlg->highRA();
  double peakDec = ctrlDlg->decPeak();
  double peakRA = ctrlDlg->RAPeak();
  double fwhm = ctrlDlg->fullWidthHalfMax();
  double checkRA = ctrlDlg->checkerRAWidth();
  double checkDec = ctrlDlg->checkerDecWidth();
  long l = ctrlDlg->harmonicL();
  long m = ctrlDlg->harmonicM();

  matrixData<double>* current = 0;
  inputMatrixData* workspace = 0;
  switch(dataSet) {
    case Regional:
      try {
        s_association->createUniformPatch(dataType,top,bottom,from,to,signalStrength,operation);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create a uniform distribution over a patch of sky failed.\nError code is %1"))
                          .arg(QString::fromStdString(s_association->errorDetails((int)error)));
        QMessageBox::critical(this,title,message);
        return;
      }
      break;
    case Delta:
      try {
        s_association->createDeltaFunction(dataType,peakRA,peakDec,signalStrength,operation);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create a delta function failed.\nError code is %1"))
                          .arg(QString::fromStdString(s_association->errorDetails((int)error)));
        QMessageBox::critical(this,title,message);
        return;
      }
      break;
    case Gaussian:
      try {
        s_association->createGaussian(dataType,peakRA,peakDec,fwhm,signalStrength,operation);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create a Gaussian function failed.\nError code is %1"))
                          .arg(QString::fromStdString(s_association->errorDetails((int)error)));
        QMessageBox::critical(this,title,message);
        return;
      }
      break;
    case Checker:
      try {
        s_association->createCheckerboard(dataType,checkRA,checkDec,signalStrength,operation);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create a checkboard pattern failed.\nError code is %1"))
                          .arg(QString::fromStdString(s_association->errorDetails((int)error)));
        QMessageBox::critical(this,title,message);
        return;
      }
      break;
    case Harmonic:
      try {
        s_association->createHarmonic(dataType,(int)l,(int)m,signalStrength,operation);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create a spherical harmonic function failed.\nError code is %1"))
                          .arg(QString::fromStdString(s_association->errorDetails((int)error)));
        QMessageBox::critical(this,title,message);
        return;
      }
      break;
    case Uniform:
    default:
      try {
        s_association->createUniformSky(dataType, signalStrength, operation);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create a uniform distribution failed.\nError code is %1"))
                          .arg(QString::fromStdString(s_association->errorDetails((int)error)));
        QMessageBox::critical(this,title,message);
        return;
      }
      break;
  }

  configureDisplay(dataType);

  if (complete) {
    s_association->getData(dataType)->dataType(dataType);
    s_association->getData(dataType)->current(true);
  }
  else
    ctrlDlg->configure(true);
}

bool mainWindow::pixelize(FILETYPE inputDataType, FILETYPE pixelDataType) {
  QString title, message;

  switch(inputDataType) {
    case fileType::InputData:
      if (!s_association->exists(fileType::InputData)) {
        title = QString(tr("No data skymap specified"));
        message = QString(tr("No data skymap has been specified.\nDo you wish to create or input a data skymap?"));
        QMessageBox questionBox;
        QPushButton *createButton = questionBox.addButton(tr("Create"),QMessageBox::ActionRole);
        QPushButton *openButton = questionBox.addButton(tr("Open"),QMessageBox::ActionRole);
        QPushButton *noneButton = questionBox.addButton(tr("No"),QMessageBox::ActionRole);
        questionBox.exec();
        if (questionBox.clickedButton() == createButton)
          ctrlDlg->configure(false);
        if (questionBox.clickedButton() == openButton)
          openFile();
        if (questionBox.clickedButton() == noneButton)
          return false;
      }
      else {
        if (!s_association->exists(pixelDataType))
          s_association->generatePixelData(s_association->pixelizationEngine(),inputDataType);
      }
      break;
    case fileType::InputWeights:
      if (!s_association->exists(fileType::InputWeights)) {
        title = QString(tr("No data mask specified"));
        message = QString(tr("No data mask has been specified.\nDo you wish to create or input a data mask skymap?"));
        QMessageBox questionBox;
        QPushButton *createButton = questionBox.addButton(tr("Create"),QMessageBox::ActionRole);
        QPushButton *openButton = questionBox.addButton(tr("Open"),QMessageBox::ActionRole);
        QPushButton *noneButton = questionBox.addButton(tr("No"),QMessageBox::ActionRole);
        questionBox.exec();
        if (questionBox.clickedButton() == createButton)
          ctrlDlg->configure(false);
        if (questionBox.clickedButton() == openButton)
          openFile();
        if (questionBox.clickedButton() == noneButton)
          return false;
      }
      else {
        if (!s_association->exists(pixelDataType))
          s_association->generatePixelData(s_association->pixelizationEngine(),inputDataType);
      }
      break;
    default:
      if (s_association->exists(inputDataType) && !s_association->exists(pixelDataType))
        s_association->generatePixelData(s_association->pixelizationEngine(),inputDataType);
      break;
  }

  if (s_association->exists(pixelDataType))
    return true;
  else
    return false;
}

void mainWindow::pixelize() {
  QString title, message;
  int count = 0;

  // create the pixelization engine, if it doesn't already exist
  if (!s_association->exists(dataEngines::Pixelization)) {
    switch (s_association->pixelizationEngineType()) {
      case HealPIX:
        s_association->addEngine(dataEngines::Pixelization, HealPIX);
        s_association->pixelizationEngine()->scale(healpixDlg->scale());
        s_association->pixelizationEngine()->average(healpixDlg->average());
        s_association->pixelizationEngine()->variance(healpixDlg->variance());
        if (healpixDlg->order())
          s_association->pixelizationEngine()->pixelLayout(Nest);
        else
          s_association->pixelizationEngine()->pixelLayout(Ring);
        s_association->pixelizationEngine()->configured(true);
        break;
      default:
        selectPixelizer();
    }
  }
  else
    if (s_association->pixelizationEngine()->configured() == false) {
      s_association->reset(allTypes::Pixelization);
      switch (s_association->pixelizationEngineType()) {
        case HealPIX:
          s_association->addEngine(dataEngines::Pixelization, HealPIX);
          s_association->pixelizationEngine()->scale(healpixDlg->scale());
          s_association->pixelizationEngine()->average(healpixDlg->average());
          s_association->pixelizationEngine()->variance(healpixDlg->variance());
          if (healpixDlg->order())
            s_association->pixelizationEngine()->pixelLayout(Nest);
          else
            s_association->pixelizationEngine()->pixelLayout(Ring);
          s_association->pixelizationEngine()->configured(true);
          break;
        default:
          selectPixelizer();
      }
    }

  // walk through all input data types
  FILETYPE inputChain = fileType::InputData;
  FILETYPE pixelChain = fileType::PixelizedData;
  int type = (int)fileType::InputData;
  int offset = (int)fileType::PixelizedData - (int)fileType::InputData;

  while (inputChain <= fileType::InputBeam) {
    if (s_association->exists(inputChain) && !s_association->exists(pixelChain)) {
      if (pixelize(inputChain,pixelChain))
        count++;
    }
    inputChain = static_cast<FILETYPE>(++type);
    pixelChain = static_cast<FILETYPE>(offset+type);
    if (pixelChain == fileType::PixelOccupancy) {
      offset++;
      pixelChain = static_cast<FILETYPE>(offset+type);
    }
  }

  if (count)
    configureDisplay(fileType::PixelizedData);

  return;
}

bool mainWindow::transform(FILETYPE pixelDataType, FILETYPE transDataType) {

  if (!s_association->exists(pixelDataType)) {
    if (!s_association->exists(dataEngines::Pixelization))
      selectPixelizer();
    int offset = (int)fileType::PixelizedData - (int)fileType::InputData;
    FILETYPE inputDataType = fileType::Null;
    if (pixelDataType >= fileType::PixelOccupancy)
      inputDataType = static_cast<FILETYPE>((int)pixelDataType - offset - 1);
    else
      inputDataType = static_cast<FILETYPE>((int)pixelDataType - offset);
    pixelize(inputDataType,pixelDataType);
  }
  if (s_association->exists(pixelDataType) && !s_association->exists(transDataType)) {
    s_association->generateTransformedData(s_association->transformationEngine(),pixelDataType);
    return true;
  }
  else
    return false;
}

void mainWindow::transform() {
  QString title, message;
  int count = 0;

  // create transformer engine, if it doesn't already exist
  if (!s_association->exists(dataEngines::Transformation)) {
    switch (s_association->transformationEngineType()) {
      case Rsht:
        s_association->addEngine(dataEngines::Transformation, Rsht);
        s_association->transformationEngine()->minIndex(rshtDlg->minimumIndex());
        s_association->transformationEngine()->maxIndex(rshtDlg->maximumIndex());
        s_association->transformationEngine()->iterations(rshtDlg->iterations());
        s_association->transformationEngine()->configured(true);
        break;
      default:
        selectTransformer();
    }
  }
  else
    if (s_association->transformationEngine()->configured() == false) {
      s_association->reset(allTypes::Transformation);
      switch (s_association->transformationEngineType()) {
        case Rsht:
          s_association->addEngine(dataEngines::Transformation, Rsht);
          s_association->transformationEngine()->minIndex(rshtDlg->minimumIndex());
          s_association->transformationEngine()->maxIndex(rshtDlg->maximumIndex());
          s_association->transformationEngine()->iterations(rshtDlg->iterations());
          s_association->transformationEngine()->configured(true);
          break;
        default:
          selectTransformer();
      }
    }

  // walk through all of the pixelized data types
  FILETYPE pixelChain = fileType::PixelizedData;
  FILETYPE transChain = fileType::TransformedData;
  int type = (int)fileType::PixelizedData;
  int offset = (int)fileType::TransformedData - (int)fileType::PixelizedData;

  while (pixelChain <= fileType::PixelizedBeam) {
    if (!s_association->exists(transChain)) {
      if (transform(pixelChain,transChain))
        count++;
    }
    pixelChain = static_cast<FILETYPE>(++type);
    if (pixelChain == fileType::PixelOccupancy) {
      pixelChain = static_cast<FILETYPE>(++type);
      offset--;
    }
    transChain = static_cast<FILETYPE>(offset+type);
  }

  if (count)
    configureDisplay(fileType::TransformedData);
  return;
}

void mainWindow::analyze() {
  QString title, message;

  //create pseudospectrum engine, if it doesn't already exist
  if (!specDlg->configured())
    specDlg->configure();

  if (!s_association->exists(dataEngines::PseudoSpectrum)) {
    s_association->addEngine(dataEngines::PseudoSpectrum);
    s_association->powerSpectraEngine()->binning(specDlg->binSpectrum());
    s_association->powerSpectraEngine()->computeInverse(specDlg->invertTransforms());
    s_association->powerSpectraEngine()->weight(specDlg->weighIndices());
    s_association->powerSpectraEngine()->indices(specDlg->indicesPerBin());
    s_association->powerSpectraEngine()->maskIndex(specDlg->maskLowestIndices());
    s_association->powerSpectraEngine()->configured(true);
  }
  else
    if (s_association->powerSpectraEngine()->configured() == false) {
      s_association->reset(allTypes::PseudoSpectrum);
      s_association->addEngine(dataEngines::PseudoSpectrum);
      s_association->powerSpectraEngine()->binning(specDlg->binSpectrum());
      s_association->powerSpectraEngine()->computeInverse(specDlg->invertTransforms());
      s_association->powerSpectraEngine()->weight(specDlg->weighIndices());
      s_association->powerSpectraEngine()->indices(specDlg->indicesPerBin());
      s_association->powerSpectraEngine()->maskIndex(specDlg->maskLowestIndices());
      s_association->powerSpectraEngine()->configured(true);
    }

  // check that all of the transformed data exists
  if (!s_association->exists(fileType::TransformedData)) {
    if (!s_association->exists(dataEngines::Transformation))
      selectTransformer();
    if (!transform(fileType::PixelizedData,fileType::TransformedData)) {
      title = QString(tr("No transformed data set available"));
      message = QString(tr("No transformed data set is available.\nPlease check your data entries to insure that one has been entered correctly."));
      QMessageBox::critical(this,title,message);
      return;
    }
  }
  if (!s_association->exists(fileType::TransformedWeights)) {
    if (!s_association->exists(dataEngines::Transformation))
      selectTransformer();
    if (!transform(fileType::PixelizedWeights,fileType::TransformedWeights)) {
      title = QString(tr("No transformed data mask available"));
      message = QString(tr("No transformed data mask is available.\nPlease check your data entries to insure that one has been entered correctly."));
      QMessageBox::critical(this,title,message);
      return;
    }
  }
  if (!s_association->exists(fileType::TransformedNoise)) {
    if (!s_association->exists(dataEngines::Transformation))
      selectTransformer();
    if (!transform(fileType::PixelizedNoise,fileType::TransformedNoise)) {
      s_association->merge(fileType::TransformedNoise,s_association->transformedData(),false);
      s_association->transformedNoise()->dataType(fileType::TransformedNoise);

      // fill vector with white noise
      s_association->createWhiteNoise(s_association->transformedNoise());
    }
  }
  if (!s_association->exists(fileType::TransformedFilter)) {
    if (!s_association->exists(dataEngines::Transformation))
      selectTransformer();
    if (!transform(fileType::PixelizedFilter,fileType::TransformedFilter)) {
      s_association->merge(fileType::TransformedFilter,s_association->transformedData(),false);
      s_association->transformedFilter()->dataType(fileType::TransformedFilter);
      int rows = s_association->transformedFilter()->rows();
      s_association->transformedFilter()->rwAccess().assign(rows,1.0);
    }
  }
  if (!s_association->exists(fileType::TransformedBeam)) {
    if (!s_association->exists(dataEngines::Transformation))
      selectTransformer();
    if (!transform(fileType::PixelizedBeam,fileType::TransformedBeam)) {
      s_association->merge(fileType::TransformedBeam,s_association->transformedData(),false);
      s_association->transformedBeam()->dataType(fileType::TransformedBeam);
      int rows = s_association->transformedData()->rows();
      s_association->transformedBeam()->rwAccess().assign(rows,1.0);
    }
  }

  // everything is here and ready to go, so carry out analysis
  s_association->generatePowerSpectrumData(s_association->powerSpectraEngine());
  configureDisplay(fileType::SpectralData);
  return;
}

void mainWindow::configureDisplay(FILETYPE dataType) {
  //If running pixelizer
  //ui->progressBar->setValue(value);  
  
  
  switch (dataType) {
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::PixelizedNoise:
    case fileType::PixelizedFilter:
    case fileType::PixelizedBeam:
    case fileType::PixelOccupancy:
    case fileType::InverseData:
    case fileType::InverseWeights:
    case fileType::WeightedInverse:
    case fileType::InverseNoise:
    case fileType::InverseFilter:
    case fileType::InverseBeam:
      configureMaps();
      break;
    case fileType::TransformedData:
    case fileType::TransformedWeights:
    case fileType::WeightedTransform:
    case fileType::TransformedNoise:
    case fileType::TransformedFilter:
    case fileType::TransformedBeam:
    case fileType::SpectralData:
    case fileType::EnsembleData:
      configureGraphs();
      break;
    default:
      break;
  }
}

void mainWindow::configureMaps() {
  if (!mapperDlg->configured())
    mapperDlg->configure();
  buildMaps();
}

void mainWindow::buildMaps() {
  QString title, message;
  
  if (!s_association->exists(dataEngines::Mapping))
    s_association->addEngine(dataEngines::Mapping,Mollweide);
  Mapper* mapEng = s_association->mappingEngine();

  int numMaps = 0, displayData = 0;
  FILETYPE dataType = fileType::Null;
  ASSOCIATEDMAP mapType = associatedMap::Null;
  ASSOCIATEDMAP current = associatedMap::Null;
  ALLTYPES   allMapType = allTypes::FILETYPE_LIMIT;
  int type = static_cast<int>(current);
  int assocType = static_cast<int>(mapType);
  int allType = static_cast<int>(allMapType);
  
  while (type >= 0) {
    if (dataType == fileType::Null) {
      dataType = static_cast<FILETYPE>(++type);
      mapType = static_cast<ASSOCIATEDMAP>(++assocType);
      allMapType = static_cast<ALLTYPES>(++allType);
      continue;
    }

    if (dataType == fileType::MAP_LIMIT)
      break;

    if (s_association->exists(dataType)) {
      if(s_association->exists(mapType))
        s_association->reset(allMapType);
      try {
        s_association->generateMap(dataType);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create the map for data type %1 failed.\nError code %2"))
                              .arg(QString::fromStdString(s_association->dataNames((int)dataType)))
                              .arg(QString::fromStdString(s_association->errorDetails(error)));
        QMessageBox::critical(this,title,message);
        return;
      }
      numMaps++;
      displayData += (1 << (type-1));
      current = mapType;
    }
    dataType = static_cast<FILETYPE>(++type);
    mapType = static_cast<ASSOCIATEDMAP>(++assocType);
    allMapType = static_cast<ALLTYPES>(++allType);
  }

  if (numMaps) {
    if (numMaps > 1)
      Q_EMIT selectMapDisplay(displayData);
    else
      displayMap(current);
  }
}

void mainWindow::displayMap(ASSOCIATEDMAP map) {
  QString title, message;

  activeMap = 0;

  switch (map) {
    case associatedMap::InputDataMap:
      activeMap = s_association->inputDataMap()->transferRGBData();
      break;
    case associatedMap::InputWeightsMap:
      activeMap = s_association->inputWeightsMap()->transferRGBData();
      break;
    case associatedMap::WeightedDataMap:
      activeMap = s_association->inputMap()->transferRGBData();
      break;
    case associatedMap::InputNoiseMap:
      activeMap = s_association->inputNoiseMap()->transferRGBData();
      break;
    case associatedMap::InputFilterMap:
      activeMap = s_association->inputFilterMap()->transferRGBData();
      break;
    case associatedMap::InputBeamMap:
      activeMap = s_association->inputBeamMap()->transferRGBData();
      break;
    case associatedMap::PixelizedDataMap:
      activeMap = s_association->pixelDataMap()->transferRGBData();
      break;
    case associatedMap::PixelizedWeightsMap:
      activeMap = s_association->pixelWeightsMap()->transferRGBData();
      break;
    case associatedMap::WeightedPixelMap:
      activeMap = s_association->pixelMap()->transferRGBData();
      break;
    case associatedMap::PixelOccupancyMap:
      activeMap = s_association->pixelOccupancyMap()->transferRGBData();
      break;
    case associatedMap::PixelizedNoiseMap:
      activeMap = s_association->pixelNoiseMap()->transferRGBData();
      break;
    case associatedMap::PixelizedFilterMap:
      activeMap = s_association->pixelFilterMap()->transferRGBData();
      break;
    case associatedMap::PixelizedBeamMap:
      activeMap = s_association->pixelBeamMap()->transferRGBData();
      break;
    case associatedMap::InverseDataMap:
      activeMap = s_association->invDataMap()->transferRGBData();
      break;
    case associatedMap::InverseWeightsMap:
      activeMap = s_association->invWeightsMap()->transferRGBData();
      break;
    case associatedMap::WeightedInverseMap:
      activeMap = s_association->invMap()->transferRGBData();
      break;
    case associatedMap::InverseNoiseMap:
      activeMap = s_association->invNoiseMap()->transferRGBData();
      break;
    case associatedMap::InverseFilterMap:
      activeMap = s_association->invFilterMap()->transferRGBData();
      break;
    case associatedMap::InverseBeamMap:
      activeMap = s_association->invBeamMap()->transferRGBData();
      break;
    default:
      activeMap = 0;
  }

  if (activeMap == 0) {
    title = QString(tr("Error code returned"));
    message = QString(tr("The attempt to display the map for data type %1 failed.\nError: %2"))
                      .arg(QString::fromStdString(s_association->dataNames((int)map)))
                      .arg(QString::fromStdString(s_association->errorDetails(noDatamapError)));
    QMessageBox::critical(this,title,message);
    return;
  }
  paintMap(activeMap);
}

void mainWindow::paintMap(unsigned char* map) {
  QString title, message;
  int width = 0;
  int height = 0;
  activeMap = map;
  
  // create QImage to display
  if (!s_association->exists(dataEngines::Mapping)) {
    title = QString(tr("No mapping engine defined"));
    message = QString(tr("Cannot display the requested map.\nThere isn't any mapping engine defined!"));
    QMessageBox::critical(this,title,message);
  }
  width = s_association->mappingEngine()->width();
  height = s_association->mappingEngine()->height();
  QImage image = QImage(width,height,QImage::Format_RGB32);
  QRgb colorValue;
  
  int mapEnd = height * width * 3;
  int offset = 0, i = 0, j = 0;
  while (offset < mapEnd) {
    i = (offset/3) % width;
    j = (offset/3) / width;
    colorValue = qRgb(activeMap[offset],activeMap[offset+1],activeMap[offset+2]); // read RGB values at point (i,j)
    image.setPixel(i,j,colorValue);
    offset += 3;
  }
 
  // convert QImage to QPixmap and load into graphicsScene
  QPixmap pMap(width,height);
  pMap.convertFromImage(image);
  QGraphicsScene *display = new QGraphicsScene();
  display->addPixmap(pMap);
  
  // display map by loading graphics scene
  ui->mapView->setScene(display);
  ui->mapView->show();
  repaint();
}

void mainWindow::clearMaps()
{
  QGraphicsScene *display = ui->mapView->scene();
  if (display) {
    display->clear();
    ui->mapView->update();
  }
}

void mainWindow::configureGraphs() {
  if (!graphDlg->configured())
    graphDlg->configure();
  buildGraphs();
}

void mainWindow::buildGraphs() {
  QString title, message;

  if (!s_association->exists(dataEngines::Graphing))
    s_association->addEngine(dataEngines::Graphing);
  Grapher* graphEng = s_association->graphingEngine();

  int numGraphs = 0, displayData = 0;
  FILETYPE dataType = fileType::MAP_LIMIT;
  ASSOCIATEDSPECTRUM graphType = associatedSpectrum::Null;
  ASSOCIATEDSPECTRUM current = associatedSpectrum::Null;
  ALLTYPES allGraphType = allTypes::ASSOCIATEMAP_LIMIT;
  int type = static_cast<int>(current);
  int assocType = static_cast<int>(graphType);
  int allType = static_cast<int>(allGraphType);
  
  while (type >= (int)fileType::MAP_LIMIT) {
    if (dataType == fileType::MAP_LIMIT) {
      dataType = static_cast<FILETYPE>(++type);
      graphType = static_cast<ASSOCIATEDSPECTRUM>(++assocType);
      allGraphType = static_cast<ALLTYPES>(++allType);
      continue;
    }

    if (dataType == fileType::GRAPH_LIMIT)
      break;

    if (s_association->exists(dataType)) {
      if (s_association->exists(graphType))
        s_association->reset(allGraphType);
      try {
        s_association->generateGraph(dataType);
      }
      catch (ERRORCODES error) {
        title = QString(tr("Error code returned"));
        message = QString(tr("The attempt to create the graph for data type %1 failed.\nError code %2"))
                              .arg(QString::fromStdString(s_association->dataNames((int)dataType)))
                              .arg(QString::fromStdString(s_association->errorDetails(noDatagraphError)));
        QMessageBox::critical(this,title,message);
        return;
      }
      numGraphs++;
      displayData += (1 << (type-1));
      current = graphType;
    }
    dataType = static_cast<FILETYPE>(++type);
    graphType = static_cast<ASSOCIATEDSPECTRUM>(++assocType);
    allGraphType = static_cast<ALLTYPES>(++allType);
  }

  if (numGraphs) {
    if (numGraphs > 1)
      Q_EMIT selectGraphDisplay(displayData);
    else
      displayGraph(current);
  }
}

void mainWindow::displayGraph(ASSOCIATEDSPECTRUM graph) {
  QString title, message;

  activeGraph = 0;

  switch (graph) {
    case associatedSpectrum::TransformedDataSpectrum:
      activeGraph = s_association->transDataGraph()->transferRGBData();
      break;
    case associatedSpectrum::TransformedWeightsSpectrum:
      activeGraph = s_association->transWeightsGraph()->transferRGBData();
      break;
    case associatedSpectrum::WeightedTransformSpectrum:
      activeGraph = s_association->transGraph()->transferRGBData();
      break;
    case associatedSpectrum::TransformedNoiseSpectrum:
      activeGraph = s_association->transNoiseGraph()->transferRGBData();
      break;
    case associatedSpectrum::TransformedFilterSpectrum:
      activeGraph = s_association->transFilterGraph()->transferRGBData();
      break;
    case associatedSpectrum::TransformedBeamSpectrum:
      activeGraph = s_association->transBeamGraph()->transferRGBData();
      break;
    case associatedSpectrum::SpectralDataSpectrum:
      activeGraph = s_association->spectrumGraph()->transferRGBData();
      break;
    case associatedSpectrum::EnsembleDataSpectrum:
      activeGraph = s_association->ensembleGraph()->transferRGBData();
      break;
    default:
      activeGraph = 0;
  }

  if (activeGraph == 0) {
    title = QString(tr("Error code returned"));
    message = QString(tr("The attempt to display the spectra for data type %1 failed.\nError: %2"))
                      .arg(QString::fromStdString(s_association->dataNames((int)graph)))
                      .arg(QString::fromStdString(s_association->errorDetails(noDatagraphError)));
    QMessageBox::critical(this,title,message);
    return;
  }
  paintGraph(activeGraph);
}

void mainWindow::paintGraph(unsigned char* graph) {
  QString title, message;
  int width = 0;
  int height = 0;
  activeGraph = graph;
  
  // create QImage to display
  if (!s_association->exists(dataEngines::Graphing)) {
    title = QString(tr("No graphing engine defined"));
    message = QString(tr("Cannot display the requested spectrum.\nThere isn't any graphing engine defined!"));
    QMessageBox::critical(this,title,message);
  }

  width = s_association->graphingEngine()->width();
  height = s_association->graphingEngine()->height();
  QImage image = QImage(width,height,QImage::Format_RGB32);
  QRgb colorValue;
  
  int mapEnd = height * width * 3;
  int offset = 0, i = 0, j = 0;
  while (offset < mapEnd) {
    i = (offset/3) % width;
    j = (offset/3) / width;
    colorValue = qRgb(activeGraph[offset],activeGraph[offset+1],activeGraph[offset+2]); // read RGB values at point (i,j)
    image.setPixel(i,j,colorValue);
    offset += 3;
  }
 
  // convert QImage to QPixmap and load into graphicsScene
  QPixmap pGraph(width,height);
  pGraph.convertFromImage(image);
  QGraphicsScene *display = new QGraphicsScene();
  display->addPixmap(pGraph);
  
  // display map by loading graphics scene
  ui->powerView->setScene(display);
  ui->tabWidget->setCurrentWidget(ui->powerTab);
  ui->powerView->show();
}

void mainWindow::clearGraphs()
{
  QGraphicsScene *display = ui->powerView->scene();
  if (display) {
    display->clear();
    ui->powerView->update();
  }
}


void mainWindow::selectPixelizer() {
  int count = 0, i = 1;
  PIXELSCHEME pixCount = static_cast<PIXELSCHEME>(i);
  
  while (i) {
    if (pixCount == PIXELIZER_LIMIT)
      break;
    count++;
    pixCount = static_cast <PIXELSCHEME>(++i);
  }

  if (count > 1) {
    if (!pixSelectDlg->configured())
      pixSelectDlg->configure();
  }
  else {
    if (!healpixDlg->configured())
      healpixDlg->configure();
  }

  return;
}

void mainWindow::selectTransformer() {
  int count = 0, i = 1;
  TRANSFORMERSCHEME transCount = static_cast<TRANSFORMERSCHEME>(i);
  
  while (i) {
    if (transCount == TRANSFORMER_LIMIT)
      break;
    count++;
    transCount = static_cast <TRANSFORMERSCHEME>(++i);
  }  

  if (count > 1) {
    if (!transSelectDlg->configured())
      transSelectDlg->configure();
  }
  else {
    if (!rshtDlg->configured())
      rshtDlg->configure();
  }

  return;
}

void mainWindow::configurePixelizer(PIXELSCHEME scheme) {
  QString title, message;
  bool error = false;

  switch (scheme) {
    case HealPIX:
      healpixDlg->configure();
      break;
    default:
      error = true;
  }

  if (error) {
    title = QString(tr("Pixelization configuration error"));
    message = QString(tr("An invalid pixelization engine was specified.\nPixelization aborted."));
    QMessageBox::critical(this,title,message);
    return;
  }
}

void mainWindow::configureTransformer(TRANSFORMERSCHEME scheme) {
  QString title, message;
  bool error = false;

  switch (scheme) {
    case Rsht:
      rshtDlg->configure();
      break;
    default:
      error = true;
  }

  if (error) {
    title = QString(tr("Transformation configuration error"));
    message = QString(tr("An invalid transformation engine was specified.\nTransformation aborted."));
    QMessageBox::critical(this,title,message);
    return;
  }
}

void mainWindow::reset() {
  ctrlDlg->reset();
  mapperDlg->reset();
  mapSelectDlg->reset();
  pixSelectDlg->reset();
  healpixDlg->reset();
  transSelectDlg->reset();
  rshtDlg->reset();
  specDlg->reset();
    
  clearMaps();
  clearGraphs();

  s_association->reset();

  delete s_progressInterface;
  s_progressInterface = 0;
  ui->progressBar->reset();
}
