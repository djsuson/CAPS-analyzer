/***************************************************************************
 *   fitsmanager.cpp                                                       *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This header provides the definitions for various enumerated lists used  *
 * by the data classes.                                                    *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <string.h>
#include <CCfits/HDU.h>

#include "fitsmanager.h"
#include "basedata.h"
#include "association.h"

#define STORE m_ptr->pHDU().addKey
#define LOAD  m_ptr->pHDU().readKey

fitsManager::fitsManager(association* dataMgr, const char *filename, FILETYPE dataType, CCfits::RWmode mode)
           : fileManager() {
  *fits_err = 0;
  s_association = dataMgr;

  if (!filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  try {
    m_ptr = new CCfits::FITS(filename, mode);
  }
  catch (CCfits::FitsException& err) {
    m_err = fileFitsError;
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    throw m_err;
  }

  m_fileDataType = dataType;
  m_filename = filename;
  m_fileFormat = Fits;
}

fitsManager::fitsManager(association* dataMgr, const char *filename, baseData *data)
           : fileManager() {
  *fits_err = 0;
  s_association = dataMgr;

  if (!data || !filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  m_filename     = filename;
  m_fileDataType = data->dataType();
  m_fileFormat   = Fits;
  m_observatory  = Analyzer;
  m_cols         = data->cols();
  m_rows         = data->rows();
  m_slices       = data->slices();

  switch (m_fileDataType) {
      case fileType::Null:
      m_err = fileInvalidError;
      s_association->errorValue(m_err);
      throw m_err;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_dimensions = 2;
      m_parts = 1;
      m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " +  std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveMatrixD((matrixData<double>*)data)) {
//      if (!saveMatrixD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      m_dimensions = 4;
      m_parts = 2;
      m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveCubeCD((cubeData<complex<double> >*)data)) {
//      if (!saveCubeCD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    case fileType::PixelOccupancy:
      m_dimensions = 1;
      m_parts = 1;
      m_fitsType = fitsInt32;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveVectorI((vectorData<int>*)data)) {
//      if (!saveVectorI(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
    default:
      m_dimensions = 1;
      m_parts = 1;
      m_fitsType = fitsDouble;
      if (!saveBase(filename)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      if (!saveVectorD((vectorData<double>*)data)) {
//      if (!saveVectorD(m_fileDataType)) {
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        throw m_err;
      }
      break;
  }
}
fitsManager::fitsManager(fitsManager* from)
           : fileManager(from) {
  m_ptr =      from->filePtr();
  m_fitsType = from->fitsType();
}

fitsManager::~fitsManager() {
  if (m_ptr) {
    delete m_ptr;
    m_ptr = 0;
  }
}

void fitsManager::open() {
  *fits_err = 0;

  if (!getDataType()) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }
  if (!getDimensions()) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }

  if (!getEnergy()) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }
  m_fileFormat = Fits;

  return;
}

void fitsManager::save(FILETYPE dataType)
{
  baseData *data = 0;
  *fits_err = 0;
  m_err = noErrors;

  if (!(data = s_association->getData(dataType))) {
    m_err = incompleteDatasetError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  m_fileDataType = data->dataType();
  m_fileFormat   = Fits;
  m_observatory  = Analyzer;
  m_cols         = data->cols();
  m_rows         = data->rows();
  m_slices       = data->slices();

  switch (m_fileDataType) {
    case fileType::Null:
      m_err = fileInvalidError;
      s_association->errorValue(m_err);
      throw m_err;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_dimensions = 2;
      m_parts = 1;
      m_fitsType = fitsDouble;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveMatrixD((matrixData<double>*)data))
//      if (!saveMatrixD(m_fileDataType))
        throw m_err;
      break;
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      m_dimensions = 4;
      m_parts = 2;
      m_fitsType = fitsDouble;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveCubeCD((cubeData<complex<double> >*)data))
//      if (!saveCubeCD(m_fileDataType))
        throw m_err;
      break;
    case fileType::PixelOccupancy:
      m_dimensions = 1;
      m_parts = 1;
      m_fitsType = fitsInt32;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveVectorI((vectorData<int>*)data))
//      if (!saveVectorI(m_fileDataType))
        throw m_err;
      break;
    default:
      m_dimensions = 1;
      m_parts = 1;
      m_fitsType = fitsDouble;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveVectorD((vectorData<double>*)data))
//      if (!saveVectorD(m_fileDataType))
        throw m_err;
      break;
  }
  return;

}

void fitsManager::save(ASSOCIATEDMAP map) {

}

void fitsManager::save(ASSOCIATEDSPECTRUM spect) {

}

bool fitsManager::getHeaders(int hdrNum) {

}

bool fitsManager::getDimensions() {
  m_dimensions = 0;
  m_rows       = 1;
  m_cols       = 1;
  m_slices     = 1;
  m_parts      = 1;
  m_minSlice   = 0;
  m_maxSlice   = 0;

  int  *dim[4]     = { &m_cols,  &m_rows,  &m_slices, &m_parts };
  std::string keyname[4] = { "TFIELDS", "NAXIS2", "NAXIS3",  "NAXIS4" };

  // since data is in the first extension, have to be sure to get it from there
  try {
//    LOAD("NAXIS",m_dimensions);
    CCfits::ExtHDU& binTable = m_ptr->extension(1);
    binTable.readKey("NAXIS",m_dimensions);

    if (m_dimensions > 4)
      return false;

    for (int i = 0; i < m_dimensions; i++)
 //     LOAD(keyname[i].c_str(),*dim[i]);
      binTable.readKey(keyname[i].c_str(),*dim[i]);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    return false;
  }

  m_maxSlice = m_slices - 1;

  return true;
}

bool fitsManager::getDataType() {
  FILETYPE type = fileType::Null;
  std::string instrument = "";
  std::string telescope  = "";
  int tempType;

  try {
    // First, we find the file numerical representation type...
    LOAD("BITPIX",tempType);
    m_fitsType = (FITSTYPE)tempType;
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return false;
  }

    /* Next, we determine the "telescope" (really, the data generation device),
       and resolve what the file data represents... */
    try {
      LOAD("TELESCOP",telescope);
    }
    catch (CCfits::FitsException& err) {
      snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
      m_err = fileFitsError;
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
      return false;
    }
    OBSERVATORY obsType = Unknown;
    int obsValue = (int)Unknown;
    while (obsType < OBSERVATORY_LIMIT) {
      obsType = static_cast<OBSERVATORY>(obsValue);
      if (telescope == observatoryNames[obsValue])
        break;
      obsValue++;
    }
    m_observatory = obsType;
    m_fileDataType = fileType::InputData;
    if (m_observatory == Analyzer) {
      try {
        LOAD("INSTRUME",instrument);
      }
      catch (CCfits::FitsException& err) {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        return false;
      }
      for (int dataNamesList = 0; dataNamesList < (int)fileType::FILETYPE_LIMIT; ++ dataNamesList)
        if (dataTypeNames[dataNamesList] == instrument)
          type = static_cast<FILETYPE>(dataNamesList);
      if (type != fileType::FILETYPE_LIMIT)
        m_fileDataType = type;
    }
    if (m_observatory == OBSERVATORY_LIMIT) {
      m_err = fileNoKeyError;
      m_errDetail = errorText[abs(m_err)] + ": Observatory not recognized";
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      return false;
    }

  return true;
}

bool fitsManager::getEnergy() {
  int n;

  switch (m_observatory) {
    case Analyzer:
      n = 0;
      m_minE[n] = 0.0;
      m_maxE[n] = 0.0;
      break;
    case Egret:
      try {
        n = 0;
        char scratchPad[80];

        while (n < m_slices) {
          sprintf(scratchPad,"%s%d","MAXENG",n + 1);
          LOAD(scratchPad,m_maxE[n]);
          sprintf(scratchPad,"%s%d","MINENG",n + 1);
          LOAD(scratchPad,m_minE[n]);
          n++;
        }
      }
      catch (CCfits::FitsException& err) {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        return false;
      }
      break;
    case Telescope_Array:
    case Auger:
    case Kascade:
    case Fermi:
      try {
        std::valarray<double> energyColumn;
        CCfits::ExtHDU& table = m_ptr->extension("EBOUNDS");

        table.column("E_MIN").read(energyColumn,1,m_slices);
        n = 0;
        while (n < m_slices) {
          m_minE[n] = energyColumn[n]/1000.0;
          n++;
        }

        table.column("E_MAX").read(energyColumn,1,m_slices);
        n = 0;
        while (n < m_slices) {
          m_maxE[n] = energyColumn[n]/1000.0;
          n++;
        }
      }
      catch (CCfits::FitsException& err) {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        return false;
      }
      break;
    default:
      return false;
  }

  return true;
}

baseData *fitsManager::data() {
  if (!m_ptr)
    return 0;

  switch (m_fileDataType) {
    case fileType::Null:
      return 0;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
      if (m_observatory != Analyzer)
        return data(m_minSlice,m_maxSlice);
    case fileType::WeightedData:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      return getMatrixD();
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      return getCubeCD();
    case fileType::PixelOccupancy:
      return getVectorI();
    default:
      return getVectorD();
  }
  return 0;
}

inputMatrixData *fitsManager::data(int slice_min, int slice_max) {
  std::valarray<double> fitsData;
  inputMatrixData* in_mat;
  long span, n, begin;
  std::string hduName = "";
  std::vector<string> colName(m_cols,"");
  const std::string cols = "COLUMN-";
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  if (!m_ptr) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": No CCfits pointer";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (!(m_observatory == Egret || m_observatory == Fermi)) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": No slices in file";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min < 0 || slice_max < 0) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number or maximum slice number less than 0";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > m_slices || slice_max > m_slices) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Slice number is greater than the available slices";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > slice_max) {
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number greater than maximum slice number";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  span  = slice_max - slice_min + 1;
  n     = span * m_cols * m_rows;
  begin = slice_min * m_cols * m_rows + 1;

  // set appropriate hdu name to identify extension
  switch (m_fileDataType) {
    case fileType::InputData:
      hduName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      hduName = "RAW_MASK";
      break;
    case fileType::WeightedData:
      hduName = "WEIGHTED_DATA";
      break;
    case fileType::InputNoise:
      hduName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      hduName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      hduName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      hduName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      hduName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      hduName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      hduName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  // set column names
  for (int col = 0; col < m_cols; col++)
    colName[col] = cols + std::to_string(col);

  // create data structure for storage
  in_mat = new inputMatrixData(m_cols,m_rows,m_fileDataType);
  in_mat->initialize();

  numOps = m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  // load data
  try {
    LOAD("CDELT1",ra_res);
    LOAD("CDELT2",dec_res);
    in_mat->RARes(ra_res);
    in_mat->DecRes(dec_res);

    CCfits::ExtHDU& binTable = m_ptr->extension(hduName);
    for (int col = 0; col < m_cols; ++col) {
      binTable.column(colName[col]).read(fitsData,1,m_rows);
      for (int row = 0; row < m_rows; ++row) {
        (*in_mat)[col][row] = fitsData[row];
        currOp++;
//        if(m_showProgress && !(currOp % updateUnit))
//          informProgress(currOp / updateUnit);
      }
    }
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    delete in_mat;
    return 0;
  }

  return in_mat;
}

vectorData<int> *fitsManager::getVectorI() {
  vectorData<int> *i_vec;
  std::string layout = "", scheme = "";
  std::string hduName = "PIXEL_OCCUPANCY";
  std::valarray<int> fitsData;
  std::vector<string> colName(1,"");
  std::vector<string> colFormat(1,"");
  colName[0] = "Value";
  colFormat[0] = "J";
  int sides = 0, maxIndex = 0, minIndex = 0;
  int maxValue = 0, minValue = 0;
  unsigned long long int numOps, updateUnit, currOp;

  try {
    LOAD("NSIDES", sides);
    LOAD("PIXLAYOUT",layout);
    LOAD("PIXSCHEME",scheme);
    LOAD("MAXVALUE",maxValue);
    LOAD("MINVALUE",minValue);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return 0;
  }

  i_vec = new vectorData<int>(m_rows,m_fileDataType);
  i_vec->initialize();
  i_vec->sides(sides);
  i_vec->maxYIndex(maxValue);
  i_vec->minYIndex(minValue);

  if (layout == "Ring")
    i_vec->layout(Ring);
  else if (layout == "Nest")
    i_vec->layout(Nest);
  else
    i_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    i_vec->pixelScheme(HealPIX);
    i_vec->numberOfPixels(12 * sides * sides);
  }
  else {
    i_vec->pixelScheme(NotPixelized);
    i_vec->numberOfPixels(0);
  }

  try {
    CCfits::ExtHDU& binTable = m_ptr->extension(hduName);
    binTable.column(colName[0]).read(fitsData,1,m_rows);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  for (int row = 0; row < m_rows; ++row) {
    (*i_vec)[row] = fitsData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return i_vec;
}

vectorData<double> *fitsManager::getVectorD() {
  vectorData<double> *d_vec;
  std::string layout = "", scheme = "",trans  = "";
  std::string hduName = "";
  std::valarray<double> fitsData;
  std::vector<string> colName(1,"");
  std::vector<string> colFormat(1,"");
  colName[0] = "Value";
  colFormat[0] = "D";
  int sides = 0, maxIndex = 0, minIndex = 0, mask = 0;
  double maxValue = 0, minValue = 0;
  unsigned long long int numOps, updateUnit, currOp;

  switch (m_fileDataType) {
    case fileType::PixelizedData:
      hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedWeights:
      hduName = "PIXEL_MASK";
      break;
    case fileType::WeightedPixel:
      hduName = "PIXEL_WEIGHTED_DATA";
      break;
    case fileType::PixelizedNoise:
      hduName = "PIXEL_NOISE";
      break;
    case fileType::PixelizedFilter:
      hduName = "PIXEL_FILTER";
      break;
    case fileType::PixelizedBeam:
      hduName = "PIXEL_BEAM";
      break;
    case fileType::InverseData:
      hduName = "INVERSE_DATA";
      break;
    case fileType::InverseWeights:
      hduName = "INVERSE_MASK";
      break;
    case fileType::InverseNoise:
      hduName = "INVERSE_NOISE";
      break;
    case fileType::InverseFilter:
      hduName = "INVERSE_FILTER";
      break;
    case fileType::InverseBeam:
      hduName = "INVERSE_BEAM";
      break;
    case fileType::TransformedData:
      hduName = "TRANSFORMED_DATA";
      break;
    case fileType::TransformedWeights:
      hduName = "TRANSFORMED_MASK";
      break;
    case fileType::WeightedTransform:
      hduName = "WEIGHTED_TRANSFORM";
      break;
    case fileType::TransformedNoise:
      hduName = "TRANSFORMED_NOISE";
      break;
    case fileType::TransformedFilter:
      hduName = "TRANSFORMED_FILTER";
      break;
    case fileType::TransformedBeam:
      hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::SpectralData:
      hduName = "PSEUDO-SPECTRAL_DATA";
      break;
  }

  try {
    switch (m_fileDataType) {
      case fileType::PixelizedData:
      case fileType::PixelizedWeights:
      case fileType::WeightedPixel:
      case fileType::PixelizedNoise:
      case fileType::PixelizedFilter:
      case fileType::PixelizedBeam:
      case fileType::InverseData:
      case fileType::InverseWeights:
      case fileType::InverseNoise:
      case fileType::InverseFilter:
      case fileType::InverseBeam:
        LOAD("NSIDES",sides);
        LOAD("PIXLAYOUT",layout);
        LOAD("PIXSCHEME",scheme);
        break;
      case fileType::TransformedData:
      case fileType::TransformedWeights:
      case fileType::WeightedTransform:
      case fileType::TransformedNoise:
      case fileType::TransformedFilter:
      case fileType::TransformedBeam:
        LOAD("TRANSFORMERSCHEME",trans);
        LOAD("MAXINDEX",maxIndex);
        LOAD("MININDEX",minIndex);
        break;
      case fileType::SpectralData:
        LOAD("MAXINDEX",maxIndex);
        LOAD("MININDEX",minIndex);
        LOAD("MAXVALUE",maxValue);
        LOAD("MINVALUE",minValue);
        LOAD("MASKINDEX",mask);
        break;
    }
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return 0;
  }

  d_vec = new vectorData<double>(m_rows,m_fileDataType);
  d_vec->initialize();
  d_vec->sides(sides);
  d_vec->maxYIndex(maxIndex);
  d_vec->minYIndex(minIndex);
  d_vec->maxValue(maxValue);
  d_vec->minValue(minValue);
  d_vec->mask(mask);

  if (layout == "Ring")
    d_vec->layout(Ring);
  else if (layout == "Nest")
    d_vec->layout(Nest);
  else
    d_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    d_vec->pixelScheme(HealPIX);
    d_vec->numberOfPixels(12 * sides * sides);
  }
  else {
    d_vec->pixelScheme(NotPixelized);
    d_vec->numberOfPixels(0);
  }

  if (trans == "Rsht")
    d_vec->transformerScheme(Rsht);
  else
    d_vec->transformerScheme(NotTransformed);

  try {
    CCfits::ExtHDU& binTable = m_ptr->extension(hduName);
    binTable.column(colName[0]).read(fitsData,1,m_rows);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  for (int row = 0; row < m_rows; ++row) {
    (*d_vec)[row] = fitsData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return d_vec;
}

matrixData<double> *fitsManager::getMatrixD() {
  matrixData<double> *d_mat;
  std::valarray<double> fitsData;
  std::string hduName = "";
  std::vector<string> colName(m_cols,"");
  const std::string cols = "COLUMN-";
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  // set appropriate hdu name to identify extension
  switch (m_fileDataType) {
    case fileType::InputData:
      hduName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      hduName = "RAW_MASK";
      break;
    case fileType::WeightedData:
      hduName = "WEIGHTED_DATA";
      break;
    case fileType::InputNoise:
      hduName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      hduName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      hduName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      hduName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      hduName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      hduName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      hduName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  // set column names
  for (int col = 0; col < m_cols; ++col)
    colName[col] = cols + std::to_string(col);

  // create data structure for storage
  d_mat = new matrixData<double>(m_cols,m_rows,m_fileDataType);
  d_mat->initialize();

  numOps = m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  // load data
  try {
    LOAD("CDELT1",ra_res);
    LOAD("CDELT2",dec_res);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    delete d_mat;
    return 0;
  }
  d_mat->RARes(ra_res);
  d_mat->DecRes(dec_res);

  try {
    CCfits::ExtHDU& binTable = m_ptr->extension(hduName);
    for (int col = 0; col < m_cols; ++col) {
      binTable.column(colName[col]).read(fitsData,1,m_rows);
      for (int row = 0; row < m_rows; ++row) {
        (*d_mat)[col][row] = fitsData[row];
        currOp++;
//        if(m_showProgress && !(currOp % updateUnit))
//          informProgress(currOp / updateUnit);
      }
    }
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    delete d_mat;
    return 0;
  }

  return d_mat;
}

cubeData<std::complex<double> > *fitsManager::getCubeCD() {
  cubeData<std::complex<double> > *dc_cube;
  std::vector<std::vector<std::vector<std::complex<double> > > > data;
  std::vector<std::complex<double> > fitsData;
  std::string hduName = "";
  std::vector<string> colName(m_cols,"");
  const std::string cols = "COLUMN-";
  int polarization, index; //, offset;
  unsigned long long int numOps, updateUnit, currOp;
  int slice = 0, col = 0, row = 0;

  switch (m_fileDataType) {
    case fileType::AlmData:
      hduName = "ALM_DATA";
      break;
    case fileType::AlmWeights:
      hduName = "ALM_MASK";
      break;
    case fileType::AlmNoise:
      hduName = "ALM_NOISE";
      break;
    case fileType::AlmFilter:
      hduName = "ALM_FILTER";
      break;
    case fileType::AlmBeam:
      hduName = "ALM_BEAM";
      break;
  }

  // set column names
  for (col = 0; col < m_cols; ++col)
    colName[col] = cols + std::to_string(col);

  dc_cube = new cubeData<std::complex<double> >(m_cols,m_rows,m_slices,m_fileDataType);
  dc_cube->initialize();
  data = dc_cube->rwAccess();

  numOps = m_slices;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  try {
    /* These may not be necessary anymore (redundant with rows, slices)... */
    LOAD("POLARIZATION",polarization);
    LOAD("INDEX",index);
    dc_cube->polarization(polarization);
    dc_cube->index(index);
    CCfits::ExtHDU& binTable = m_ptr->extension(hduName);
    fitsData.resize(m_rows);
    for (slice = 0; slice < m_slices; ++slice) {
      for (col = 0; col < m_cols; ++col) {
        binTable.column(colName[col]).read(fitsData,1,m_rows);
        for (row = 0; row < m_rows; ++row) {
          data[slice][col][row] = fitsData[row];
        }
      }
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
    }
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  return dc_cube;
}

dataMap* fitsManager::getMap() {
  return 0;
}

dataSpectrum* fitsManager::getSpectrum() {
  return 0;
}

bool fitsManager::saveBase(const char* filename) {
  long naxes[4] = {m_cols,m_rows,m_slices,m_parts};
  std::string text, comment = "Entity which generated data.";

  if (m_ptr == 0)
    try {
      m_ptr = new CCfits::FITS(filename,m_fitsType,m_dimensions,naxes);
    }
    catch (CCfits::FitsException& err) {
      m_err = fileFitsError;
      snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      return false;
    }

  /* All data saved will be tagged as "Analyzer" data. In memory
     data generated from other observatories will be noted as such in
     the FITS comment section... */
  if (m_observatory != Analyzer) {
    text = observatoryNames[(int)m_observatory];
    comment  = "Compiled from ";
    comment += text;
    comment += " data file.";
    m_observatory = Analyzer;
  }

  try {
    STORE("TELESCOP","Analyzer",comment);
    text = dataTypeNames[(int)m_fileDataType];
    STORE("INSTRUME",text,"Type of data stored in file.");
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return false;
  }

  return true;
}

bool fitsManager::saveVectorI(vectorData<int> *v) {
  std::valarray<int> fitsData;
  std::string layout, scheme;
  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  std::vector<string> colName(1,"");
  std::vector<string> colFormat(1,"");
  colName[0] = "Value";
  colFormat[0] = "J";
  CCfits::Table* binTable = 0;

  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  fitsData.resize(m_rows);
  for (int row = 0; row < m_rows; row++) {
    fitsData[row] = (*v)[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  try {
    STORE("NSIDES",v->sides(),"Number of sides.");
    STORE("PIXLAYOUT",layout, "Type of layout used to pixelize.");
    STORE("PIXSCHEME",scheme, "Type of pixel scheme used to pixelize.");
    STORE("MAXVALUE",v->maxValue(),"Maximum number of data points in a pixel.");
    STORE("MINVALUE",v->minValue(),"Minimum number of data points in a pixel.");
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return 0;
  }
  hduName = "PIXEL_OCCUPANCY";
  try {
    binTable = m_ptr->addTable(hduName,m_rows,colName,colFormat);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  try {
    binTable->column(colName[0]).write(fitsData,1);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveVectorD(vectorData<double> *v) {
  std::valarray<double> fitsData;
  std::string layout, scheme, trans;
  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  std::vector<string> colName(1,"");
  std::vector<string> colFormat(1,"");
  colName[0] = "Value";
  colFormat[0] = "D";
  CCfits::Table* binTable = 0;

  switch (m_fileDataType) {
    case fileType::PixelizedData:
      hduName = "PIXEL_DATA";
      break;
    case fileType::PixelizedWeights:
      hduName = "PIXEL_MASK";
      break;
    case fileType::PixelizedNoise:
      hduName = "PIXEL_NOISE";
      break;
    case fileType::PixelizedFilter:
      hduName = "PIXEL_FILTER";
      break;
    case fileType::PixelizedBeam:
      hduName = "PIXEL_BEAM";
      break;
    case fileType::InverseData:
      hduName = "INVERSE_DATA";
      break;
    case fileType::InverseWeights:
      hduName = "INVERSE_MASK";
      break;
    case fileType::InverseNoise:
      hduName = "INVERSE_NOISE";
      break;
    case fileType::InverseFilter:
      hduName = "INVERSE_FILTER";
      break;
    case fileType::InverseBeam:
      hduName = "INVERSE_BEAM";
      break;
    case fileType::TransformedData:
      hduName = "TRANSFORMED_DATA";
      break;
    case fileType::TransformedWeights:
      hduName = "TRANSFORMED_MASK";
      break;
    case fileType::TransformedNoise:
      hduName = "TRANSFORMED_NOISE";
      break;
    case fileType::TransformedFilter:
      hduName = "TRANSFORMED_FILTER";
      break;
    case fileType::TransformedBeam:
      hduName = "TRANSFORMED_BEAM";
      break;
    case fileType::SpectralData:
      hduName = "PSEUDO-SPECTRAL_DATA";
      break;
  }
  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  if (v->transformerScheme() == Rsht)
    trans = std::string("Rsht");
  else
    trans = std::string("NotTransformed");

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  fitsData.resize(m_rows);
  for (int row = 0; row < m_rows; row++) {
    fitsData[row] = (*v)[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
//  int nSides = 0;
  try {
    switch (m_fileDataType) {
      case fileType::PixelizedData:
      case fileType::PixelizedWeights:
      case fileType::WeightedPixel:
      case fileType::PixelizedNoise:
      case fileType::PixelizedFilter:
      case fileType::PixelizedBeam:
      case fileType::InverseData:
      case fileType::InverseWeights:
      case fileType::InverseNoise:
      case fileType::InverseFilter:
      case fileType::InverseBeam:
        STORE("NSIDES",v->sides(),"Number of sides.");
        STORE("PIXLAYOUT",layout, "Type of layout used to pixelize.");
        STORE("PIXSCHEME",scheme, "Type of pixel scheme used to pixelize.");
        break;
      case fileType::TransformedData:
      case fileType::TransformedWeights:
      case fileType::WeightedTransform:
      case fileType::TransformedNoise:
      case fileType::TransformedFilter:
      case fileType::TransformedBeam:
        STORE("TRANSFORMERSCHEME",trans,"Type of transformer scheme");
        STORE("MAXINDEX",v->maxYIndex(), "Maximum index");
        STORE("MININDEX",v->minYIndex(), "Minimum index");
        break;
      case fileType::SpectralData:
        STORE("MAXINDEX",v->maxYIndex(),"Maximum index");
        STORE("MININDEX",v->minYIndex(),"Minimum index");
        STORE("MAXVALUE",v->maxValue(),"Maximum value");
        STORE("MINVALUE",v->minValue(),"Minimum value");
        STORE("MASKINDEX",v->mask(),   "Mask index");
        break;
    }
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return 0;
  }

  try {
    binTable = m_ptr->addTable(hduName,m_rows,colName,colFormat);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  try {
    binTable->column(colName[0]).write(fitsData,1);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveMatrixD(matrixData<double> *m) {
  std::valarray<double> fitsData;
  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  std::vector<string> colName(m_cols,"");
  std::vector<string> colFormat(m_cols,"");
  const std::string cols = "COLUMN-";
  CCfits::Table* binTable = 0;

  switch (m_fileDataType) {
    case fileType::InputData:
      hduName = "RAW_DATA";
      break;
    case fileType::InputWeights:
      hduName = "RAW_MASK";
      break;
    case fileType::InputNoise:
      hduName = "RAW_NOISE";
      break;
    case fileType::InputFilter:
      hduName = "RAW_FILTER";
      break;
    case fileType::InputBeam:
      hduName = "RAW_BEAM";
      break;
    case fileType::BinCouplingMatrix:
      hduName = "BIN_COUPLING_MATRIX";
      break;
    case fileType::ModeCouplingMatrix:
      hduName = "MODE_COUPLING_MATRIX";
      break;
    case fileType::InverseBinMatrix:
      hduName = "INVERSE_BIN_COUPLING_MATRIX";
      break;
    case fileType::InverseModeMatrix:
      hduName = "INVERSE_MODE_COUPLING_MATRIX";
      break;
  }

  try {
    STORE("CDELT1",m->RARes(), "RaResolution of data stored in file.");
    STORE("CDELT2",m->DecRes(),"DecResolution of data stored in file.");
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return false;
  }
  for (int i = 0; i < m_cols; i++) {
    colName[i] = cols + std::to_string(i);
    colFormat[i] = "D";
  }
  try {
    binTable = m_ptr->addTable(hduName,m_rows,colName,colFormat);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }
  numOps = m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  fitsData.resize(m_rows);
  for (int i = 0; i < m_cols; ++i) {
    for (int j = 0; j < m_rows; ++j) {
      fitsData[j] = (*m)[i][j];
      currOp++;
//      if(m_showProgress && !(currOp % updateUnit))
//        informProgress(currOp / updateUnit);
    }
    try {
      binTable->column(colName[i]).write(fitsData,1);
    }
    catch (CCfits::FitsException& err) {
      snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
      m_err = fileFitsError;
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      return false;
    }
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveCubeCD(cubeData<complex<double> > *c) {
  std::valarray<std::complex<double> >fitsData;
  unsigned long long int numOps, updateUnit, currOp;
  std::string hduName = "";
  std::vector<string> colName(m_cols,"");
  std::vector<string> colFormat(m_cols,"");
  const std::string cols = "COLUMN-";
  CCfits::Table* binTable = 0;

  switch (m_fileDataType) {
    case fileType::AlmData:
      hduName = "ALM_DATA";
      break;
    case fileType::AlmWeights:
      hduName = "ALM_MASK";
      break;
    case fileType::AlmNoise:
      hduName = "ALM_NOISE";
      break;
    case fileType::AlmFilter:
      hduName = "ALM_FILTER";
      break;
    case fileType::AlmBeam:
      hduName = "ALM_BEAM";
      break;
  }
  std::vector<std::vector<std::vector<complex<double> > > > data = c->roAccess();

  try {
    STORE("POLARIZATION",c->polarization(),"Polarization of data.");
    STORE("INDEX",c->index(),"Index of data stored in file.");
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    return false;
  }

  for (int col = 0; col < m_cols; col++) {
    colName[col] = cols + std::to_string(col);
    colFormat[col] = "M";
  }
  try {
    binTable = m_ptr->addTable(hduName,m_rows,colName,colFormat);
  }
  catch (CCfits::FitsException& err) {
    snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
    m_err = fileFitsError;
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }
  numOps = m_slices * m_rows * m_cols;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  fitsData.resize(m_rows);
  for (int slice = 0; slice < m_slices; ++slice) {
    for (int col = 0; col < m_cols; ++col) {
      for (int row = 0; row < m_rows; ++row) {
        fitsData[row] = data[slice][col][row];
        currOp++;
//        if(m_showProgress && !(currOp % updateUnit))
//          informProgress(currOp / updateUnit);
      }
      try {
        binTable->column(colName[col]).write(fitsData,1);
      }
      catch (CCfits::FitsException& err) {
        snprintf(fits_err,FITS_ERR_LEN,"%s",err.message().c_str());
        m_err = fileFitsError;
        m_errDetail = errorText[abs(m_err)] + ": " + std::string(fits_err);
        s_association->errorValue(m_err);
        s_association->errorDetails(m_errDetail);
        return false;
      }
    }
  }

  if (m_err != noErrors) {
    m_err = incompleteTableWrittenError;
    s_association->errorValue(m_err);
    return false;
  }

  return true;
}

bool fitsManager::saveMap(dataMap* map) {
  return true;
}

bool fitsManager::saveSpectrum(dataSpectrum* spect) {
  return true;
}
