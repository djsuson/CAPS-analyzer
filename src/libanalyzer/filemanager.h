/***************************************************************************
 *   filemanager.h                                                       *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * Interface for all file manager types.                                   *
 *                                                                         *
 * Subclasses shall implement two constructors:                            *
 *                                                                         *
 *    <fileclass> (const char *load_filename);                             *
 *    <fileclass> (baseData *data, const char *save_filename);             *
 *                                                                         *
 * These will load and save data, respectively. The "save"                 *
 * constructor can assume the proper FILETYPE has been set inside the      *
 * baseData object...                                                      *
 *                                                                         *
 * In all cases the subclass shall insure that the opened file is closed   *
 * when its destructor is called.                                          *
 *                                                                         *
 * If a property does not exist for a certain file, the subclass           *
 * shall assign the empty value (for enum types), and 0 or 1 to valued     *
 * types, which ever makes sense: e.g. dimensional values cannot be less   *
 * than one if ANY file data exists.                                       *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#ifndef __FILEMANAGER_H__
#define __FILEMANAGER_H__

#include <sigc++/sigc++.h>
#include <string>
#include "atypes.h"
#include "association.h"
#include "basedata.h"
#include "inputmatrixdata.h"
#include "../libgraphics/datamap.h"
#include "../libgraphics/dataspectrum.h"

#define     ERR_DETAIL_LEN  256
#define 	MAX_SLICES		100

// typedef void (*updateFx)(void*, int);

class fileManager {

  public:
    fileManager();
    fileManager(fileManager* from);
    virtual ~fileManager() {}

    fileManager& operator=(fileManager& other);

    void         fileName(const char* name)  {m_filename = name;}
    const char*  fileName()                  {return m_filename;}
    void         fileDataType(FILETYPE type) {m_fileDataType = type;}
    FILETYPE     fileDataType()              { return m_fileDataType;}
    void         fileFormat(FORMAT format)   {m_fileFormat = format; }
    FORMAT       fileFormat()                { return m_fileFormat; }
    OBSERVATORY  observatory()               { return m_observatory; }
    int          dimensions()                { return m_dimensions; }
    int          rows()                      { return m_rows; }
    int          cols()                      { return m_cols; }
    int          slices()                    { return m_slices; }
    int          parts()                     { return m_parts; }
    void         minSlice(int slice)        { m_minSlice = slice; }
    int          minSlice()                 { return m_minSlice; }
    void         maxSlice(int slice)        { m_maxSlice = slice; }
    int          maxSlice()                 {return m_maxSlice; }
    float        sliceEnergyMin(int slice)   { return m_minE[slice]; }
    float        sliceEnergyMax(int slice)   { return m_maxE[slice]; }
    float        min_energy()                { return m_minE[0]; }
    float        max_energy()                { return m_maxE[0]; }
    float        min_energy(int i);
    float        max_energy(int i);
    void         min_energy(int i, float E);
    void         max_energy(int i, float E);
    void         error(ERRORCODES code)     {m_err = code; }
    ERRORCODES   error()                    {return m_err; }
    std::string  errorDescription()         {return m_errDetail;}
    std::string  errorDescription(ERRORCODES value);

    virtual void            open()                         = 0;
    virtual void            save(FILETYPE dataType)        = 0;
    virtual void            save(ASSOCIATEDMAP  map)       = 0;
    virtual void            save(ASSOCIATEDSPECTRUM spect) = 0;
    virtual baseData        *data()                        = 0;
    virtual inputMatrixData *data(int s_min,int s_max)     = 0;
    virtual inputMatrixData *data(float e_min,float e_max) = 0;

    virtual bool getHeaders(int hdrNum) {return false;}
    virtual bool getDimensions() {return false;}
    virtual bool getDataType() {return false;}
    virtual bool getEnergy() {return false;}
   
   /**
    * set up progress signal
    */
    void updateProgress(int value);
    sigc::signal<void(int)> signalProgress();
    void setProgressFunc(void* uiObject,void (*func)(void*,int));
    void  informProgress(int progress);                                  // This is called by data
    void  showProgress(sigc::signal<void(int)> show) {m_showProgress = show;}
    sigc::signal<void(int)> showProgress() const {return m_showProgress;}
    void* userInterface() const {return m_uiObject;}
    updateFx updateFunction() const {return m_updateFunc;}

  protected:
    FILETYPE                 m_fileDataType;
    FORMAT                   m_fileFormat;
    OBSERVATORY              m_observatory;

    sigc::signal<void(int)>  m_showProgress;
    void*                    m_uiObject;
    updateFx                 m_updateFunc;

    int                      m_dimensions;
    int                      m_rows;
    int                      m_cols;
    int                      m_slices;
    int                      m_parts;

    float                    m_minE[MAX_SLICES];
    float                    m_maxE[MAX_SLICES];
    int                      m_minSlice;
    int                      m_maxSlice;

    ERRORCODES               m_err;
    std::string              m_errDetail;
    const char*              m_filename;
};

#endif /* __FILEMANAGER_H__ */
