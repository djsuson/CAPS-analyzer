/***************************************************************************
 *   association.h                                                         *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * The association class collects all of the various data objects together *
 * for easy checking of the data chain as well as the associated action    *
 * engines for generating additional steps.                                *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#ifndef _ASSOCIATION_H_
#define _ASSOCIATION_H_

#include <math.h>

#include "atypes.h"
#include "basedata.h"
#include "../libgraphics/progress.h"

template <typename _type> class vectorData;
template <typename _type> class matrixData;
template <typename _type> class cubeData;
class inputMatrixData;
class dataMap;
class fileManager;
class Mapper;
class Grapher;
class dataSpectrum;
class Transformer;
class Pixelizer;
class Spectrum;

typedef void (*updateFx)(void*, int);

class association {
public:
  association();
  association(association* from);
  ~association() {reset();}

  /**
   * set two associations equal to each other.
   */
  association& operator=(association& other);

  /**
   * merge two associations. If replace = false, only merge if target is null, otherwise
   * completely replace the association
   */
  association& merge(association& other, bool replace = true);

  /**
   * merge specific data elements or engines.
   */
  baseData& merge(FILETYPE dataType, baseData* other, bool replace = true);
  dataMap& merge(ASSOCIATEDMAP mapType, dataMap* other, bool replace = true);
  dataSpectrum& merge(ASSOCIATEDSPECTRUM graphType, dataSpectrum* other, bool replace = true);
  Mapper& merge(MAPTYPE mapType, Mapper* other, bool replace = true);
  Grapher& merge(Grapher*other, bool replace = true);
  fileManager& merge(FORMAT ext, fileManager* other, bool replace = true);
  Pixelizer& merge(PIXELSCHEME pixType, Pixelizer* other, bool replace = true);
  Transformer& merge(TRANSFORMERSCHEME transType, Transformer* other, bool replace = true);
  Spectrum& merge(Spectrum* other, bool replace = true);

public:

  /**
   * access data chain
   */
  matrixData<double>* inputData() const {return m_inputData;}
  vectorData<double>* pixelizedData() const {return m_pixelData;}
  vectorData<double>* transformedData() const {return m_transData;}
  cubeData<std::complex<double> >* almData() const {return m_almData;}
  vectorData<double>* inverseData() const {return m_invData;}

  /**
   * access weights chain
   */
  matrixData<double>* inputWeights() const {return m_inputWeights;}
  vectorData<double>* pixelizedWeights() const {return m_pixelWeights;}
  vectorData<double>* transformedWeights() const {return m_transWeights;}
  cubeData<std::complex<double> >* almWeights() const {return m_almWeights;}
  vectorData<double>* inverseWeights() const {return m_invWeights;}

  /**
   * access noise data
   */
  matrixData<double>* inputNoise() const {return m_inputNoise;}
  vectorData<double>* pixelizedNoise() const {return m_pixelNoise;}
  vectorData<double>* transformedNoise() const {return m_transNoise;}
  cubeData<std::complex<double> >* almNoise() const {return m_almNoise;}
  vectorData<double>* inverseNoise() const {return m_invNoise;}

  /**
   * access filter data
   */
  matrixData<double>* inputFilter() const {return m_inputFilter;}
  vectorData<double>* pixelizedFilter() const {return m_pixelFilter;}
  vectorData<double>* transformedFilter() const {return m_transFilter;}
  cubeData<std::complex<double> >* almFilter() const {return m_almFilter;}
  vectorData<double>* inverseFilter() const {return m_invFilter;}

  /**
   * access beam data
   */
  matrixData<double>* inputBeam() const {return m_inputBeam;}
  vectorData<double>* pixelizedBeam() const {return m_pixelBeam;}
  vectorData<double>* transformedBeam() const {return m_transBeam;}
  cubeData<std::complex<double> >* almBeam() const {return m_almBeam;}
  vectorData<double>* inverseBeam() const {return m_invBeam;}

  /**
   * access spectrum data
   */
  vectorData<double>* spectrumData() const {return m_spectData;}
  vectorData<double>* ensembleData() const {return m_ensembleSpectData;}

  /**
   * access pixel occupancy
   */
  vectorData<int>* pixelOccupancy() const {return m_pixelOccupancy;}


  /**
   * access coupling matrix data
   */
  matrixData<double>* couplingMatrix() const {return m_couplingMatrix;}
  matrixData<double>* inverseMatrix() const {return m_inverseMatrix;}  

  /**
   * access maps
   */
  dataMap* inputDataMap() const {return m_inputDataMap;}
  dataMap* inputWeightsMap() const {return m_inputWeightsMap;}
  dataMap* inputMap() const {return m_inputMap;}
  dataMap* inputNoiseMap() const {return m_inputNoiseMap;}
  dataMap* inputFilterMap() const {return m_inputFilterMap;}
  dataMap* inputBeamMap() const {return m_inputBeamMap;}

  dataMap* pixelDataMap() const {return m_pixelDataMap;}
  dataMap* pixelWeightsMap() const {return m_pixelWeightsMap;}
  dataMap* pixelMap() const {return m_pixelMap;}
  dataMap* pixelOccupancyMap() const {return m_pixelOccupancyMap;}
  dataMap* pixelNoiseMap() const {return m_pixelNoiseMap;}
  dataMap* pixelFilterMap() const {return m_pixelFilterMap;}
  dataMap* pixelBeamMap() const {return m_pixelBeamMap;}

  dataMap* invDataMap() const {return m_invDataMap;}
  dataMap* invWeightsMap() const {return m_invWeightsMap;}
  dataMap* invMap() const {return m_invMap;}
  dataMap* invFilterMap() const {return m_invFilterMap;}
  dataMap* invBeamMap() const {return m_invBeamMap;}
  dataMap* invNoiseMap() const {return m_invNoiseMap;}

  /**
   * access transformed data graphs
   */
  dataSpectrum* transDataGraph() const {return m_transDataGraph;}
  dataSpectrum* transWeightsGraph() const {return m_transWeightsGraph;}
  dataSpectrum* transGraph() const {return m_transGraph;}
  dataSpectrum* transFilterGraph() const {return m_transFilterGraph;}
  dataSpectrum* transNoiseGraph() const {return m_transNoiseGraph;}
  dataSpectrum* transBeamGraph() const {return m_transBeamGraph;}
  dataSpectrum* spectrumGraph() const {return m_spectDataGraph;}
  dataSpectrum* ensembleGraph() const {return m_ensembleDataGraph;}

  /**
   * access data engines
   */
  fileManager* fileIOEngine() const {return m_fileIOEngine;}
  FORMAT fileIOEngineType() const {return m_selectedIOEngine;}
  void fileIOEngineType(FORMAT engine) {m_selectedIOEngine = engine;}
  Mapper* mappingEngine() const {return m_mapEngine;}
  MAPTYPE mappingEngineType() const {return m_selectedMapEngine;}
  void mapEngineType(MAPTYPE engine) {m_selectedMapEngine = engine;}
  Grapher* graphingEngine() const {return m_graphEngine;}
  Pixelizer* pixelizationEngine() const {return m_pixelEngine;}
  PIXELSCHEME pixelizationEngineType() const {return m_selectedPixelEngine;}
  void pixelizationEngineType(PIXELSCHEME engine) {m_selectedPixelEngine = engine;}
  Transformer* transformationEngine() const {return m_transformEngine;}
  TRANSFORMERSCHEME transformationEngineType() const {return m_selectedTransformEngine;}
  void transformationEngineType(TRANSFORMERSCHEME engine) {m_selectedTransformEngine = engine;}
  Spectrum* powerSpectraEngine() const {return m_powSpectEngine;}

  /**
   * access generic class of objects
   */
  baseData* getData(FILETYPE ft);
  dataMap* getMap(ASSOCIATEDMAP mt);
  dataSpectrum* getGraph(ASSOCIATEDSPECTRUM st);
  void* getEngine(DATAENGINES de);

  /**
   * verify that a particular data set exists in the data chain
   */
  bool exists(FILETYPE ft);
  bool exists(ASSOCIATEDMAP mt);
  bool exists(ASSOCIATEDSPECTRUM st);
  bool exists(DATAENGINES de);

  /**
   * Track position in data chain
   */
  SEQUENCE maxDataSet(GENERICTYPE type);
  SEQUENCE maxDataChain(GENERICTYPE type);
  SEQUENCE sequenceStep() const {return m_sequence;}
  void sequenceStep(SEQUENCE completed) {m_sequence = completed;}

   /*
   * actions associated with moving through data chain
   */
  void addEngine(DATAENGINES de, ...);
  inputMatrixData* workSpace(double resRA, double resDec);
  inputMatrixData* workSpace(inputMatrixData *imd);
  void workSpaceTo(FILETYPE type, M_OP operation);

  void getResolution(FILETYPE dataType, double &RARes, double &decRes);
  void createEmptyDataSet(FILETYPE dataType, double RARes, double decRes);
  void createUniformSky(FILETYPE dataType, double level, M_OP operation);
  void createUniformPatch(FILETYPE dataType, double decMax, double decMin, double RAMin, double RAMax, double level, M_OP operation);
  void createDeltaFunction(FILETYPE dataType, double RAPeak, double decPeak, double level, M_OP operation);
  void createGaussian(FILETYPE dataType, double RAPeak, double decPeak, double width, double level, M_OP operation);
  void createCheckerboard(FILETYPE dataType, double RAStride, double decStride, double level, M_OP operation);
  void createHarmonic(FILETYPE dataType, int l, int m, double level, M_OP operation);
  void createShotNoise(vectorData<double>* vdd);
  void createWhiteNoise(vectorData<double>* vdd);

  void generatePixelData(Pixelizer *pixelizer, FILETYPE ft);
//  void updatePixelData();
  double pixelAverage() const {return m_pixelAverage;}
  double pixelVariance() const {return m_pixelVariance;}

  void generateMap(FILETYPE type);

  bool generateTransformedData(Transformer *transformer, FILETYPE ft);
  bool generatePowerSpectrumData(Spectrum *spect);

  bool generateGraph(FILETYPE type);

  bool generateInverseData(Transformer *transformer, FILETYPE ft);

  void addData(baseData *item);

  /**
   * reset data chain
   */
  void discardRelation(FILETYPE type);
  void reset();
  void reset(ALLTYPES id);
  void resetData();
  void resetMaps();
  void resetGraphs();
  void resetEngines();
  void resetSpectral();

  /**
   * progress function information
   */
//  progress* progressMonitor() {return m_progress;}
//  void progressMonitor(progress* monitor) {m_progress = monitor;}
//  void setProgressFunc(void* uiObject,void (*func)(void*,int)); // This is called by the GUI
//  void informProgress(double progress) { if(m_updateFunc) m_updateFunc(m_uiObject, progress);} //  This is called by data
//  void showProgress(bool show) { m_showProgress = show;}
//  bool  showProgress() const {return m_showProgress;}
//  void* userInterface() const {return m_uiObject;}
//  updateFx updateFunction() const {return m_updateFunc;}

  ERRORCODES  errorValue() const {return m_error;}
  void errorValue(ERRORCODES errNo) {m_error = errNo;}
  std::string errorDetails() const {return m_errorDescription;}
  std::string errorDetails(int errNo) const {return errorText[abs(errNo)];}
  void errorDetails(std::string errMsg) {m_errorDescription = errMsg;}

  std::string dataNames(int id) const {return dataTypeNames[id];}

private:
  void addEmpty(FILETYPE type, int x, int y = 1, int z = 1);
  void matrixTransfer(matrixData<double>* from, matrixData<double>* to, M_OP operation);
  dataMap* configureMap(FILETYPE type);
  dataSpectrum* configureGraph(FILETYPE type);

  bool                             m_showProgress;
  void*                            m_uiObject;
  updateFx                         m_updateFunc;
  progress                         *m_progress;

  double                           m_pixelAverage;
  double                           m_pixelVariance;

  inputMatrixData                  *m_workSpace;
  inputMatrixData                  *m_tmpSpace;

  matrixData<double>               *m_inputData;
  vectorData<double>               *m_pixelData;
  vectorData<double>               *m_transData;
  cubeData<std::complex<double> >  *m_almData;
  vectorData<double>               *m_invData;

  matrixData<double>               *m_inputWeights;
  vectorData<double>               *m_pixelWeights;
  vectorData<double>               *m_transWeights;
  cubeData<std::complex<double> >  *m_almWeights;
  vectorData<double>               *m_invWeights;

  matrixData<double>               *m_inputFilter;
  vectorData<double>               *m_pixelFilter;
  vectorData<double>               *m_transFilter;
  cubeData<std::complex<double> >  *m_almFilter;
  vectorData<double>               *m_invFilter;

  matrixData<double>               *m_inputNoise;
  vectorData<double>               *m_pixelNoise;
  vectorData<double>               *m_transNoise;
  cubeData<std::complex<double> >  *m_almNoise;
  vectorData<double>               *m_invNoise;

  matrixData<double>               *m_inputBeam;
  vectorData<double>               *m_pixelBeam;
  vectorData<double>               *m_transBeam;
  cubeData<std::complex<double> >  *m_almBeam;
  vectorData<double>               *m_invBeam;

  vectorData<int>                  *m_pixelOccupancy;
  matrixData<double>               *m_couplingMatrix;
  matrixData<double>               *m_inverseMatrix;
  vectorData<double>               *m_spectData;
  vectorData<double>               *m_ensembleSpectData;
  
  dataMap                          *m_inputDataMap;
  dataMap                          *m_inputWeightsMap;
  dataMap                          *m_inputMap;
  dataMap                          *m_inputNoiseMap;
  dataMap                          *m_inputFilterMap;
  dataMap                          *m_inputBeamMap;
  
  dataMap                          *m_pixelDataMap;
  dataMap                          *m_pixelWeightsMap;
  dataMap                          *m_pixelMap;
  dataMap                          *m_pixelOccupancyMap;
  dataMap                          *m_pixelNoiseMap;
  dataMap                          *m_pixelFilterMap;
  dataMap                          *m_pixelBeamMap;
  
  dataMap                          *m_invDataMap;
  dataMap                          *m_invWeightsMap;
  dataMap                          *m_invMap;
  dataMap                          *m_invNoiseMap;
  dataMap                          *m_invFilterMap;
  dataMap                          *m_invBeamMap;
  
  dataSpectrum                     *m_transDataGraph;
  dataSpectrum                     *m_transWeightsGraph;
  dataSpectrum                     *m_transGraph;
  dataSpectrum                     *m_spectDataGraph;
  dataSpectrum                     *m_ensembleDataGraph;
  dataSpectrum                     *m_transFilterGraph;
  dataSpectrum                     *m_transNoiseGraph;
  dataSpectrum                     *m_transBeamGraph;

  fileManager                      *m_fileIOEngine;
  Mapper                           *m_mapEngine;
  Grapher                          *m_graphEngine;
  Pixelizer                        *m_pixelEngine;
  Transformer                      *m_transformEngine;
  Spectrum                         *m_powSpectEngine;

  SEQUENCE                         m_sequence;
  FORMAT                           m_selectedIOEngine;
  MAPTYPE                          m_selectedMapEngine;
  PIXELSCHEME                      m_selectedPixelEngine;
  TRANSFORMERSCHEME                m_selectedTransformEngine;


//  std::map<ALLTYPES, std::string>  m_allTypes;
  ERRORCODES                       m_error;
  std::string                      m_errorDescription;
};

#endif
