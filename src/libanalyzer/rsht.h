/****************************************************************************
                              \rsht.h
Description:\brief (put short description here)

Begin    : Wed Jun 8 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#ifndef _RSHT_H_
#define _RSHT_H_

#include <healpix_cxx/healpix_map.h>
#include <healpix_cxx/alm.h>
#include <healpix_cxx/xcomplex.h>
#include <healpix_cxx/powspec.h>

#include "atypes.h"
#include "transformer.h"
#include "association.h"

typedef xcomplex<double> hPoint;

class RshtTransformer : public Transformer {

  public:
     RshtTransformer();
     RshtTransformer(RshtTransformer* from);
     ~RshtTransformer();

    /**
     * initialize storage arrays
     */
    int initialize(association* dataClasses, FILETYPE type);
    int initialize(association* dataClasses);

    /**
     * load pixelized data into data map
     */
    int loadMap(association* dataClasses, FILETYPE type);

    /**
     * translate alm arrays between native and HealPix formats
     */
    int loadAlmMap(association* dataClasses, FILETYPE type);
    int storeAlmMap(association* dataClasses, FILETYPE type);

    /**
     * transform data
     */
    void transform(association* dataClasses, FILETYPE type);

    /**
     * perform inverse transformation on data
     */
    void invert(association* dataClasses, FILETYPE type);

    /**
     * clear the transformed arrays
     */
    void clearData(association* dataclasses, FILETYPE ft = fileType::Null);
    void clearAlms();
    void clearMaps();
    void clearArrays(association* dataClasses);
    void clear(association* dataClasses);

    /**
     * access elements for copy constructor
     */
    std::string name() {return m_name;}
    int sides() {return m_sides;}
    double cosThetaCut() {return m_cosThetaCut;}
//    association* association() {return m_association;}
    Healpix_Map<double>* dataMap() {return m_dataMap;}
    Healpix_Map<double>* weightsMap() {return m_weightsMap;}
    Healpix_Map<double>* map() {return m_map;}
    Healpix_Map<double>* filterMap() {return m_filterMap;}
    Healpix_Map<double>* beamMap() {return m_beamMap;}
    Healpix_Map<double>* noiseMap() {return m_noiseMap;}
    Healpix_Map<double>* invDataMap() {return m_invDataMap;}
    Healpix_Map<double>* invMaskMap() {return m_invMaskMap;}
    Healpix_Map<double>* invFilterMap() {return m_invFilterMap;}
    Healpix_Map<double>* invBeamMap() {return m_invBeamMap;}
    Healpix_Map<double>* invNoiseMap() {return m_invNoiseMap;}
    Alm<hPoint>* almDataValue() {return m_almDataValue;}
    Alm<hPoint>* almDataGrad() {return m_almDataGrad;}
    Alm<hPoint>* almDataCurl() {return m_almDataCurl;}
    Alm<hPoint>* almWeightsValue() {return m_almWeightsValue;}
    Alm<hPoint>* almWeightsGrad() {return m_almWeightsGrad;}
    Alm<hPoint>* almWeightsCurl() {return m_almWeightsCurl;}
    Alm<hPoint>* almValue() {return m_almValue;}
    Alm<hPoint>* almGrad() {return m_almGrad;}
    Alm<hPoint>* almCurl() {return m_almCurl;}
    Alm<hPoint>* almFilterValue() {return m_almFilterValue;}
    Alm<hPoint>* almFilterGrad() {return m_almFilterGrad;}
    Alm<hPoint>* almFilterCurl() {return m_almFilterCurl;}
    Alm<hPoint>* almBeamValue() {return m_almBeamValue;}
    Alm<hPoint>* almBeamGrad() {return m_almBeamGrad;}
    Alm<hPoint>* almBeamCurl() {return m_almBeamCurl;}
    Alm<hPoint>* almNoiseValue() {return m_almNoiseValue;}
    Alm<hPoint>* almNoiseGrad() {return m_almNoiseGrad;}
    Alm<hPoint>* almNoiseCurl() {return m_almNoiseCurl;}
    PowSpec* spectrum() {return m_spectrum;}

    void sides(int sides){m_sides = sides;}

  private:
    std::string          m_name;
    int                  m_sides;
    double               m_cosThetaCut;
//    association         *m_association;
    Healpix_Map<double> *m_dataMap;
    Healpix_Map<double> *m_weightsMap;
    Healpix_Map<double> *m_map;
    Healpix_Map<double> *m_filterMap;
    Healpix_Map<double> *m_beamMap;
    Healpix_Map<double> *m_noiseMap;
    Healpix_Map<double> *m_invDataMap;
    Healpix_Map<double> *m_invMaskMap;
    Healpix_Map<double> *m_invFilterMap;
    Healpix_Map<double> *m_invBeamMap;
    Healpix_Map<double> *m_invNoiseMap;
    Alm<hPoint>         *m_almDataValue;
    Alm<hPoint>         *m_almDataGrad;
    Alm<hPoint>         *m_almDataCurl;
    Alm<hPoint>         *m_almWeightsValue;
    Alm<hPoint>         *m_almWeightsGrad;
    Alm<hPoint>         *m_almWeightsCurl;
    Alm<hPoint>         *m_almValue;
    Alm<hPoint>         *m_almGrad;
    Alm<hPoint>         *m_almCurl;
    Alm<hPoint>         *m_almFilterValue;
    Alm<hPoint>         *m_almFilterGrad;
    Alm<hPoint>         *m_almFilterCurl;
    Alm<hPoint>         *m_almBeamValue;
    Alm<hPoint>         *m_almBeamGrad;
    Alm<hPoint>         *m_almBeamCurl;
    Alm<hPoint>         *m_almNoiseValue;
    Alm<hPoint>         *m_almNoiseGrad;
    Alm<hPoint>         *m_almNoiseCurl;
    PowSpec             *m_spectrum;
};

#endif
