/****************************************************************************
                              \spectrum.h
Description:\brief (put short description here)

Begin    : Fri Jul 1 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#ifndef _SPECTRUM_H_
#define _SPECTRUM_H_

#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>
#include <healpix_cxx/powspec.h>
#include "matrixdata.h"
#include "vectordata.h"
#include "association.h"

class Spectrum {
  public:
    Spectrum();
    Spectrum(Spectrum* from);
    ~Spectrum();

  public:
    /**
     * flag for determining if spectrum is configured
     */
    bool configured() {return m_configured;}
    void configured(bool flag) {m_configured = flag;}

    /**
     * flag for determining if spectrum is active
     */
    bool active() {return m_active;}
    void active(bool flag) {m_active = flag;}

    /**
     * flag for determining if spectrum stops at inverting coupling matrix or not
     */
    bool computeInverse() {return m_invert;}
    void computeInverse(bool flag) {m_invert = flag;}

    /**
     * access whether data is to be binned or not
     */
    bool binning() {return m_binning;}
    void binning(bool flag) {m_binning = flag;}

    /**
     * access number of indices per bin
     */
    int indices() {return m_indices;}
    void indices(int value) {m_indices = value;}

    /**
     * access index mask
     */
    int maskIndex() {return m_maskIndex;}
    void maskIndex(int value) {m_maskIndex = value;}

    /**
     * access invert flag
     */
    bool invert() {return m_invert;}
    void invert(bool flag) {m_invert = flag;}

    /**
     * access whether data is to be weighted or not
     */
    bool weight() {return m_weight;}
    void weight(bool flag) {m_weight = flag;}

    /**
     * power spectrum minimum and maximum index values
     */
    int minIndex() {return m_minIndex;}
    void minIndex(int value) {m_minIndex = value;}
    int maxIndex() {return m_maxIndex;}
    void maxIndex(int value) {m_maxIndex = value;}

    /**
     * power spectrum minimum and maximum bin indices
     */
    int minBin() {return m_minBin;}
    void minBin(int value) {m_minBin = value;}
    int maxBin() {return m_maxBin;}
    void maxBin(int value) {m_maxBin = value;}

    /**
     * bin to index and index to bin lowest l value
     */
    int lowBinL() {return m_lowBinL;}
    void lowBinL(int value) {m_lowBinL = value;}

    /**
     * initialize the arrays
     */
    void initialize();

    /**
     * calculate mode-mode coupling matrix
     */
    void loadCouplingMatrix(association *asc);
    void createModeCouplingMatrix(association *asc);

    /**
     * calculate bin-index conversion matrix
     */
    void calculateBinIndexMatrix(long binOffset,long indexOffset,long binRecords = 1,long indexRecords = 1);

    /**
     * calculate index-bin conversion matrix
     */
    void calculateIndexBinMatrix(long binOffset,long indexOffset,long binRecords = 1,long indexRecords = 1);

    /**
     * calculate bin-bin coupling matrix
     */
    void calculateBinCouplingMatrix(association *asc);

    /**
     * invert coupling matrix
     */
    void loadInverseMatrix(association *asc);
    int invertMatrix(association *asc);

    /**
     * calculate power spectrum
     */
    void calculateSpectrum(association* asc);

    /**
     * calculate the ensemble average
     */
    void calculateEnsembleAverage(association *asc, int size);

    /**
     * clear the spectrum object
     */
    void clear();

  private:
    /**
     * math routines for calculating the wigner 3-j coefficients until gsl routines are fixed
     */
    double gammln(double xx);
    double factln(int n);
    double coupling_3j(int l1,int l2,int l3);

  private:
    bool          m_configured;
    bool          m_active;
    bool          m_binning;
    bool          m_weight;
    bool          m_invert;
    int           m_maskIndex;
    int           m_indices;
    int           m_minIndex;
    int           m_maxIndex;
    int           m_minBin;
    int           m_maxBin;
    int           m_lowBinL;
    gsl_matrix   *m_mode_modeMatrix;
    gsl_matrix   *m_bin_binMatrix;
    gsl_matrix   *m_bin_indexMatrix;
    gsl_matrix   *m_index_binMatrix;
    gsl_matrix   *m_inverseModeMatrix;
    gsl_matrix   *m_inverseBinMatrix;
    PowSpec      *m_healPIXPowerSpectrum;
};

#endif
