/****************************************************************************
                              \healpix.cpp
Description:\brief (put short description here)

Begin    : Mon Jun 6 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#include <math.h>
#include <stdio.h>
#include <istream>
#include <fstream>
#include <healpix_cxx/healpix_base.h>
#include <healpix_cxx/alm_healpix_tools.h>
// extern "C" {
// #include <chealpix.h>
// }

#include "basedata.h"
#include "inputmatrixdata.h"
#include "healpix.h"

HealPIXPixelizer::HealPIXPixelizer()
                : Pixelizer() {
  m_name = "HealPIX";
  m_scheme = HealPIX;
  m_sides = 1;
  m_layout = Ring;
//  m_maxSides = 1024;
  m_pixels = 12 * m_sides * m_sides;
  m_scratch = 0;
}

HealPIXPixelizer::HealPIXPixelizer(HealPIXPixelizer* from)
                : Pixelizer((Pixelizer*) from) {
  m_name     = from->name();
  m_scheme   = from->pixelizerScheme();
  m_sides    = from->scale();
  m_layout   = from->pixelLayout();
//  m_maxSides = from->maxScale();
  m_pixels   = 12 * m_sides * m_sides;
  m_scratch  = 0;
}

HealPIXPixelizer::~HealPIXPixelizer() {
  if (m_scratch)
    delete m_scratch;
}

void HealPIXPixelizer::initialize() {
  bool initialize = true;
  m_pixels = 12 * m_sides * m_sides; // total number of pixels in HealPix scheme
}

int HealPIXPixelizer::pixelize(association* dataClasses, long x, long y, int range, FILETYPE type) {
  int count = 0;
  int pixelNumber = 0;
  double phi = 0, theta = 0;
  double angle2rads = M_PI / 180.0;
  double maxValue = 0.0, minValue = 0.0;
  int maxCount = 0, minCount = 0;
  matrixData<double> *input = 0;
  vectorData<double> *pixout = 0;
  vectorData<int>* pixOccupancy = 0;

  /* Do input variable checks */
  if (type == fileType::Null)
    return 0;

  if (!dataClasses)
    return 0;

  switch (type) {
    case fileType::InputData:
      input = dataClasses->inputData();
      pixout = dataClasses->pixelizedData();
      pixOccupancy = dataClasses->pixelOccupancy();
      break;
    case fileType::InputWeights:
      input = dataClasses->inputWeights();
      pixout = dataClasses->pixelizedWeights();
      break;
    case fileType::InputFilter:
      input = dataClasses->inputFilter();
      pixout = dataClasses->pixelizedFilter();
      break;
    case fileType::InputBeam:
      input = dataClasses->inputBeam();
      pixout = dataClasses->pixelizedBeam();
      break;
    case fileType::InputNoise:
      input = dataClasses->inputNoise();
      pixout = dataClasses->pixelizedNoise();
      break;
    default:
      return 0;
  }

  if (range <= 0)
    range = input->size();
  

  // translate to healpix structure and get pixel number
  Healpix_Base* healpix = new Healpix_Base();
  healpix->SetNside((const int)m_sides,(Healpix_Ordering_Scheme)(m_layout-1));
  long i = x, j = y;
  for (count = 0;count < range;++count) {
    // update progress bar
//    dataClasses->informProgress((double)count / (double)range);
    
    if ((*input)[i][j] > 0) {
      input->bin2angle(i,j,theta,phi);  // convert bin coordinates to angular coordinates
      theta = (90.0 - theta) * angle2rads; // convert theta to 0-180 range and then to radians
//      if (phi < 0.0)
//        phi += 180.0;
//      if (phi > 360.0)
//        phi -= 180.0;
      phi *= angle2rads; // convert phi to radians
      pixelNumber = healpix->ang2pix(pointing(theta,phi));
      (*pixout)[pixelNumber] += (*input)[i][j];
      if (type == fileType::InputData) {
        (*pixOccupancy)[pixelNumber]++;
        if ((*pixOccupancy)[pixelNumber] > maxCount)
          maxCount = (*pixOccupancy)[pixelNumber];
        if ((*pixOccupancy)[pixelNumber] < minCount)
          minCount = (*pixOccupancy)[pixelNumber];
      }
      if ((*pixout)[pixelNumber] > maxValue)
        maxValue = (*pixout)[pixelNumber];
      if ((*pixout)[pixelNumber] < minValue)
        minValue = (*pixout)[pixelNumber];
    }
    ++j;
    if (j == input->rows()) {
      ++i;
      j = 0;
    }
  }

  // check min and max value for pixel data vector
  if (pixout->maxValue() != maxValue)
    pixout->maxValue(maxValue);
  if (pixout->minValue() != minValue)
    pixout->minValue(minValue);
  // check sides and min/max indices for pixel data vector
  if (pixout->sides() != m_sides)
    pixout->sides(m_sides);
  if (pixout->minYIndex() != 0);
    pixout->minYIndex(0);
  int pixCount = 12 * m_sides * m_sides;
  if (m_pixels != pixCount)
    m_pixels = pixCount;
  if (pixout->maxYIndex() != m_pixels)
    pixout->maxYIndex(m_pixels);

  // repeat for pixel occuplancy vector
  if (pixOccupancy) {
    if (pixOccupancy->maxValue() != maxValue)
      pixOccupancy->maxValue(maxValue);
    if (pixOccupancy->minValue() != minValue)
      pixOccupancy->minValue(minValue);
    // check sides and min/max indices for pixel data vector
    if (pixOccupancy->sides() != m_sides)
      pixOccupancy->sides(m_sides);
    if (pixOccupancy->minYIndex() != 0);
      pixOccupancy->minYIndex(0);
    if (pixOccupancy->maxYIndex() != m_pixels)
      pixOccupancy->maxYIndex(m_pixels);
  }

  return (count);
}

double HealPIXPixelizer::calculateAverage(FILETYPE dataType, association* assoc) {
  double globalAve = 0.0;
  int numberDataPoints = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;
  vectorData<double> *weights = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;
  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam) {
    if (assoc->exists(fileType::PixelizedWeights))
      weights = new vectorData<double>(assoc->pixelizedWeights());
    switch (dataType) {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = new vectorData<double>(assoc->pixelizedData());
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = new vectorData<double>(assoc->pixelizedWeights());
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = new vectorData<double>(assoc->pixelizedNoise());
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = new vectorData<double>(assoc->pixelizedFilter());
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = new vectorData<double>(assoc->pixelizedBeam());
        break;
    }
  }
  else
    throw incompleteDatasetError;

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && (data || weights)))
      throw incompleteDatasetError;
    if (data->rows() != weights->rows() || data->rows() != hits->rows() || weights->rows() != hits->rows())
      throw dataMismatchError;
  }
  else {
    if (!(hits && weights))
      throw incompleteDatasetError;
    if (weights->rows() != hits->rows())
      throw dataMismatchError;
  }

  // In general, calculate average by summing the (weighted) data and number of data points across all pixels
  // then the two. Have to treat the occupancy average different, however, as that would be the sum of the occupancy
  // divided by the number of pixels
  long nPixels = hits->rows();
  for (int row = 0;row < nPixels;++row) {
    if (dataType == fileType::PixelOccupancy && weights)
      numberDataPoints += (*hits)[row] * (*weights)[row];
    else {
      numberDataPoints += (*hits)[row];
      if(data) {
        if(weights)
          globalAve += (*data)[row] * (*weights)[row];
        else
          globalAve += (*data)[row];
      }
      else if (weights)
        globalAve += (*weights)[row];
      else
        throw incompleteDatasetError;
    }
  }

  if (dataType == fileType::PixelOccupancy)
    globalAve = numberDataPoints / nPixels;
  else
    globalAve /= numberDataPoints;

  if (data)
    delete data;
  if (weights)
    delete weights;
  return globalAve;
}

double HealPIXPixelizer::calculateVariance(FILETYPE dataType, association* assoc) {
  double variance = 0.0;
  int totalHits = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;
  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam) {
    switch (dataType) {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = assoc->pixelizedData();
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = assoc->pixelizedWeights();
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = assoc->pixelizedNoise();
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = assoc->pixelizedFilter();
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = assoc->pixelizedBeam();
        break;
    }
  }
  else
    throw incompleteDatasetError;

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && data))
      throw incompleteDatasetError;
    if (data->rows() != hits->rows())
      throw dataMismatchError;
  }
  else
    if (!hits)
      throw incompleteDatasetError;

  // calculate variance as the sum of the squared difference between the value in the pixel and the average,
  // then divide the sum by either the total number of pixels (pixelOccupancy) or data points (all others), minus 1
  long nPixels = hits->rows();
  double average = calculateAverage(dataType, assoc);
  for (int row = 0;row < nPixels;++row) {
    if (dataType == fileType::PixelOccupancy)
      variance += ((*hits)[row] - average) * ((*hits)[row] - average);
    else {
      variance += ((*data)[row] - average) * ((*data)[row] - average);
      totalHits += (*hits)[row];
    }
  }
  if (dataType == fileType::PixelOccupancy)
    variance /= nPixels - 1;
  else
    variance /= totalHits - 1;

  return variance;
}

baseData* HealPIXPixelizer::calculateAverageVector(FILETYPE dataType, association* assoc) {
  vectorData<double>* dataAverage = 0;
  vectorData<int>* occAverage = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;
  vectorData<double> *weights = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;
  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam) {
    if (assoc->exists(fileType::PixelizedWeights))
      weights = new vectorData<double>(assoc->pixelizedWeights());
    switch (dataType) {
      case fileType::PixelizedData:
        if (assoc->exists(fileType::PixelizedData))
          data = new vectorData<double>(assoc->pixelizedData());
        break;
      case fileType::PixelizedWeights:
        if (assoc->exists(fileType::PixelizedWeights))
          data = new vectorData<double>(assoc->pixelizedWeights());
        break;
      case fileType::PixelizedNoise:
        if (assoc->exists(fileType::PixelizedNoise))
          data = new vectorData<double>(assoc->pixelizedNoise());
        break;
      case fileType::PixelizedFilter:
        if (assoc->exists(fileType::PixelizedFilter))
          data = new vectorData<double>(assoc->pixelizedFilter());
        break;
      case fileType::PixelizedBeam:
        if (assoc->exists(fileType::PixelizedBeam))
          data = new vectorData<double>(assoc->pixelizedBeam());
        break;
    }
  }
  else
    throw incompleteDatasetError;

  if (dataType == fileType::PixelOccupancy)
    occAverage = new vectorData<int>(hits->rows());
  else
    dataAverage = new vectorData<double>(hits->rows());

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && (data || weights)))
      throw incompleteDatasetError;
    if (data->rows() != weights->rows() || data->rows() != hits->rows() || weights->rows() != hits->rows())
      throw dataMismatchError;
  }
  else {
    if (!(hits && weights))
      throw incompleteDatasetError;
    if (weights->rows() != hits->rows())
      throw dataMismatchError;
  }

  // In general, calculate average by dividing the (weighted) data and number of data points per pixel
  // then the two. Have to treat the occupancy average different, however, as that would be the sum of the occupancy
  // divided by the number of pixels
  long nPixels = hits->rows();
  for (int row = 0;row < nPixels;++row) {
    if (dataType == fileType::PixelOccupancy) {
      if (weights)
        (*occAverage)[row] += (*hits)[row] * (*weights)[row];
      else
        (*occAverage)[row] += (*hits)[row];
    }
    else {
      if(data) {
        if(weights)
          (*dataAverage)[row] += (*data)[row] * (*weights)[row];
        else
          (*dataAverage)[row] += (*data)[row];
      }
      else if (weights)
        (*dataAverage)[row] += (*weights)[row];
      else
        throw incompleteDatasetError;
    }
  }

  if (dataType == fileType::PixelOccupancy)
    return (baseData*)occAverage;
  else
    return (baseData*)dataAverage;
}

baseData* HealPIXPixelizer::calculateVarianceVector(FILETYPE dataType, association* assoc) {
  vectorData<double>* dataVariance = 0;
  vectorData<int>* occVariance = 0;
  vectorData<int> *hits = 0;
  vectorData<double> *data = 0;

  // load requisite data sets
  if (assoc->exists(fileType::PixelOccupancy))
    hits = assoc->pixelOccupancy();
  else
    throw incompleteDatasetError;
  if (dataType >= fileType::PixelizedData && dataType <= fileType::PixelizedBeam) {
    switch (dataType) {
     case fileType::PixelizedData:
       if (assoc->exists(fileType::PixelizedData))
         data = assoc->pixelizedData();
       break;
     case fileType::PixelizedWeights:
       if (assoc->exists(fileType::PixelizedWeights))
         data = assoc->pixelizedWeights();
       break;
     case fileType::PixelizedNoise:
       if (assoc->exists(fileType::PixelizedNoise))
         data = assoc->pixelizedNoise();
       break;
     case fileType::PixelizedFilter:
       if (assoc->exists(fileType::PixelizedFilter))
         data = assoc->pixelizedFilter();
       break;
     case fileType::PixelizedBeam:
       if (assoc->exists(fileType::PixelizedBeam))
         data = assoc->pixelizedBeam();
       break;
    }
  }

  // check to make sure everything loaded correctly
  if (dataType != fileType::PixelOccupancy) {
    if (!(hits && data))
      throw incompleteDatasetError;
    if (data->rows() != hits->rows())
      throw dataMismatchError;
  }
  else
    if (!hits)
      throw incompleteDatasetError;

  // calculate variance as the sum of the squared difference between the value in the pixel and the average,
  // then divide the sum by either the total number of pixels (pixelOccupancy) or data points (all others), minus 1
  long nPixels = hits->rows();
  double average = calculateAverage(dataType, assoc);
  for (int row = 0;row < nPixels;++row) {
    if (dataType == fileType::PixelOccupancy)
      (*occVariance)[row] = ((*hits)[row] - average) * ((*hits)[row] - average) / nPixels - 1;
    else
      (*dataVariance)[row] += ((*data)[row] - average) * ((*data)[row] - average) / (*hits)[row] - 1;
  }

  if (dataType == fileType::PixelOccupancy)
    return (baseData*)occVariance;
  else
    return (baseData*)dataVariance;
}

double HealPIXPixelizer::resolution(int sides) {
  double result = 360.0 / (sides * sqrt(12.0*M_PI));
  return(result);
}

int HealPIXPixelizer::psuedoSides(double resolution) {
  int result = (int)(360.0 / (resolution * sqrt(12.0*M_PI)));
  return result;
}

double HealPIXPixelizer::pixelArea(bool radFlag) {
      double area = 4 * M_PI / (12 * m_sides * m_sides);
      if (radFlag)
        return area;
      else
        return area * (M_PI / 180.0) * (M_PI / 180.0);
}

