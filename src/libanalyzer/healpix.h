/****************************************************************************
                              \healpix.h
Description:\brief (put short description here)

Begin    : Mon Jun 6 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M 
University-Kingsville by Daniel Suson
***************************************************************************/
#ifndef _HEALPIX_H_
#define _HEALPIX_H_

#include <string>

#include "atypes.h"
#include "association.h"
#include "pixelizer.h"

class HealPIXPixelizer : public Pixelizer {
  public:
    HealPIXPixelizer();
    HealPIXPixelizer(HealPIXPixelizer* from);
    ~HealPIXPixelizer();

  public:
    // define inherited methods first
    /**
     * Get the class name
     */
    std::string name() const {return m_name;}

    /**
     * create pixel vector and load data into it
     */
    int pixelize(association* dataClasses, long x = 0, long y = 0, int range = 0, FILETYPE type = fileType::Null);

    /**
     * initialize pixel arrays
     */
    void initialize();

    /**
     * suggest optimum pixel sides
     */
    int optimize(int points, association* dataClasses) {return 0;}

    /**
     * Access the number of pixel sides
     */
    int scale() const {return m_sides;}
    void scale(int number) {m_sides = number;}

    /**
     * Access number of pixels
     */
    int pixels() const {return m_pixels;}

    // define HealPIX specific methods
    /**
     * Access the pixel layout
     */
    LAYOUT pixelLayout() const {return m_layout;}
    void pixelLayout(LAYOUT type) {m_layout = type;}

    /**
     * average the data across all pixels
     */
    double calculateAverage(FILETYPE dataType, association* assoc);

    /**
     * calculate variance of data across all pixels
     */
    double calculateVariance(FILETYPE dataType, association* assoc);

    /**
     * calculate the average vector
     */
    baseData* calculateAverageVector(FILETYPE dataType, association* assoc);

    /**
     *  calculate the variance vector
     */
    baseData* calculateVarianceVector(FILETYPE dataType, association* assoc);

    /**
     * Calculate the area of a single pixel
     */
    double pixelArea(bool radFlag=true);

    /**
     * calculate total area of map
     */
    double calculateArea(bool radFlag=true) {return pixelArea(radFlag)*m_pixels;}

    /**
     * calculate resolution given a base side number
     */
    double resolution(int sides);

    /**
     * calculate the number of sides given a resolution
     */
    int psuedoSides(double resolution);

  private:

    std::string          m_name;       // class name
    int                  m_sides;      // number of pixel sides on which the pixelization is based
    int                  m_pixels;     // total number of pixels
//    int                  m_maxSides;   // maximum number of pixel sides
    LAYOUT               m_layout;     // flag indicating how pixels are numbered
    std::vector<double>* m_scratch;    // array used for optimizations
//    bool                 m_aveFlag;    // flag for using averages
//    bool                 m_varFlag;    //flag for using variances
};

#endif
