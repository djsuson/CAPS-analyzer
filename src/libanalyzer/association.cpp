/***************************************************************************
 *   association.cpp                                                       *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * The association class collects all of the various data objects together *
 * for easy checking of the data chain as well as the associated action    *
 * engines for generating additional steps.                                *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <cstdarg>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>

#include "atypes.h"
#include "association.h"
#include "vectordata.h"
#include "matrixdata.h"
#include "inputmatrixdata.h"
#include "cubedata.h"
#include "pixelizer.h"
#include "healpix.h"
#include "transformer.h"
#include "rsht.h"
#include "spectrum.h"
#include "filemanager.h"
#include "fitsmanager.h"
#include "csvmanager.h"
#include "../libgraphics/dataspectrum.h"
#include "../libgraphics/datamap.h"
#include "../libgraphics/mapper.h"
#include "../libgraphics/mollweide.h"
#include "../libgraphics/grapher.h"

association::association() {
  m_uiObject = 0;
  m_updateFunc = 0;
  m_showProgress = false;

  m_pixelAverage = 0;
  m_pixelVariance = 0;

  m_workSpace = 0;
  m_tmpSpace = 0;
  m_inputData = 0;
  m_inputWeights = 0;
  m_inputFilter = 0;
  m_inputBeam = 0;
  m_inputNoise = 0;
  m_pixelData = 0;
  m_pixelWeights = 0;
  m_pixelOccupancy = 0;
  m_pixelFilter = 0;
  m_pixelBeam = 0;
  m_pixelNoise = 0;
  m_invData = 0;
  m_invWeights = 0;
  m_invFilter = 0;
  m_invBeam = 0;
  m_invNoise = 0;
  m_transData = 0;
  m_transWeights = 0;
  m_transFilter = 0;
  m_transNoise = 0;
  m_transBeam = 0;
  m_spectData = 0;
  m_ensembleSpectData = 0;
  m_almData = 0;
  m_almWeights = 0;
  m_almFilter = 0;
  m_almBeam = 0;
  m_almNoise = 0;
  m_couplingMatrix = 0;
  m_inverseMatrix = 0;
  
  m_inputDataMap = 0;
  m_inputWeightsMap = 0;
  m_inputMap = 0;
  m_inputNoiseMap = 0;
  m_inputFilterMap = 0;
  m_inputBeamMap = 0;
  m_pixelDataMap = 0;
  m_pixelWeightsMap = 0;
  m_pixelMap = 0;
  m_pixelOccupancyMap = 0;
  m_pixelNoiseMap = 0;
  m_pixelFilterMap = 0;
  m_pixelBeamMap = 0;
  m_invDataMap = 0;
  m_invWeightsMap = 0;
  m_invMap = 0;
  m_invNoiseMap = 0;
  m_invFilterMap = 0;
  m_invBeamMap = 0;
  
  m_transDataGraph = 0;
  m_transWeightsGraph = 0;
  m_transGraph = 0;
  m_spectDataGraph = 0;
  m_ensembleDataGraph = 0;
  m_transFilterGraph = 0;
  m_transNoiseGraph = 0;
  m_transBeamGraph = 0;

  m_fileIOEngine = 0;
  m_mapEngine = 0;
  m_graphEngine = 0;
  m_pixelEngine = 0;
  m_transformEngine = 0;
  m_powSpectEngine = 0;

  m_selectedIOEngine = None;
  m_selectedMapEngine = Blank;
  m_selectedPixelEngine = NotPixelized;
  m_selectedTransformEngine = NotTransformed;
  m_sequence = noSky;
}

association::association(association* from) {
  m_inputData         = new matrixData<double>(from->inputData());
  m_inputWeights      = new matrixData<double>(from->inputWeights());
  m_inputFilter       = new matrixData<double>(from->inputFilter());
  m_inputNoise        = new matrixData<double>(from->inputNoise());
  m_inputBeam         = new matrixData<double>(from->inputBeam());
  m_pixelData         = new vectorData<double>(from->pixelizedData());
  m_pixelWeights      = new vectorData<double>(from->pixelizedWeights());
  m_pixelOccupancy    = new vectorData<int>(from->pixelOccupancy());
  m_pixelFilter       = new vectorData<double>(from->pixelizedFilter());
  m_pixelNoise        = new vectorData<double>(from->pixelizedNoise());
  m_pixelBeam         = new vectorData<double>(from->pixelizedBeam());
  m_invData           = new vectorData<double>(from->inverseData());
  m_invWeights        = new vectorData<double>(from->inverseWeights());
  m_invNoise          = new vectorData<double>(from->inverseNoise());
  m_invFilter         = new vectorData<double>(from->inverseFilter());
  m_invBeam           = new vectorData<double>(from->inverseBeam());
  m_transData         = new vectorData<double>(from->transformedData());
  m_transWeights      = new vectorData<double>(from->transformedWeights());
  m_transFilter       = new vectorData<double>(from->transformedFilter());
  m_transNoise        = new vectorData<double>(from->transformedNoise());
  m_transBeam         = new vectorData<double>(from->transformedBeam());
  m_spectData         = new vectorData<double>(from->spectrumData());
  m_ensembleSpectData = new vectorData<double>(from->ensembleData());
  m_couplingMatrix  = new matrixData<double>(from->couplingMatrix());
  m_inverseMatrix   = new matrixData<double>(from->inverseMatrix());
  m_almData         = new cubeData<std::complex<double> >(from->almData());
  m_almWeights      = new cubeData<std::complex<double> >(from->almWeights());
  m_almNoise        = new cubeData<std::complex<double> >(from->almNoise());
  m_almFilter       = new cubeData<std::complex<double> >(from->almFilter());
  m_almBeam         = new cubeData<std::complex<double> >(from->almBeam());
  
  m_inputDataMap      = new dataMap(from->inputDataMap());
  m_inputWeightsMap   = new dataMap(from->inputWeightsMap());
  m_inputMap          = new dataMap(from->inputMap());
  m_pixelDataMap      = new dataMap(from->pixelDataMap());
  m_pixelWeightsMap   = new dataMap(from->pixelWeightsMap());
  m_pixelMap          = new dataMap(from->pixelMap());
  m_pixelOccupancyMap = new dataMap(from->pixelOccupancyMap());
  m_invDataMap        = new dataMap(from->invDataMap());
  m_invWeightsMap     = new dataMap(from->invWeightsMap());
  m_invMap            = new dataMap(from->invMap());
  m_inputNoiseMap     = new dataMap(from->inputNoiseMap());
  m_inputFilterMap    = new dataMap(from->inputFilterMap());
  m_inputBeamMap      = new dataMap(from->inputBeamMap());
  m_pixelNoiseMap     = new dataMap(from->pixelNoiseMap());
  m_pixelFilterMap    = new dataMap(from->pixelFilterMap());
  m_pixelBeamMap      = new dataMap(from->pixelBeamMap());
  m_invNoiseMap       = new dataMap(from->invNoiseMap());
  m_invFilterMap      = new dataMap(from->invFilterMap());
  m_invBeamMap        = new dataMap(from->invBeamMap());
  
  m_transDataGraph     = new dataSpectrum(from->transDataGraph());
  m_transWeightsGraph  = new dataSpectrum(from->transWeightsGraph());
  m_transGraph         = new dataSpectrum(from->transGraph());
  m_spectDataGraph     = new dataSpectrum(from->spectrumGraph());
  m_ensembleDataGraph  = new dataSpectrum(from->ensembleGraph());
  m_transFilterGraph   = new dataSpectrum(from->transFilterGraph());
  m_transNoiseGraph    = new dataSpectrum(from->transNoiseGraph());
  m_transBeamGraph     = new dataSpectrum(from->transBeamGraph());

  m_selectedIOEngine        = from->fileIOEngineType();
  m_selectedMapEngine       = from->mappingEngineType();
  m_selectedPixelEngine     = from->pixelizationEngineType();
  m_selectedTransformEngine = from->transformationEngineType();
  m_sequence                = from->sequenceStep();

  if (from->fileIOEngine()->fileFormat() == CSV)
    m_fileIOEngine    = new csvManager((csvManager*)(from->fileIOEngine()));
  else if (from->fileIOEngine()->fileFormat() == Fits)
    m_fileIOEngine    = new fitsManager((fitsManager*)(from->fileIOEngine()));
  else
    m_fileIOEngine    = 0;
  if (from->mappingEngine()->layout() == Mollweide)
    m_mapEngine         = new MollweideMapper((MollweideMapper*)(from->mappingEngine()));
  else
    m_mapEngine         = 0;
  m_graphEngine = from->graphingEngine();
  if (from->pixelizationEngine()->pixelizerScheme() == HealPIX)
    m_pixelEngine      = new HealPIXPixelizer((HealPIXPixelizer*)(from->pixelizationEngine()));
  else
    m_pixelEngine      = 0;
  if (from->transformationEngine()->transformerScheme() == Rsht)
    m_transformEngine  = new RshtTransformer((RshtTransformer*)(from->transformationEngine()));
  else
    m_transformEngine  = 0;
  m_powSpectEngine     = new Spectrum(from->powerSpectraEngine());

//  m_uiObject     = from->userInterface();
//  m_updateFunc   = from->updateFunction();
//  m_showProgress = from->showProgress();
}

association& association::operator=(association& other) {
  *m_inputData         = *other.inputData();
  *m_inputWeights      = *other.inputWeights();
  *m_inputNoise        = *other.inputNoise();
  *m_inputFilter       = *other.inputFilter();
  *m_inputBeam         = *other.inputBeam();
  *m_pixelData         = *other.pixelizedData();
  *m_pixelWeights      = *other.pixelizedWeights();
  *m_pixelOccupancy    = *other.pixelOccupancy();
  *m_pixelFilter       = *other.pixelizedFilter();
  *m_pixelNoise        = *other.pixelizedNoise();
  *m_pixelBeam         = *other.pixelizedBeam();
  *m_invData           = *other.inverseData();
  *m_invWeights        = *other.inverseWeights();
  *m_invNoise          = *other.inverseNoise();
  *m_invFilter         = *other.inverseFilter();
  *m_invBeam           = *other.inverseBeam();
  *m_transData         = *other.transformedData();
  *m_transWeights      = *other.transformedWeights();
  *m_transFilter       = *other.transformedFilter();
  *m_transNoise        = *other.transformedNoise();
  *m_transBeam         = *other.transformedBeam();
  *m_spectData         = *other.spectrumData();
  *m_ensembleSpectData = *other.ensembleData();
  *m_couplingMatrix    = *other.couplingMatrix();
  *m_inverseMatrix     = *other.inverseMatrix();
  *m_almData           = *other.almData();
  *m_almWeights        = *other.almWeights();
  *m_almFilter         = *other.almFilter();
  *m_almBeam           = *other.almBeam();
  *m_almNoise          = *other.almNoise();

  *m_inputDataMap      = *other.inputDataMap();
  *m_inputWeightsMap   = *other.inputWeightsMap();
  *m_inputMap          = *other.inputMap();
  *m_inputNoiseMap     = *other.inputNoiseMap();
  *m_inputFilterMap    = *other.inputFilterMap();
  *m_inputBeamMap      = *other.inputBeamMap();
  *m_pixelDataMap      = *other.pixelDataMap();
  *m_pixelWeightsMap   = *other.pixelWeightsMap();
  *m_pixelMap          = *other.pixelMap();
  *m_pixelOccupancyMap = *other.pixelOccupancyMap();
  *m_invDataMap        = *other.invDataMap();
  *m_invWeightsMap     = *other.invWeightsMap();
  *m_invMap            = *other.invMap();
  *m_pixelNoiseMap     = *other.pixelNoiseMap();
  *m_pixelFilterMap    = *other.pixelFilterMap();
  *m_pixelBeamMap      = *other.pixelBeamMap();
  *m_invNoiseMap       = *other.invNoiseMap();
  *m_invFilterMap      = *other.invFilterMap();
  *m_invBeamMap        = *other.invBeamMap();

  *m_transDataGraph    = *other.transDataGraph();
  *m_transWeightsGraph = *other.transWeightsGraph();
  *m_transGraph        = *other.transGraph();
  *m_spectDataGraph    = *other.spectrumGraph();
  *m_ensembleDataGraph = *other.ensembleGraph();
  *m_transFilterGraph  = *other.transFilterGraph();
  *m_transNoiseGraph   = *other.transNoiseGraph();
  *m_transBeamGraph    = *other.transBeamGraph();

  *m_fileIOEngine      = *other.fileIOEngine();
  *m_mapEngine         = *other.mappingEngine();
  *m_graphEngine       = *other.graphingEngine();
  *m_pixelEngine       = *other.pixelizationEngine();
  *m_transformEngine   = *other.transformationEngine();
  *m_powSpectEngine    = *other.powerSpectraEngine();

  m_selectedIOEngine        = other.fileIOEngineType();
  m_selectedMapEngine       = other.mappingEngineType();
  m_selectedPixelEngine     = other.pixelizationEngineType();
  m_selectedTransformEngine = other.transformationEngineType();
  m_sequence                = other.sequenceStep();

//  m_uiObject          = other.userInterface();
//  m_updateFunc        = other.updateFunction();
//  m_showProgress        = other.showProgress();

  return *this;
}

association& association::merge(association& other, bool replace) {
  if (replace)
    *this = other;
  else {
    if (!exists(fileType::InputData) && other.exists(fileType::InputData))
      m_inputData = new matrixData<double>(other.inputData());
    if (!exists(fileType::InputWeights) && other.exists(fileType::InputWeights))
      m_inputWeights = new matrixData<double>(other.inputWeights());
    if(!exists(fileType::PixelizedData) && other.exists(fileType::PixelizedData))
      m_pixelData = new vectorData<double>(other.pixelizedData());
    if (!exists(fileType::PixelizedWeights) && other.exists(fileType::PixelizedWeights))
      m_pixelWeights = new vectorData<double>(other.pixelizedWeights());
    if (!exists(fileType::PixelOccupancy) && other.exists(fileType::PixelOccupancy))
      m_pixelOccupancy = new vectorData<int>(other.pixelOccupancy());
    if (!exists(fileType::InverseData) && other.exists(fileType::InverseData))
      m_invData = new vectorData<double>(other.inverseData());
    if (!exists(fileType::InverseWeights) && other.exists(fileType::InverseWeights))
      m_invWeights = new vectorData<double>(other.inverseWeights());
    if (!exists(fileType::TransformedData) && other.exists(fileType::TransformedData))
      m_transData = new vectorData<double>(other.transformedData());
    if (!exists(fileType::TransformedWeights) && other.exists(fileType::TransformedWeights))
      m_transWeights = new vectorData<double>(other.transformedWeights());
    if (!exists(fileType::InputFilter) && other.exists(fileType::InputFilter))
      m_inputFilter = new matrixData<double>(other.inputFilter());
    if (!exists(fileType::PixelizedFilter) && other.exists(fileType::PixelizedFilter))
      m_pixelFilter = new vectorData<double>(other.pixelizedFilter());
    if (!exists(fileType::InverseFilter) && other.exists(fileType::InverseFilter))
      m_invFilter = new vectorData<double>(other.inverseFilter());
    if (!exists(fileType::InverseNoise) && other.exists(fileType::InverseNoise))
      m_invNoise = new vectorData<double>(other.inverseNoise());
    if (!exists(fileType::InverseBeam) && other.exists(fileType::InverseBeam))
      m_invBeam = new vectorData<double>(other.inverseBeam());
    if (!exists(fileType::TransformedFilter) && other.exists(fileType::TransformedFilter))
      m_transFilter = new vectorData<double>(other.transformedFilter());
    if (!exists(fileType::InputNoise) && other.exists(fileType::InputNoise))
      m_inputNoise = new matrixData<double>(other.inputNoise());
    if (!exists(fileType::PixelizedNoise) && other.exists(fileType::PixelizedNoise))
      m_pixelNoise = new vectorData<double>(other.pixelizedNoise());
    if (!exists(fileType::TransformedNoise) && other.exists(fileType::TransformedNoise))
      m_transNoise = new vectorData<double>(other.transformedNoise());
    if (!exists(fileType::InputBeam) && other.exists(fileType::InputBeam))
      m_inputBeam = new matrixData<double>(other.inputBeam());
    if (!exists(fileType::PixelizedBeam) && other.exists(fileType::PixelizedBeam))
      m_pixelBeam = new vectorData<double>(other.pixelizedBeam());
    if (!exists(fileType::TransformedBeam) && other.exists(fileType::TransformedBeam))
      m_transBeam = new vectorData<double>(other.transformedBeam());
    if (!exists(fileType::SpectralData) && other.exists(fileType::SpectralData))
      m_spectData = new vectorData<double>(other.spectrumData());
    if (!exists(fileType::EnsembleData) && other.exists(fileType::EnsembleData))
      m_ensembleSpectData = new vectorData<double>(other.ensembleData());
    if ((   !exists(fileType::BinCouplingMatrix) && other.exists(fileType::BinCouplingMatrix))
        && (!exists(fileType::ModeCouplingMatrix) && other.exists(fileType::ModeCouplingMatrix)))
      m_couplingMatrix = new matrixData<double>(other.couplingMatrix());
    if ((   !exists(fileType::InverseBinMatrix) && other.exists(fileType::InverseBinMatrix))
        && (!exists(fileType::InverseModeMatrix) && other.exists(fileType::InverseModeMatrix)))
      m_inverseMatrix = new matrixData<double>(other.inverseMatrix());
    if (!exists(fileType::AlmData) && other.exists(fileType::AlmData))
      m_almData = new cubeData<std::complex<double> >(other.almData());
    if (!exists(fileType::AlmWeights) && other.exists(fileType::AlmWeights))
      m_almWeights = new cubeData<std::complex<double> >(other.almWeights());
    if (!exists(fileType::AlmFilter) && other.exists(fileType::AlmFilter))
      m_almFilter = new cubeData<std::complex<double> >(other.almFilter());
    if (!exists(fileType::AlmNoise) && other.exists(fileType::AlmNoise))
      m_almNoise = new cubeData<std::complex<double> >(other.almNoise());
    if (!exists(fileType::AlmBeam) && other.exists(fileType::AlmBeam))
      m_almBeam = new cubeData<std::complex<double> >(other.almBeam());
  
    if (!exists(associatedMap::InputDataMap) && other.exists(associatedMap::InputDataMap))
      m_inputDataMap = new dataMap(other.inputDataMap());
    if (!exists(associatedMap::InputWeightsMap) && other.exists(associatedMap::InputWeightsMap))
      m_inputWeightsMap = new dataMap(other.inputWeightsMap());
    if (!exists(associatedMap::WeightedDataMap) && other.exists(associatedMap::WeightedDataMap))
      m_inputMap = new dataMap(other.inputMap());
    if (!exists(associatedMap::PixelizedDataMap) && other.exists(associatedMap::PixelizedDataMap))
      m_pixelDataMap = new dataMap(other.pixelDataMap());
    if (!exists(associatedMap::PixelizedWeightsMap) && other.exists(associatedMap::PixelizedWeightsMap))
      m_pixelWeightsMap = new dataMap(other.pixelWeightsMap());
    if (!exists(associatedMap::WeightedPixelMap) && other.exists(associatedMap::WeightedPixelMap))
      m_pixelMap = new dataMap(other.pixelMap());
    if(!exists(associatedMap::PixelOccupancyMap) && other.exists(associatedMap::PixelOccupancyMap))
      m_pixelOccupancyMap = new dataMap(other.pixelOccupancyMap());
    if (!exists(associatedMap::InverseDataMap) && other.exists(associatedMap::InverseDataMap))
      m_invDataMap = new dataMap(other.invDataMap());
    if (!exists(associatedMap::InverseWeightsMap) && other.exists(associatedMap::InverseWeightsMap))
      m_invWeightsMap = new dataMap(other.invWeightsMap());
    if (!exists(associatedMap::WeightedInverseMap) && other.exists(associatedMap::WeightedInverseMap))
      m_invMap = new dataMap(other.invMap());
    if (!exists(associatedMap::InputNoiseMap) && other.exists(associatedMap::InputNoiseMap))
      m_inputNoiseMap = new dataMap(other.inputNoiseMap());
    if (!exists(associatedMap::InputFilterMap) && other.exists(associatedMap::InputFilterMap))
      m_inputFilterMap = new dataMap(other.inputFilterMap());
    if (!exists(associatedMap::InputBeamMap) && other.exists(associatedMap::InputBeamMap))
      m_inputBeamMap = new dataMap(other.inputBeamMap());
    if (!exists(associatedMap::PixelizedNoiseMap) && other.exists(associatedMap::PixelizedNoiseMap))
      m_pixelNoiseMap = new dataMap(other.pixelNoiseMap());
    if (!exists(associatedMap::PixelizedFilterMap) && other.exists(associatedMap::PixelizedFilterMap))
      m_pixelFilterMap = new dataMap(other.pixelFilterMap());
    if (!exists(associatedMap::PixelizedBeamMap) && other.exists(associatedMap::PixelizedBeamMap))
      m_pixelBeamMap = new dataMap(other.pixelBeamMap());
    if (!exists(associatedMap::InverseNoiseMap) && other.exists(associatedMap::InverseNoiseMap))
      m_invNoiseMap = new dataMap(other.invNoiseMap());
    if (!exists(associatedMap::InverseFilterMap) && other.exists(associatedMap::InverseFilterMap))
      m_invFilterMap = new dataMap(other.invFilterMap());
    if (!exists(associatedMap::InverseBeamMap) && other.exists(associatedMap::InverseBeamMap))
      m_invBeamMap = new dataMap(other.invBeamMap());
  
    if (!exists(associatedSpectrum::TransformedDataSpectrum) && other.exists(associatedSpectrum::TransformedDataSpectrum))
      m_transDataGraph = new dataSpectrum(other.transDataGraph());
    if (!exists(associatedSpectrum::TransformedWeightsSpectrum) && other.exists(associatedSpectrum::TransformedWeightsSpectrum))
      m_transWeightsGraph = new dataSpectrum(other.transWeightsGraph());
    if (!exists(associatedSpectrum::WeightedTransformSpectrum) && other.exists(associatedSpectrum::WeightedTransformSpectrum))
      m_transGraph = new dataSpectrum(other.transGraph());
    if (!exists(associatedSpectrum::SpectralDataSpectrum) && other.exists(associatedSpectrum::SpectralDataSpectrum))
      m_spectDataGraph = new dataSpectrum(other.spectrumGraph());
    if (!exists(associatedSpectrum::EnsembleDataSpectrum) && other.exists(associatedSpectrum::EnsembleDataSpectrum))
      m_ensembleDataGraph = new dataSpectrum(other.ensembleGraph());
    if (!exists(associatedSpectrum::TransformedFilterSpectrum) && other.exists(associatedSpectrum::TransformedFilterSpectrum))
      m_transFilterGraph = new dataSpectrum(other.transFilterGraph());
    if (!exists(associatedSpectrum::TransformedNoiseSpectrum) && other.exists(associatedSpectrum::TransformedNoiseSpectrum))
      m_transNoiseGraph = new dataSpectrum(other.transNoiseGraph());
    if (!exists(associatedSpectrum::TransformedBeamSpectrum) && other.exists(associatedSpectrum::TransformedBeamSpectrum))
      m_transBeamGraph = new dataSpectrum(other.transBeamGraph());

    if (!exists(dataEngines::fileIO) && other.exists(dataEngines::fileIO)) {
      if (other.fileIOEngine()->fileFormat() == CSV)
        m_fileIOEngine = new csvManager((csvManager*)other.fileIOEngine());
      else if (other.fileIOEngine()->fileFormat() == Fits)
        m_fileIOEngine = new fitsManager((fitsManager*)other.fileIOEngine());
    }
    if (!exists(dataEngines::Mapping) && other.exists(dataEngines::Mapping))
      if (other.mappingEngine()->layout() == Mollweide)
        m_mapEngine = new MollweideMapper((MollweideMapper*)other.mappingEngine());
    if (!exists(dataEngines::Graphing) && other.exists(dataEngines::Graphing))
      m_graphEngine = new Grapher(other.graphingEngine());
    if (!exists(dataEngines::Pixelization) && other.exists(dataEngines::Pixelization))
      if (other.pixelizationEngine()->pixelizerScheme() == HealPIX)
        m_pixelEngine = new HealPIXPixelizer((HealPIXPixelizer*)other.pixelizationEngine());
    if (!exists(dataEngines::Transformation) && other.exists(dataEngines::Transformation))
      if (other.transformationEngine()->scheme() == Rsht)
        m_transformEngine = new RshtTransformer((RshtTransformer*)other.transformationEngine());
    if (!exists(dataEngines::PseudoSpectrum) && other.exists(dataEngines::PseudoSpectrum))
      m_powSpectEngine = new Spectrum(other.powerSpectraEngine());

    if (!m_selectedIOEngine && other.fileIOEngineType())
      m_selectedIOEngine = other.fileIOEngineType();
    if (!m_selectedMapEngine && other.mappingEngineType())
      m_selectedMapEngine = other.mappingEngineType();
    if (!m_selectedPixelEngine && other.pixelizationEngineType())
      m_selectedPixelEngine = other.pixelizationEngineType();
    if (!m_selectedTransformEngine && other.transformationEngineType())
      m_selectedTransformEngine = other.transformationEngineType();
    if (!m_sequence && other.sequenceStep())
      m_sequence = other.sequenceStep();

    /*
    if (!m_uiObject && other.userInterface())
      m_uiObject = other.userInterface();
    if (!m_updateFunc && other.updateFunction())
      m_updateFunc = other.updateFunction();
    if (!m_showProgress && other.showProgress())
      m_showProgress = other.showProgress();
    */
  }
  
  return *this;
}

baseData& association::merge (FILETYPE dataType, baseData* other, bool replace) {

  baseData* bdPtr = 0;

  switch (dataType) {
    case fileType::InputData:
      if (m_inputData == 0)
        m_inputData = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputData && replace)
          m_inputData = (matrixData<double>*)other;
      }
      bdPtr = m_inputData;
      break;
    case fileType::InputWeights:
      if (m_inputWeights == 0)
        m_inputWeights = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputWeights && replace)
          m_inputWeights = (matrixData<double>*)other;
      }
      bdPtr = m_inputWeights;
      break;
    case fileType::InputNoise:
      if (m_inputNoise == 0)
        m_inputNoise = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputNoise && replace)
          m_inputNoise = (matrixData<double>*)other;
      }
      bdPtr = m_inputNoise;
      break;
    case fileType::InputFilter:
      if (m_inputFilter == 0)
        m_inputFilter = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputFilter && replace)
          m_inputFilter = (matrixData<double>*)other;
      }
      bdPtr = m_inputFilter;
      break; *m_inputFilter;
    case fileType::InputBeam:
      if (m_inputBeam == 0)
        m_inputBeam = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_inputBeam && replace)
          m_inputBeam = (matrixData<double>*)other;
      }
      bdPtr = m_inputBeam;
      break;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      if (m_couplingMatrix == 0)
        m_couplingMatrix = new matrixData<double>((matrixData<double>*)other);
      else {
        if (m_couplingMatrix && replace)
          m_couplingMatrix = (matrixData<double>*)other;
      }
      bdPtr = m_couplingMatrix;
      break;
    case fileType::PixelizedData:
      if (m_pixelData == 0)
        m_pixelData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelData && replace)
          m_pixelData = (vectorData<double>*)other;
      }
      bdPtr = m_pixelData;
      break;;
    case fileType::PixelizedWeights:
      if (m_pixelWeights == 0)
        m_pixelWeights = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelWeights && replace)
          m_pixelWeights = (vectorData<double>*)other;
      }
      bdPtr = m_pixelWeights;
      break;
    case fileType::PixelizedNoise:
      if (m_pixelNoise == 0)
        m_pixelNoise = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelNoise && replace)
          m_pixelNoise = (vectorData<double>*)other;
      }
      bdPtr = m_pixelNoise;
      break;
    case fileType::PixelizedFilter:
      if (m_pixelFilter == 0)
        m_pixelFilter = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelFilter && replace)
          m_pixelFilter = (vectorData<double>*)other;
      }
      bdPtr = m_pixelFilter;
      break;
    case fileType::PixelizedBeam:
      if (m_pixelBeam == 0)
        m_pixelBeam = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_pixelBeam && replace)
          m_pixelBeam = (vectorData<double>*)other;
      }
      bdPtr = m_pixelBeam;
      break;
    case fileType::PixelOccupancy:
      if (m_pixelOccupancy == 0)
        m_pixelOccupancy = new vectorData<int>((vectorData<int>*)other);
      else {
        if (m_pixelOccupancy && replace)
          m_pixelOccupancy = (vectorData<int>*)other;
      }
      bdPtr = m_pixelOccupancy;
      break;
    case fileType::TransformedData:
      if (m_transData == 0)
        m_transData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transData && replace)
          m_transData = (vectorData<double>*)other;
      }
      bdPtr = m_transData;
      break;
    case fileType::TransformedWeights:
      if (m_transWeights == 0)
        m_transWeights = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transWeights && replace)
          m_transWeights = (vectorData<double>*)other;
      }
      bdPtr = m_transWeights;
      break;
    case fileType::TransformedNoise:
      if (m_transNoise == 0)
        m_transNoise = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transNoise && replace)
          m_transNoise = (vectorData<double>*)other;
      }
      bdPtr = m_transNoise;
      break;
    case fileType::TransformedFilter:
      if (m_transFilter == 0)
        m_transFilter = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transFilter && replace)
          m_transFilter = (vectorData<double>*)other;
      }
      bdPtr = m_transFilter;
      break;
    case fileType::TransformedBeam:
      if (m_transBeam == 0)
        m_transBeam = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_transBeam && replace)
          m_transBeam = (vectorData<double>*)other;
      }
      bdPtr = m_transBeam;
      break;
    case fileType::SpectralData:
      if (m_spectData == 0)
        m_spectData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_spectData && replace)
          m_spectData = (vectorData<double>*)other;
      }
      bdPtr = m_spectData;
      break;
    case fileType::EnsembleData:
      if (m_ensembleSpectData == 0)
        m_ensembleSpectData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_ensembleSpectData && replace)
          m_ensembleSpectData = (vectorData<double>*)other;
      }
      bdPtr = m_ensembleSpectData;
      break;
    case fileType::InverseData:
      if (m_invData == 0)
        m_invData = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invData && replace)
          m_invData = (vectorData<double>*)other;
      }
      bdPtr = m_invData;
      break;
    case fileType::InverseWeights:
      if (m_invWeights == 0)
        m_invWeights = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invWeights && replace)
          m_invWeights = (vectorData<double>*)other;
      }
      bdPtr = m_invWeights;
      break;
    case fileType::InverseNoise:
      if (m_invNoise == 0)
        m_invNoise = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invNoise && replace)
          m_invNoise = (vectorData<double>*)other;
      }
      bdPtr = m_invNoise;
      break;
    case fileType::InverseFilter:
      if (m_invFilter == 0)
        m_invFilter = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invFilter && replace)
          m_invFilter = (vectorData<double>*)other;
      }
      bdPtr = m_invFilter;
      break;
    case fileType::InverseBeam:
      if (m_invBeam == 0)
        m_invBeam = new vectorData<double>((vectorData<double>*)other);
      else {
        if (m_invBeam && replace)
          m_invBeam = (vectorData<double>*)other;
      }
      bdPtr = m_invBeam;
      break;
    case fileType::AlmData:
      if (m_almData == 0)
        m_almData = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almData && replace)
          m_almData = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almData;
      break;
    case fileType::AlmWeights:
      if (m_almWeights == 0)
        m_almWeights = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almWeights && replace)
          m_almWeights = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almWeights;
      break;
    case fileType::AlmNoise:
      if (m_almNoise == 0)
        m_almNoise = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almNoise && replace)
          m_almNoise = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almNoise;
      break;
    case fileType::AlmFilter:
      if (m_almFilter == 0)
        m_almFilter = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almFilter && replace)
          m_almFilter = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almFilter;
      break;
    case fileType::AlmBeam:
      if (m_almBeam == 0)
        m_almBeam = new cubeData<std::complex<double> >((cubeData<std::complex<double> >*)other);
      else {
        if (m_almBeam && replace)
          m_almBeam = (cubeData<std::complex<double> >* )other;
      }
      bdPtr = m_almBeam;
      break;
  }

  return *bdPtr;
}

dataMap& association::merge(ASSOCIATEDMAP mapType, dataMap* other, bool replace) {
  dataMap* dmPtr = 0;

  switch (mapType) {
    case associatedMap::InputDataMap:
      if (m_inputDataMap == 0)
        m_inputDataMap = new dataMap((dataMap*)other);
      else {
        if (m_inputDataMap && replace)
          m_inputDataMap = other;
      }
      dmPtr = m_inputDataMap;
      break;
    case associatedMap::InputWeightsMap:
      if (m_inputWeightsMap == 0)
        m_inputWeightsMap = new dataMap((dataMap*)other);
      else {
        if (m_inputWeightsMap && replace)
          m_inputWeightsMap = other;
      }
      dmPtr = m_inputWeightsMap;
      break;
    case associatedMap::WeightedDataMap:
      if (m_inputMap == 0)
        m_inputMap = new dataMap((dataMap*)other);
      else {
        if (m_inputMap && replace)
          m_inputMap = other;
      }
      dmPtr = m_inputMap;
      break;
    case associatedMap::InputNoiseMap:
      if (m_inputNoiseMap == 0)
        m_inputNoiseMap = new dataMap((dataMap*)other);
      else {
        if (m_inputNoiseMap && replace)
          m_inputNoiseMap = other;
      }
      dmPtr = m_inputNoiseMap;
      break;
    case associatedMap::InputFilterMap:
      if (m_inputFilterMap == 0)
        m_inputFilterMap = new dataMap((dataMap*)other);
      else {
        if (m_inputFilterMap && replace)
          m_inputFilterMap = other;
      }
      dmPtr = m_inputFilterMap;
      break;
    case associatedMap::InputBeamMap:
      if (m_inputBeamMap == 0)
        m_inputBeamMap = new dataMap((dataMap*)other);
      else {
        if (m_inputBeamMap && replace)
          m_inputBeamMap = other;
      }
      dmPtr = m_inputBeamMap;
      break;
    case associatedMap::PixelizedDataMap:
      if (m_pixelDataMap == 0)
        m_pixelDataMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelDataMap && replace)
          m_pixelDataMap = other;
      }
      dmPtr = m_pixelDataMap;
      break;
    case associatedMap::PixelizedWeightsMap:
      if (m_pixelWeightsMap == 0)
        m_pixelWeightsMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelWeightsMap && replace)
          m_pixelWeightsMap = other;
      }
      dmPtr = m_pixelWeightsMap;
      break;
    case associatedMap::WeightedPixelMap:
      if (m_pixelMap == 0)
        m_pixelMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelMap && replace)
          m_pixelMap = other;
      }
      dmPtr = m_pixelMap;
      break;
    case associatedMap::PixelOccupancyMap:
      if (m_pixelOccupancyMap == 0)
        m_pixelOccupancyMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelOccupancyMap && replace)
          m_pixelOccupancyMap = other;
      }
      dmPtr = m_pixelOccupancyMap;
      break;
    case associatedMap::PixelizedNoiseMap:
      if (m_pixelNoiseMap == 0)
        m_pixelNoiseMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelNoiseMap && replace)
          m_pixelNoiseMap = other;
      }
      dmPtr = m_pixelNoiseMap;
      break;
    case associatedMap::PixelizedFilterMap:
      if (m_pixelFilterMap == 0)
        m_pixelFilterMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelFilterMap && replace)
          m_pixelFilterMap = other;
      }
      dmPtr = m_pixelFilterMap;
      break;
    case associatedMap::PixelizedBeamMap:
      if (m_pixelBeamMap == 0)
        m_pixelBeamMap = new dataMap((dataMap*)other);
      else {
        if (m_pixelBeamMap && replace)
          m_pixelBeamMap = other;
      }
      dmPtr = m_pixelBeamMap;
      break;
    case associatedMap::InverseDataMap:
      if (m_invDataMap == 0)
        m_invDataMap = new dataMap((dataMap*)other);
      else {
        if (m_invDataMap && replace)
          m_invDataMap = other;
      }
      dmPtr = m_invDataMap;
      break;
    case associatedMap::InverseWeightsMap:
      if (m_invWeightsMap == 0)
        m_inputWeightsMap = new dataMap((dataMap*)other);
      else {
        if (m_invWeightsMap && replace)
          m_invWeightsMap = other;
      }
      dmPtr = m_invWeightsMap;
      break;
    case associatedMap::WeightedInverseMap:
      if (m_invMap == 0)
        m_invMap = new dataMap((dataMap*)other);
      else {
        if (m_invMap && replace)
          m_invMap = other;
      }
      dmPtr = m_invMap;
      break;
    case associatedMap::InverseNoiseMap:
      if (m_invNoiseMap == 0)
        m_invNoiseMap = new dataMap((dataMap*)other);
      else {
        if (m_invNoiseMap && replace)
          m_invNoiseMap = other;
      }
      dmPtr = m_invNoiseMap;
      break;
    case associatedMap::InverseFilterMap:
      if (m_invFilterMap == 0)
        m_invFilterMap = new dataMap((dataMap*)other);
      else {
        if (m_invFilterMap && replace)
          m_invFilterMap = other;
      }
      dmPtr = m_invFilterMap;
      break;
    case associatedMap::InverseBeamMap:
      if (m_invBeamMap == 0)
        m_invBeamMap = new dataMap((dataMap*)other);
      else {
        if (m_invBeamMap && replace)
          m_invBeamMap = other;
      }
      dmPtr = m_invBeamMap;
      break;
  }

  return *dmPtr;
}

dataSpectrum& association::merge(ASSOCIATEDSPECTRUM graphType, dataSpectrum* other, bool replace) {
  dataSpectrum* dsPtr = 0;

  switch (graphType) {
    case associatedSpectrum::TransformedDataSpectrum:
      if (m_transDataGraph == 0)
        m_transDataGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transDataGraph && replace)
          m_transDataGraph = other;
      }
      dsPtr = m_transDataGraph;
      break;
    case associatedSpectrum::TransformedWeightsSpectrum:
      if (m_transWeightsGraph == 0)
        m_transWeightsGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transWeightsGraph && replace)
          m_transWeightsGraph = other;
      }
      dsPtr = m_transWeightsGraph;
      break;
    case associatedSpectrum::WeightedTransformSpectrum:
      if (m_transGraph == 0)
        m_transGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transGraph && replace)
          m_transGraph = other;
      }
      dsPtr = m_transGraph;
      break;
    case associatedSpectrum::TransformedNoiseSpectrum:
      if (m_transNoiseGraph == 0)
        m_transNoiseGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transNoiseGraph && replace)
          m_transNoiseGraph = other;
      }
      dsPtr = m_transNoiseGraph;
      break;
    case associatedSpectrum::TransformedFilterSpectrum:
      if (m_transFilterGraph == 0)
        m_transFilterGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transFilterGraph && replace)
          m_transFilterGraph = other;
      }
      dsPtr = m_transFilterGraph;
      break;
    case associatedSpectrum::TransformedBeamSpectrum:
      if (m_transBeamGraph == 0)
        m_transBeamGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_transBeamGraph && replace)
          m_transBeamGraph = other;
      }
      dsPtr = m_transBeamGraph;
      break;
    case associatedSpectrum::SpectralDataSpectrum:
      if (m_spectDataGraph == 0)
        m_spectDataGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_spectDataGraph && replace)
          m_spectDataGraph = other;
      }
      dsPtr = m_spectDataGraph;
      break;
    case associatedSpectrum::EnsembleDataSpectrum:
      if (m_ensembleDataGraph == 0)
        m_ensembleDataGraph = new dataSpectrum((dataSpectrum*)other);
      else {
        if (m_ensembleDataGraph && replace)
          m_ensembleDataGraph = other;
      }
      dsPtr = m_ensembleDataGraph;
      break;
  }

  return *dsPtr;
}

Mapper& association::merge(MAPTYPE mapType, Mapper* other, bool replace) {
  Mapper* mapPtr = 0;

  switch (mapType) {
    case Mollweide:
      if (m_mapEngine == 0)
        m_mapEngine = new MollweideMapper((MollweideMapper*)other);
      else {
        if (m_mapEngine && replace)
          m_mapEngine = other;
      }
      mapPtr = m_mapEngine;
      break;
  }

  return *mapPtr;
}

Grapher& association::merge(Grapher* other, bool replace) {
  if (m_graphEngine == 0)
    m_graphEngine = new Grapher(other);
  else {
    if (m_graphEngine && replace)
      m_graphEngine = other;
  }
  return *m_graphEngine;
}

fileManager& association::merge(FORMAT ext, fileManager* other, bool replace) {
  fileManager* fmPtr = 0;

  switch (ext) {
    case Fits:
      if (m_fileIOEngine == 0)
        m_fileIOEngine = new fitsManager((fitsManager*)other);
      else {
        if (m_fileIOEngine && replace)
          m_fileIOEngine = other;
      }
      fmPtr = m_fileIOEngine;
      break;
    case CSV:
      if (m_fileIOEngine == 0)
        m_fileIOEngine = new csvManager((csvManager*)other);
      else {
        if (m_fileIOEngine && replace)
          m_fileIOEngine = other;
      }
      fmPtr = m_fileIOEngine;
      break;
  }

  return *fmPtr;
}

Pixelizer& association::merge(PIXELSCHEME pixType, Pixelizer* other, bool replace) {
  Pixelizer* pixPtr = 0;

  switch (pixType) {
     case HealPIX:
      if (m_pixelEngine == 0)
        m_pixelEngine = new HealPIXPixelizer((HealPIXPixelizer*)other);
      else {
        if (m_pixelEngine && replace)
          m_pixelEngine = other;
      }
      pixPtr = m_pixelEngine;
      break;
  }

  return *pixPtr;
}

Transformer& association::merge(TRANSFORMERSCHEME transType, Transformer* other, bool replace) {
  Transformer* transPtr = 0;

  switch (transType) {
    case Rsht:
      if (m_transformEngine == 0)
        m_transformEngine = new RshtTransformer((RshtTransformer*)other);
      else {
        if (m_transformEngine && replace)
          m_transformEngine = other;
      }
      transPtr = m_transformEngine;
      break;
  }

  return *transPtr;
}

Spectrum& association::merge(Spectrum* other, bool replace) {
  if (m_powSpectEngine == 0)
    m_powSpectEngine = new Spectrum(other);
  else {
    if (m_powSpectEngine && replace)
      m_powSpectEngine = other;
  }
  return *m_powSpectEngine;
}

bool association::exists(FILETYPE ft) {
  switch (ft) {
      case fileType::InputData:
      return (bool) m_inputData;
    case fileType::InputWeights:
      return (bool) m_inputWeights;
    case fileType::InputFilter:
      return (bool) m_inputFilter;
    case fileType::InputNoise:
      return (bool) m_inputNoise;
    case fileType::InputBeam:
      return (bool) m_inputBeam;
    case fileType::PixelizedData:
      return (bool) m_pixelData;
    case fileType::PixelizedWeights:
      return (bool) m_pixelWeights;
    case fileType::PixelOccupancy:
      return (bool) m_pixelOccupancy;
    case fileType::PixelizedFilter:
      return (bool) m_pixelFilter;
    case fileType::PixelizedBeam:
      return (bool) m_pixelBeam;
    case fileType::PixelizedNoise:
      return (bool) m_pixelNoise;
    case fileType::TransformedData:
      return (bool) m_transData;
    case fileType::TransformedWeights:
      return (bool) m_transWeights;
    case fileType::TransformedNoise:
      return (bool) m_transNoise;
    case fileType::TransformedFilter:
      return (bool) m_transFilter;
    case fileType::TransformedBeam:
      return (bool) m_transBeam;
    case fileType::AlmData:
      return (bool) m_almData;
    case fileType::AlmWeights:
      return (bool) m_almWeights;
    case fileType::AlmNoise:
      return (bool) m_almNoise;
    case fileType::AlmFilter:
      return (bool) m_almFilter;
    case fileType::AlmBeam:
      return (bool) m_almBeam;
    case fileType::InverseData:
      return (bool) m_invData;
    case fileType::InverseWeights:
      return (bool) m_invWeights;
    case fileType::InverseFilter:
      return (bool) m_invFilter;
    case fileType::InverseNoise:
      return (bool) m_invNoise;
    case fileType::InverseBeam:
      return (bool) m_invBeam;
    case fileType::SpectralData:
      return (bool) m_spectData;
    case fileType::EnsembleData:
      return (bool) m_ensembleSpectData;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      return (bool)m_couplingMatrix && (m_couplingMatrix->dataType() == ft);
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      return (bool)m_inverseMatrix && (m_inverseMatrix->dataType() == ft);

    /* Pseudo targets: these are really dependencies. */
    case fileType::WeightedData:
      return (bool) m_inputData && (bool) m_inputWeights;
    case fileType::WeightedPixel:
      return (bool) m_pixelData && (bool) m_pixelWeights;
    case fileType::WeightedTransform:
      return (bool) m_transData && (bool) m_transWeights;

    case fileType::Null:
    default:
      break;
  }
  return false;
}

bool association::exists(ASSOCIATEDMAP mt) {
  switch (mt) {
      case associatedMap::InputDataMap:
      return (bool) m_inputDataMap;
    case associatedMap::InputWeightsMap:
      return (bool) m_inputWeightsMap;
    case associatedMap::InputNoiseMap:
      return (bool) m_inputNoiseMap;
    case associatedMap::InputFilterMap:
      return (bool) m_inputFilterMap;
    case associatedMap::InputBeamMap:
      return (bool) m_inputBeamMap;
    case associatedMap::WeightedDataMap:
      return (bool) m_inputMap;
    case associatedMap::PixelizedDataMap:
      return (bool) m_pixelDataMap;
    case associatedMap::PixelizedWeightsMap:
      return (bool) m_pixelWeightsMap;
    case associatedMap::WeightedPixelMap:
      return (bool) m_pixelMap;
    case associatedMap::PixelOccupancyMap:
      return (bool) m_pixelOccupancyMap;
    case associatedMap::InverseDataMap:
      return (bool) m_invDataMap;
    case associatedMap::InverseWeightsMap:
      return (bool) m_invWeightsMap;
    case associatedMap::WeightedInverseMap:
      return (bool) m_invMap;
    case associatedMap::PixelizedNoiseMap:
      return (bool) m_pixelNoiseMap;
    case associatedMap::PixelizedFilterMap:
      return (bool) m_pixelFilterMap;
    case associatedMap::PixelizedBeamMap:
      return (bool) m_pixelBeamMap;
    case associatedMap::InverseNoiseMap:
      return (bool) m_invNoiseMap;
    case associatedMap::InverseFilterMap:
      return (bool) m_invFilterMap;
    case associatedMap::InverseBeamMap:
      return (bool) m_invBeamMap;

    case associatedMap::Null:
    default:
      break;
  }
  return false;
}

bool association::exists(ASSOCIATEDSPECTRUM st) {
  switch (st) {
      case associatedSpectrum::TransformedDataSpectrum:
      return (bool) m_transDataGraph;
    case associatedSpectrum::TransformedWeightsSpectrum:
      return (bool) m_transWeightsGraph;
    case associatedSpectrum::WeightedTransformSpectrum:
      return (bool) m_transGraph;
    case associatedSpectrum::SpectralDataSpectrum:
      return (bool) m_spectDataGraph;
    case associatedSpectrum::EnsembleDataSpectrum:
      return (bool) m_ensembleDataGraph;
    case associatedSpectrum::TransformedFilterSpectrum:
      return (bool) m_transFilterGraph;
    case associatedSpectrum::TransformedNoiseSpectrum:
      return (bool) m_transNoiseGraph;
    case associatedSpectrum::TransformedBeamSpectrum:
      return (bool) m_transBeamGraph;

    case associatedSpectrum::Null:
    default:
      break;
  }
  return false;
}

bool association::exists(DATAENGINES de) {
  switch (de) {
    case dataEngines::fileIO:
      return (bool) m_fileIOEngine;
    case dataEngines::Mapping:
      return (bool) m_mapEngine;
    case dataEngines::Graphing:
      return (bool) m_graphEngine;
    case dataEngines::Pixelization:
      return (bool) m_pixelEngine;
    case dataEngines::Transformation:
      return (bool) m_transformEngine;
    case dataEngines::PseudoSpectrum:
      return (bool) m_powSpectEngine;

    case dataEngines::Null:
    default:
      break;
  }
  return false;
}

baseData* association::getData(FILETYPE ft) {
  switch (ft) {
    case fileType::InputData:
      return m_inputData;
    case fileType::InputWeights:
      return m_inputWeights;
    case fileType::InputNoise:
      return m_inputNoise;
    case fileType::InputFilter:
      return m_inputFilter;
    case fileType::InputBeam:
      return m_inputBeam;
    case fileType::PixelizedData:
      return m_pixelData;
    case fileType::PixelizedWeights:
      return m_pixelWeights;
    case fileType::PixelOccupancy:
      return m_pixelOccupancy;
    case fileType::TransformedData:
      return m_transData;
    case fileType::TransformedWeights:
      return m_transWeights;
    case fileType::AlmData:
      return m_almData;
    case fileType::AlmWeights:
      return m_almWeights;
    case fileType::AlmNoise:
      return m_almNoise;
    case fileType::AlmFilter:
      return m_almFilter;
    case fileType::AlmBeam:
      return m_almBeam;
    case fileType::InverseData:
      return m_invData;
    case fileType::InverseWeights:
      return m_invWeights;
    case fileType::InverseBeam:
      return m_invBeam;
    case fileType::InverseNoise:
      return m_invNoise;
    case fileType::InverseFilter:
      return m_invFilter;
    case fileType::PixelizedNoise:
      return m_pixelNoise;
    case fileType::TransformedNoise:
      return m_transNoise;
    case fileType::PixelizedFilter:
      return m_pixelFilter;
    case fileType::TransformedFilter:
      return m_transFilter;
    case fileType::PixelizedBeam:
      return m_pixelBeam;
    case fileType::TransformedBeam:
      return m_transBeam;
    case fileType::SpectralData:
      return m_spectData;
    case fileType::EnsembleData:
      return m_ensembleSpectData;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      return m_couplingMatrix;
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      return m_inverseMatrix;
    default:
      break;
  }
  return 0;
}

dataMap* association::getMap(ASSOCIATEDMAP mt) {
  switch (mt) {
      case associatedMap::InputDataMap:
      return m_inputDataMap;
    case associatedMap::InputWeightsMap:
      return m_inputWeightsMap;
    case associatedMap::WeightedDataMap:
      return m_inputMap;
    case associatedMap::PixelizedDataMap:
      return m_pixelDataMap;
    case associatedMap::PixelizedWeightsMap:
      return m_pixelWeightsMap;
    case associatedMap::WeightedPixelMap:
      return m_pixelMap;
    case associatedMap::PixelOccupancyMap:
      return m_pixelOccupancyMap;
    case associatedMap::InverseDataMap:
      return m_invDataMap;
    case associatedMap::InverseWeightsMap:
      return m_invWeightsMap;
    case associatedMap::WeightedInverseMap:
      return m_invMap;
    case associatedMap::InverseNoiseMap:
      return m_invNoiseMap;
    case associatedMap::InverseFilterMap:
      return m_invFilterMap;
    case associatedMap::InverseBeamMap:
      return m_invBeamMap;
    case associatedMap::InputNoiseMap:
      return m_inputNoiseMap;
    case associatedMap::InputFilterMap:
      return m_inputFilterMap;
    case associatedMap::InputBeamMap:
      return m_inputBeamMap;
    case associatedMap::PixelizedNoiseMap:
      return m_pixelNoiseMap;
    case associatedMap::PixelizedFilterMap:
      return m_pixelFilterMap;
    case associatedMap::PixelizedBeamMap:
      return m_pixelBeamMap;
    case associatedMap::Null:
    default:
      break;
   }
   return 0;
}

dataSpectrum* association::getGraph(ASSOCIATEDSPECTRUM st) {
  switch (st) {
      case associatedSpectrum::TransformedDataSpectrum:
      return m_transDataGraph;
    case associatedSpectrum::TransformedWeightsSpectrum:
      return m_transWeightsGraph;
    case associatedSpectrum::WeightedTransformSpectrum:
      return m_transGraph;
    case associatedSpectrum::SpectralDataSpectrum:
      return m_spectDataGraph;
    case associatedSpectrum::EnsembleDataSpectrum:
      return m_ensembleDataGraph;
    case associatedSpectrum::TransformedFilterSpectrum:
      return m_transFilterGraph;
    case associatedSpectrum::TransformedNoiseSpectrum:
      return m_transNoiseGraph;
    case associatedSpectrum::TransformedBeamSpectrum:
      return m_transBeamGraph;
    case associatedSpectrum::Null:
    default:
      break;
   }
   return 0;
}

void* association::getEngine(DATAENGINES de) {
  switch (de) {
      case dataEngines::fileIO:
        return (void*) m_fileIOEngine;
      case dataEngines::Mapping:
        return (void*) m_mapEngine;
      case dataEngines::Graphing:
        return (void*) m_graphEngine;
      case dataEngines::Pixelization:
        return (void*) m_pixelEngine;
      case dataEngines::Transformation:
        return (void*) m_transformEngine;
      case dataEngines::PseudoSpectrum:
        return (void*) m_powSpectEngine;
      case dataEngines::Null:
      default:
        break;
  }
  return 0;
}

void association::addEngine(DATAENGINES de, ...) {
  ERRORCODES recursiveError = noErrors;

  if (exists(de)) {
    int offset = (int)de + (int)allTypes::SpectralDataSpectrum;
    reset((ALLTYPES)offset);
  }

  const char* fileName;
  FILETYPE dataType = fileType::Null;
  FORMAT fileFormat = None;
  MAPTYPE mapType = Blank;
  PIXELSCHEME pixType = NotPixelized;
  TRANSFORMERSCHEME transType = NotTransformed;
  RWMode mode = Read;
  std::va_list args;

  switch (de) {
    case dataEngines::fileIO:
      va_start(args,de);
      fileName = va_arg(args, const char*);
      fileFormat = static_cast<FORMAT>(va_arg(args,int));
      dataType = static_cast<FILETYPE>(va_arg(args,int));
      mode = static_cast<RWMode>(va_arg(args,int));
      va_end(args);
      switch (fileFormat) {
        case Fits:
          if (mode == Read)
            try {
              m_fileIOEngine = new fitsManager(this,fileName,dataType,CCfits::Read);
            }
            catch (ERRORCODES error) {
              recursiveError = error;
            }
          else
            try {
              m_fileIOEngine = new fitsManager(this,fileName,dataType,CCfits::Write);
            }
            catch (ERRORCODES error) {
              recursiveError = error;
            }
          break;
        case CSV:
          try {
            m_fileIOEngine = new csvManager(this,fileName,dataType,mode);
          }
          catch (ERRORCODES error) {
            recursiveError = error;
          }
          break;
      }
      if (recursiveError != noErrors)
        throw recursiveError;
      m_selectedIOEngine = fileFormat;
      break;
    case dataEngines::Mapping:
      va_start(args,de);
      mapType = static_cast<MAPTYPE>(va_arg(args,int));
      va_end(args);
      switch (mapType) {
        case Mollweide:
          m_mapEngine = new MollweideMapper();
          break;
      }
      m_selectedMapEngine = mapType;
      break;
    case dataEngines::Graphing:
      m_graphEngine = new Grapher();
      break;
    case dataEngines::Pixelization:
      va_start(args,de);
      pixType = static_cast<PIXELSCHEME>(va_arg(args,int));
      va_end(args);
      switch (pixType) {
        case HealPIX:
          m_pixelEngine = new HealPIXPixelizer();
          break;
      }
      m_selectedPixelEngine = pixType;
      break;
    case dataEngines::Transformation:
      va_start(args,de);
      transType = static_cast<TRANSFORMERSCHEME>(va_arg(args,int));
      va_end(args);
      switch (transType) {
        case Rsht:
          m_transformEngine = new RshtTransformer();
          break;
      }
      m_selectedTransformEngine = transType;
      break;
    case dataEngines::PseudoSpectrum:
      m_powSpectEngine = new Spectrum();
      break;
  }
}

inputMatrixData* association::workSpace(double resRA, double resDec) {
  if (m_workSpace)
    delete m_workSpace;
  m_workSpace = new inputMatrixData(resRA,resDec);
  m_workSpace->initialize();

  return m_workSpace;
}

inputMatrixData* association::workSpace(inputMatrixData *imd) {
  if (!imd)
    return 0;

  if (m_workSpace)
    delete m_workSpace;

  m_workSpace = imd;

  return m_workSpace;
}

void association::workSpaceTo(FILETYPE type, M_OP operation) {
  if (!m_workSpace)
    return;

  switch (type) {
    case fileType::InputData:
      if (operation == Replace) {
        if (m_inputData)
          delete m_inputData;
        m_inputData = m_workSpace;
        m_workSpace = 0;
      }
      else {
        if (!m_inputData)
          m_inputData = new inputMatrixData(m_workSpace);
        else
          matrixTransfer(m_inputData,m_workSpace,operation);	
      }
      m_inputData->dataType(fileType::InputData);
      m_inputData->mapType(associatedMap::InputDataMap);
      break;
    case fileType::InputWeights:
      if (operation == Replace) {
        if (m_inputWeights)
          delete m_inputWeights;
        m_inputWeights = m_workSpace;
        m_workSpace = 0;
      }
      else {
        if (!m_inputWeights)
          m_inputWeights =  new inputMatrixData(m_workSpace);
        else
          matrixTransfer(m_inputWeights,m_workSpace,operation);
      }
      m_inputWeights->dataType(fileType::InputWeights);
      m_inputWeights->mapType(associatedMap::InputWeightsMap);
      break;
    default:
      break;
  }
}

void association::matrixTransfer(matrixData<double>* to, matrixData<double>* from, M_OP operation) {
  long row, col;

  if (!from || !to)
    return;

  if (to->cols() < from->cols() || to->rows() < from->rows())
    return;

  col = 0;
  while	(col < from->cols()) {
    row = 0;
    while (row < from->rows()) {
      switch (operation) {
        case Add:
          (*to)[col][row] += (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Subtract:
          (*to)[col][row] -= (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Scale:
          (*to)[col][row] *= (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Replace:
          (*to)[col][row] = (*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Invert:
          (*to)[col][row] = from->maxValue()-(*from)[col][row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        case Mirror:
          (*to)[col][row] = (*from)[from->cols()-col][from->rows()-row];
          if ((*to)[col][row] > to->maxValue())
            to->maxValue((*to)[col][row]);
          if ((*to)[col][row] < to->minValue())
            to->minValue((*to)[col][row]);
          break;
        default:
          return;
      }
      row++;
    }
    col++;
  }
}

void association::addEmpty(FILETYPE type, int x, int y, int z) {
  discardRelation(type);

  switch (type) {
    case fileType::InputData:
      m_inputData = new matrixData<double>(x,y,type);
      break;
    case fileType::InputWeights:
      m_inputWeights = new matrixData<double>(x,y,type);
      break;
    case fileType::InputNoise:
      m_inputNoise = new matrixData<double>(x,y,type);
      break;
    case fileType::InputFilter:
      m_inputFilter = new matrixData<double>(x,y,type);
      break;
    case fileType::InputBeam:
      m_inputBeam = new matrixData<double>(x,y,type);
      break;
    case fileType::PixelizedData:
      m_pixelData = new vectorData<double>(x,type);
      break;
    case fileType::PixelizedWeights:
      m_pixelWeights = new vectorData<double>(x,type);
      break;
    case fileType::PixelOccupancy:
      m_pixelOccupancy = new vectorData<int>(x,type);
      break;
    case fileType::PixelizedFilter:
      m_pixelFilter = new vectorData<double>(x,type);
      break;
    case fileType::PixelizedNoise:
      m_pixelNoise = new vectorData<double>(x,type);
      break;
    case fileType::PixelizedBeam:
      m_pixelBeam = new vectorData<double>(x,type);
      break;
    case fileType::InverseData:
      m_invData = new vectorData<double>(x,type);
      break;
    case fileType::InverseWeights:
      m_invWeights = new vectorData<double>(x,type);
      break;
    case fileType::TransformedData:
      m_transData = new vectorData<double>(x,type);
      break;
    case fileType::TransformedWeights:
      m_transWeights = new vectorData<double>(x,type);
      break;
    case fileType::TransformedBeam:
      m_transBeam = new vectorData<double>(x,type);
      break;
    case fileType::TransformedNoise:
      m_transNoise = new vectorData<double>(x,type);
      break;
    case fileType::TransformedFilter:
      m_transFilter = new vectorData<double>(x,type);
      break;
    case fileType::AlmData:
      m_almData = new cubeData<std::complex<double> >(x,y,z,type);
      break;
    case fileType::AlmWeights:
      m_almWeights = new cubeData<std::complex<double> >(x,y,z,type);
      break;
    case fileType::SpectralData:
      m_spectData = new vectorData<double>(x,type);
      break;
    case fileType::EnsembleData:
      m_ensembleSpectData = new vectorData<double>(x,type);
      break;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      m_couplingMatrix = new matrixData<double>(x,y,type);
      m_couplingMatrix->format((type == fileType::BinCouplingMatrix) ? Bin : Mode);
      break;
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_inverseMatrix = new matrixData<double>(x,y,type);
      m_inverseMatrix->format((type == fileType::InverseBinMatrix) ? Bin : Mode);
      break;
    default:
      break;
  }
  return;
}

void association::getResolution(FILETYPE dataType, double& RARes, double& decRes) {
  switch (dataType) {
    case fileType::InputData:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputData()->RARes();
      decRes = inputData()->DecRes();;
      break;
    case fileType::InputWeights:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputWeights()->RARes();
      decRes = inputWeights()->DecRes();;
      break;
    case fileType::InputNoise:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputNoise()->RARes();
      decRes = inputNoise()->DecRes();;
      break;
    case fileType::InputFilter:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputFilter()->RARes();
      decRes = inputFilter()->DecRes();;
      break;
    case fileType::InputBeam:
      if (!exists(dataType))
        throw undefinedSizeError;
      RARes = inputBeam()->RARes();
      decRes = inputBeam()->DecRes();;
      break;
    default:
      throw functionParameterError;
  }

  return;
}

void association::createEmptyDataSet(FILETYPE dataType, double RARes, double decRes) {

  if (RARes <= 0.0 || decRes <= 0.0)
    throw functionParameterError;

  //convert resolutions to number of bis

  if (RARes < 0.000001 || decRes < 0.000001)
    throw incompleteDatasetError;

  int x = (int)(360.0/RARes);
  int y = (int)(180.0/decRes);
  addEmpty(dataType, x, y);
  ((matrixData<double>*)(getData(dataType)))->RARes(RARes);
  ((matrixData<double>*)(getData(dataType)))->DecRes(decRes);
  ((matrixData<double>*)(getData(dataType)))->initialize();

  m_sequence = setSky;
  return;
}

void association::createUniformSky(FILETYPE dataType, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createUniformPatch(FILETYPE dataType, double decMax, double decMin, double RAMin, double RAMax, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(decMax,decMin,RAMax,RAMin,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createDeltaFunction(FILETYPE dataType, double RAPeak, double decPeak, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(RAPeak,decPeak,0,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createGaussian(FILETYPE dataType, double RAPeak, double decPeak, double width, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(RAPeak,decPeak,width,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createCheckerboard(FILETYPE dataType, double RAStride, double decStride, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(RAStride,decStride,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createHarmonic(FILETYPE dataType, int l, int m, double level, M_OP operation) {
  inputMatrixData* sandBox = 0;
  matrixData<double>* current = 0;

  if (dataType == fileType::Null || dataType == fileType::WeightedData || dataType > fileType::InputBeam)
    throw functionParameterError;

  if (exists(dataType)) {
    current = (matrixData<double>*)getData(dataType);
    sandBox = workSpace(current->RARes(), current->DecRes());
    sandBox->create(l,m,level);
    workSpaceTo(dataType, operation);
  }
  else
    throw undefinedSizeError;

  m_sequence = setSky;
  return;
}

void association::createWhiteNoise(vectorData<double>* vdd) {
  if (!m_pixelEngine)
    throw noPixelizerError;
  if (m_pixelEngine->pixelizerScheme() != HealPIX)
    throw noPixelizerError;
  HealPIXPixelizer* hp = (HealPIXPixelizer*)m_pixelEngine;

  if (!m_transData)
    throw incompleteDatasetError;
  if (!m_transWeights)
    throw incompleteDatasetError;

  // calculate the white noise value as the average value of the weight map time the pixel area in steradians
  // divided by the average number of sources in the data map
  double pixelArea = hp->pixelArea(true);
  double aveData = hp->calculateAverage(fileType::PixelizedData,this);
  double aveWeights = hp->calculateAverage(fileType::PixelizedWeights,this);
  double whiteNoise = pixelArea * aveWeights / aveData;

  // load vdd with white noise
  vdd->rwAccess().assign(m_transNoise->rows(),whiteNoise);

  return;
}

void association::createShotNoise(vectorData<double>* vdd) {
  if (!m_pixelEngine)
    throw noPixelizerError;
  if (m_pixelEngine->pixelizerScheme() != HealPIX)
    throw noPixelizerError;
  HealPIXPixelizer* hp = (HealPIXPixelizer*)m_pixelEngine;

  if (!m_transData)
    throw incompleteDatasetError;

  // initialize the random number generator
  gsl_rng_env_setup();
  const gsl_rng_type* generatorType = gsl_rng_default;
  gsl_rng* generator = gsl_rng_alloc(generatorType);

  // calculate the shot noise value by taking a random Poisson value using the data value
  // as the mean
  for (int row = 0; row < m_transNoise->rows(); ++row)
    (*vdd)[row] = (double)gsl_ran_poisson(generator,(*m_transData)[row]);

  return;
}

/* Added for new lib layer compat on Novemer 2, 2010 by J.D.
Modified version of above functions which does not assume "ownership"
of pixelizer; returns true on success, false otherwise... */

void association::generatePixelData(Pixelizer *pixelizer, FILETYPE ft) {
  int nPixels;
  matrixData<double> *in = 0;
  vectorData<double> *pix = 0;
  vectorData<int> *occ = 0;
  
  if (!pixelizer)
    throw noPixelizerError;
  
  if (!exists(ft))
    throw noDataError;

  nPixels = 12 * pixelizer->scale() * pixelizer->scale();
  m_pixelAverage  = 0;
  m_pixelVariance = 0;

  int offset = (int)fileType::PixelizedData - (int)fileType::InputData;
  FILETYPE pt = static_cast<FILETYPE>((int)ft + offset);
  if (ft > fileType::InputBeam)
    throw noDataError;
  if (pt >= fileType::PixelOccupancy)
    pt = static_cast<FILETYPE>((int)pt + 1);
  discardRelation(pt);
  addEmpty(pt,nPixels);

  switch (ft) {
    case fileType::InputData:
//      discardRelation(fileType::PixelizedData);
//      addEmpty(fileType::PixelizedData,nPixels);
      pix = m_pixelData;
      
      discardRelation(fileType::PixelOccupancy);
      addEmpty(fileType::PixelOccupancy,nPixels);
      occ = m_pixelOccupancy;
      break;
    case fileType::InputWeights:
//      discardRelation(fileType::PixelizedWeights);
//      addEmpty(fileType::PixelizedWeights,nPixels);
      pix = m_pixelWeights;
      break;
    case fileType::InputNoise:
//      discardRelation(fileType::PixelizedNoise);
//      addEmpty(fileType::PixelizedNoise,nPixels);
      pix = m_pixelNoise;
      break;
    case fileType::InputFilter:
//      discardRelation(fileType::PixelizedFilter);
//      addEmpty(fileType::PixelizedFilter,nPixels);
      pix = m_pixelFilter;
      break;
    case fileType::InputBeam:
//      discardRelation(fileType::PixelizedBeam);
//      addEmpty(fileType::PixelizedBeam,nPixels);
      pix = m_pixelBeam;
      break;
  }
  pix->initialize();
  pix->pixelScheme(pixelizer->pixelizerScheme());
  pix->layout(pixelizer->pixelLayout());
  pix->sides(pixelizer->scale());
  
  if (occ) {
    occ->pixelScheme(pixelizer->pixelizerScheme());
    occ->layout(pixelizer->pixelLayout());
    occ->sides(pixelizer->scale());
  }

  pixelizer->pixelize(this,0,0,0,ft);

  if (pixelizer->average())
    m_pixelAverage = pixelizer->calculateAverage(ft,this);
  if (pixelizer->variance())
    pixelizer->calculateVariance(ft,this);

  m_sequence = pixelize;
  return;
}

bool association::generateTransformedData(Transformer *transformer, FILETYPE ft) {
  vectorData<double> *pix = 0, *trans = 0;
  cubeData<std::complex<double> > *alm = 0;
  
  if (!transformer)
    return false;

  if (!exists(ft))
    return false;

  int transOffset = (int)fileType::TransformedData - (int)fileType::PixelizedData;
  int almOffset   = (int)fileType::AlmData - (int)fileType::PixelizedData;
  FILETYPE transType = static_cast<FILETYPE>((int)ft + transOffset);
  FILETYPE almType   = static_cast<FILETYPE>((int) ft + almOffset);

  if (ft < fileType::PixelizedData || ft > fileType::PixelizedBeam)
    throw noDataError;
  if (ft >= fileType::PixelOccupancy) {
    transType = static_cast<FILETYPE>((int)ft + 1);
    almType   = static_cast<FILETYPE>((int)ft + 1);
  }
  discardRelation(transType);
  addEmpty(transType,transformer->maxIndex());
  addEmpty(almType,transformer->maxIndex(),transformer->maxIndex());

  switch (ft) {
    case fileType::PixelizedData:
//      discardRelation(fileType::TransformedData);
//      addEmpty(fileType::TransformedData,transformer->maxIndex());
//      m_transData->initialize();
//      addEmpty(fileType::AlmData,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almData->initialize();
      pix = m_pixelData;
      trans = m_transData;
      alm = m_almData;
      break;
    case fileType::PixelizedWeights:
//      discardRelation(fileType::TransformedWeights);
//      addEmpty(fileType::TransformedWeights,transformer->maxIndex());
//      m_transWeights->initialize();
//      addEmpty(fileType::AlmWeights,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almWeights->initialize();
      pix  = m_pixelWeights;
      trans = m_transWeights;
      alm = m_almWeights;
      break;
    case fileType::PixelizedNoise:
//      discardRelation(fileType::TransformedNoise);
//      addEmpty(fileType::TransformedNoise,transformer->maxIndex());
//      m_transNoise->initialize();
//      addEmpty(fileType::AlmNoise,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almNoise->initialize();
      pix = m_pixelNoise;
      trans = m_transNoise;
      alm = m_almNoise;
      break;
    case fileType::PixelizedFilter:
//      discardRelation(fileType::TransformedFilter);
//      addEmpty(fileType::TransformedFilter,transformer->maxIndex());
//      m_transFilter->initialize();
//      addEmpty(fileType::AlmFilter,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almFilter->initialize();
      pix = m_pixelFilter;
      trans = m_transFilter;
      alm = m_almFilter;
      break;
    case fileType::PixelizedBeam:
//      discardRelation(fileType::TransformedBeam);
//      addEmpty(fileType::TransformedBeam,transformer->maxIndex());
//      m_transBeam->initialize();
//      addEmpty(fileType::AlmBeam,transformer->maxIndex(),transformer->maxIndex(),3);
//      m_almBeam->initialize();
      pix = m_pixelBeam;
      trans = m_transBeam;
      alm = m_almBeam;
      break;
    default:
      return false;
  }
  
  trans->initialize();
  trans->transformerScheme(transformer->scheme());
  trans->minYIndex(transformer->minIndex());

  alm->initialize();

  transformer->dataSize(pix->size());
  transformer->initialize(this);
  transformer->configured(true);
  transformer->loadMap(this,pix->dataType());
  transformer->transform(this,trans->dataType());
  transformer->storeAlmMap(this,alm->dataType());

  m_sequence = transform;
  return true;
}

bool association::generatePowerSpectrumData(Spectrum *spect) {
  if (!spect)
    return false;

  if (!m_transData || !m_transWeights)
    return false;

  addEmpty(fileType::SpectralData,m_transData->size());
  spect->maxIndex(m_transData->maxYIndex());

  spect->initialize();

  // set up mode-mode coupling matrix
  if (!m_couplingMatrix) {
    addEmpty(fileType::ModeCouplingMatrix,m_transData->size(),m_transData->size());
    spect->createModeCouplingMatrix(this);
  }
  if (m_couplingMatrix->format() == Mode)
    spect->loadCouplingMatrix(this);

  /* Maybe some checks here, but think that most checking applies to
  existing file loaded matrices: therefore should be in a different
  "process from file" function... */

  long max_index = spect->maxIndex(), max_bin = spect->maxBin();
  long indices = spect->indices();
  long i = 0, j = 0, total = max_index * (max_index + 1);
  long minL = 0, maxL = 1;
  long op_total, progress = 0;

  if (spect->binning()) {
    op_total = max_bin * indices;

    /* Calculating bin-index coupling matrix */
    for (i = 0; i < max_bin; ++i) {
      minL = i * indices;
      maxL = minL + indices;
      if (maxL > max_index)
        maxL = max_index;

      for (j = minL; j < maxL; ++j) {
        spect->calculateBinIndexMatrix(i,j);
        progress = i * max_bin + j;
      }
    }

    /* Calculating index-bin coupling matrix */
    for (i = 0; i < max_bin; ++i) {
      minL = i * indices;
      maxL = minL + indices;
      if (maxL > max_index)
        maxL = max_index;

      for (j = minL; j < maxL; ++j) {
        spect->calculateIndexBinMatrix(i,j);
        progress = i * max_bin + j;
      }
    }

    op_total = max_bin * max_bin;

    if (!m_couplingMatrix)
      addEmpty(fileType::BinCouplingMatrix,m_transData->size(),m_transData->size());
    m_couplingMatrix->format(Bin);
    spect->calculateBinCouplingMatrix(this);
    if (m_couplingMatrix && m_couplingMatrix->format() == Bin)
      spect->loadCouplingMatrix(this);

    m_spectData->binned(true);
  }
  else
    m_spectData->binned(false);

  if (!m_inverseMatrix) {
    if (spect->binning())
      addEmpty(fileType::InverseBinMatrix,m_transData->size(),m_transData->size());
    else
      addEmpty(fileType::InverseModeMatrix,m_transData->size(),m_transData->size());
    m_inverseMatrix->initialize();
    if (spect->invertMatrix(this) < 0)
      return false;
  }
  spect->loadInverseMatrix(this);

//  if (spect->computeInverse()) {
//    if (!spect->binning() && m_inverseMatrix && m_inverseMatrix->format() == Mode)
//      spect->loadInverseMatrix(this);
//    else if (spect->binning() && m_inverseMatrix  && m_inverseMatrix->format() == Bin)
//      spect->loadInverseMatrix(this);
//    else if (!spect->binning() && !m_inverseMatrix) {
//      addEmpty(InverseModeMatrix,m_transData->size(),m_transData->size());
//      if (spect->invertMatrix(this) < 0)
//        return false;
//    }
//    else {
//      addEmpty(InverseBinMatrix,m_transData->size(),m_transData->size());
//      if (spect->invertMatrix(this) < 0)
//        return false;
//    }

  /* Calculating spectral data */
  spect->calculateSpectrum(this);

  m_spectData->mask(spect->maskIndex());
//  }

  m_sequence = powerSpectrum;
  return true;
}

bool association::generateInverseData(Transformer *transformer, FILETYPE ft) {
  vectorData<double> *pix = 0, *inv = 0;
  cubeData<std::complex<double> >* alm = 0;
  int size = 0;
  FILETYPE almType;
  
  if (!transformer)
    return false;

  if (m_pixelNoise)
    pix = pixelizedNoise();
  if (m_pixelBeam)
    pix = pixelizedBeam();
  if (m_pixelFilter)
    pix = pixelizedFilter();
  if (m_pixelWeights)
    pix = pixelizedWeights();
  if (m_pixelData)
    pix = pixelizedData();
  if (!pix)
    return false;
  
  size = pix->size();
  
  switch (ft) {
    case fileType::TransformedData:
      if (!m_almData)
        return false;
      alm = m_almData;
      addEmpty(fileType::InverseData,size);
      inv = m_invData;
      almType = fileType::AlmData;
      break;
    case fileType::TransformedWeights:
      if (!m_almWeights)
        return false;
      alm = m_almWeights;
      addEmpty(fileType::InverseWeights,size);
      inv = m_invWeights;
      almType = fileType::AlmWeights;
      break;
    case fileType::TransformedFilter:
      if (!m_almFilter)
        return false;
      alm = m_almFilter;
      addEmpty(fileType::InverseFilter,size);
      inv = m_invFilter;
      almType = fileType::AlmFilter;
      break;
    case fileType::TransformedBeam:
      if (!m_almBeam)
        return false;
      alm = m_almBeam;
      addEmpty(fileType::InverseBeam,size);
      inv = m_invBeam;
      almType = fileType::AlmBeam;
      break;
    case fileType::TransformedNoise:
      if (!m_almNoise)
        return false;
      alm = m_almNoise;
      addEmpty(fileType::InverseNoise,size);
      inv = m_invNoise;
      almType = fileType::AlmNoise;
      break;
    default:
      return false;
  }
      
  /* Calculating Inverse Transformation */
  transformer->loadAlmMap(this,almType);
  transformer->invert(this,ft);

  inv->pixelScheme(pix->pixelScheme());
  inv->layout(pix->layout());
  inv->sides(int(sqrt(inv->size()/12)));
  inv->numberOfPixels(inv->size());

  m_sequence = invert;
  return true;
}

void association::generateMap(FILETYPE type) {
  std::string   name;
  dataMap       *map = 0;

  if (!exists(dataEngines::Mapping))
    throw noMapperError;

  map = new dataMap();
  if (!map)
   throw noDatamapError;

  name = dataTypeNames[(int)type];
  map->title(name);
  map->orientation(m_mapEngine->orientation());
  map->aspect(m_mapEngine->aspectRatio());
  map->initialize(m_mapEngine->width(),m_mapEngine->height());
  map->colorScheme(m_mapEngine->colorScheme());
  map->createColorBar();

  switch (type) {
    case fileType::InputData:
      if (!m_inputData)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputDataMap)
        *m_inputDataMap = *map;
      else
        m_inputDataMap = new dataMap(map);
      break;
    case fileType::InputWeights:
      if (!m_inputWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputWeightsMap)
        *m_inputWeightsMap = *map;
      else
        m_inputWeightsMap = new dataMap(map);
      break;
    case fileType::WeightedData:
      if (!m_inputData || !m_inputWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputMap)
        *m_inputMap = *map;
      else
        m_inputMap = new dataMap(map);
      break;
    case fileType::InputNoise:
      if (!m_inputNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputNoiseMap)
        *m_inputNoiseMap = *map;
      else
        m_inputNoiseMap = new dataMap(map);
      break;
    case fileType::InputFilter:
      if (!m_inputFilter)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputFilterMap)
        *m_inputFilterMap = *map;
      else
        m_inputFilterMap = new dataMap(map);
      break;
    case fileType::InputBeam:
      if (!m_inputBeam)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_inputBeamMap)
        *m_inputBeamMap = *map;
      else
        m_inputBeamMap = new dataMap(map);
      break;
    case fileType::PixelizedData:
      if (!m_pixelData)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelDataMap)
        *m_pixelDataMap = *map;
      else
        m_pixelDataMap = new dataMap(map);
      break;
    case fileType::PixelizedWeights:
      if (!m_pixelWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelWeightsMap)
        *m_pixelWeightsMap = *map;
      else
        m_pixelWeightsMap = new dataMap(map);
      break;
    case fileType::WeightedPixel:
      if (!m_pixelData || !m_pixelWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelMap)
        *m_pixelMap = *map;
      else
        m_pixelMap = new dataMap(map);
      break;
    case fileType::PixelOccupancy:
      if (!m_pixelOccupancy)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelOccupancyMap)
        *m_pixelOccupancyMap = *map;
      else
        m_pixelOccupancyMap = new dataMap(map);
      break;
    case fileType::PixelizedNoise:
      if (!m_pixelNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelNoiseMap)
        *m_pixelNoiseMap = *map;
      else
        m_pixelNoiseMap = new dataMap(map);
      break;
    case fileType::PixelizedFilter:
      if (!m_pixelFilter)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelFilterMap)
        *m_pixelFilterMap = *map;
      else
        m_pixelFilterMap = new dataMap(map);
      break;
    case fileType::PixelizedBeam:
      if (!m_pixelBeam)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_pixelBeamMap)
        *m_pixelBeamMap = *map;
      else
        m_pixelBeamMap = new dataMap(map);
      break;
    case fileType::InverseData:
      if (!m_invData)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invDataMap)
        *m_invDataMap = *map;
      else
        m_invDataMap = new dataMap(map);
      break;
    case fileType::InverseWeights:
      if (!m_invWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invWeightsMap)
        *m_invWeightsMap = *map;
      else
        m_invWeightsMap = new dataMap(map);
      break;
    case fileType::WeightedInverse:
      if (!m_invData || !m_invWeights)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invMap)
        *m_invMap = *map;
      else
        m_invMap = new dataMap(map);
      break;
    case fileType::InverseNoise:
      if (!m_invNoise)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invNoiseMap)
        *m_invNoiseMap = *map;
      else
        m_invNoiseMap = new dataMap(map);
      break;
    case fileType::InverseFilter:
      if (!m_invFilter)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invFilterMap)
        *m_invFilterMap = *map;
      else
        m_invFilterMap = new dataMap(map);
      break;
    case fileType::InverseBeam:
      if (!m_invBeam)
        throw noDataError;
      m_mapEngine->makeMap(map,type,this);
      if (m_invBeamMap)
        *m_invBeamMap = *map;
      else
        m_invBeamMap = new dataMap(map);
      break;
    default:
      throw noDataError;
  }
  delete map;

  switch (type) {
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
      m_sequence = mapSky;
      break;
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::PixelOccupancy:
    case fileType::PixelizedNoise:
    case fileType::PixelizedFilter:
    case fileType::PixelizedBeam:
      m_sequence = mapPixel;
      break;
    case fileType::InverseData:
    case fileType::InverseWeights:
    case fileType::WeightedInverse:
    case fileType::InverseNoise:
    case fileType::InverseFilter:
    case fileType::InverseBeam:
      m_sequence = mapInverse;
      break;
  }
  return;
}

bool association::generateGraph(FILETYPE type) {
  std::string   name;
  dataSpectrum *graph = 0;

  if (!exists(dataEngines::Graphing))
    return false;
  
  graph = new dataSpectrum();
  if (!graph)
   return false;

  name = dataTypeNames[(int)type];
  graph->title(name);
  graph->aspect(m_graphEngine->aspectRatio());
  graph->initialize(m_graphEngine->width(),m_graphEngine->height());

  switch (type) {
    case fileType::TransformedData:
      if (!m_transData)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transDataGraph)
        *m_transDataGraph = *graph;
      else
        m_transDataGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedWeights:
      if (!m_transWeights)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transWeightsGraph)
        *m_transWeightsGraph = *graph;
      else
        m_transWeightsGraph = new dataSpectrum(graph);
      break;
    case fileType::WeightedTransform:
      if (!m_transData || !m_transWeights)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transGraph)
        *m_transGraph = *graph;
      else
        m_transGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedNoise:
      if (!m_pixelNoise)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transNoiseGraph)
        *m_transNoiseGraph = *graph;
      else
        m_transNoiseGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedFilter:
      if (!m_pixelFilter)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transFilterGraph)
        *m_transFilterGraph = *graph;
      else
        m_transFilterGraph = new dataSpectrum(graph);
      break;
    case fileType::TransformedBeam:
      if (!m_pixelBeam)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_transBeamGraph)
        *m_transBeamGraph = *graph;
      else
        m_transBeamGraph = new dataSpectrum(graph);
      break;
    case fileType::SpectralData:
      if (!m_spectData)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_spectDataGraph)
        *m_spectDataGraph = *graph;
      else
        m_spectDataGraph = new dataSpectrum(graph);
      break;
    case fileType::EnsembleData:
      if (!m_ensembleSpectData)
        return false;
      m_graphEngine->makeGraph(graph,type,this);
      if (m_ensembleDataGraph)
        *m_ensembleDataGraph = *graph;
      else
        m_ensembleDataGraph = new dataSpectrum(graph);
      break;
    default:
      return false;
  }
  delete graph;

  switch (type) {
    case fileType::TransformedData:
    case fileType::TransformedWeights:
    case fileType::WeightedTransform:
    case fileType::TransformedNoise:
    case fileType::TransformedFilter:
    case fileType::TransformedBeam:
      m_sequence = graphTransform;
      break;
    case fileType::SpectralData:
    case fileType::EnsembleData:
      m_sequence = graphPowerSpectrum;
      break;
  }
  return true;
}

void association::addData(baseData *item) {
  if (!item)
    return;

  if (exists(item->dataType()))
    discardRelation(item->dataType());

  switch (item->dataType()) {
      case fileType::InputData:
      m_inputData = (matrixData<double>*)item;
      break;
    case fileType::InputWeights:
      m_inputWeights = (matrixData<double>*)item;
      break;
    case fileType::InputNoise:
      m_inputNoise = (matrixData<double>*)item;
      break;
    case fileType::InputFilter:
      m_inputFilter = (matrixData<double>*)item;
      break;
    case fileType::InputBeam:
      m_inputBeam = (matrixData<double>*)item;
      break;
    case fileType::PixelizedData:
      m_pixelData = (vectorData<double>*)item;
      break;
    case fileType::PixelizedWeights:
      m_pixelWeights = (vectorData<double>*)item;
      break;
    case fileType::PixelOccupancy:
      m_pixelOccupancy = (vectorData<int>*)item;
      break;
    case fileType::PixelizedNoise:
      m_pixelNoise = (vectorData<double>*)item;
      break;
    case fileType::PixelizedFilter:
      m_pixelFilter = (vectorData<double>*)item;
      break;
    case fileType::PixelizedBeam:
      m_pixelBeam = (vectorData<double>*)item;
      break;
    case fileType::InverseData:
      m_invData = (vectorData<double>*)item;
      break;
    case fileType::InverseWeights:
      m_invWeights = (vectorData<double>*)item;
      break;
    case fileType::TransformedData:
      m_transData = (vectorData<double>*)item;
      break;
    case fileType::TransformedWeights:
      m_transWeights = (vectorData<double>*)item;
      break;
    case fileType::TransformedFilter:
      m_transFilter = (vectorData<double>*)item;
      break;
    case fileType::TransformedBeam:
      m_transBeam = (vectorData<double>*)item;
      break;
    case fileType::TransformedNoise:
      m_transNoise = (vectorData<double>*)item;
      break;
    case fileType::AlmData:
      m_almData = (cubeData<std::complex<double> >*)item;
      break;
    case fileType::AlmWeights:
      m_almWeights = (cubeData<std::complex<double> >*)item;
      break;
    case fileType::SpectralData:
      m_spectData = (vectorData<double>*)item;
      break;
    case fileType::EnsembleData:
      m_ensembleSpectData = (vectorData<double>*)item;
      break;
    default:
      break;
  }
}

SEQUENCE association::maxDataSet(GENERICTYPE type) {
  SEQUENCE seq = noSky;

  switch (type) {
    case Data:
      if (m_inputData)
        seq = setSky;
      if (m_pixelData)
        seq = pixelize;
      if (m_transData)
        seq = transform;
      if (m_spectData)
        seq = powerSpectrum;
      if (m_ensembleSpectData)
        seq = DONE;
      break;
    case Weights:
      if (m_inputWeights)
        seq = setSky;
      if (m_pixelWeights)
        seq = pixelize;
      if (m_transWeights)
        seq = transform;
      if (m_spectData)
        seq = powerSpectrum;
      if (m_ensembleSpectData)
        seq = DONE;
      break;
    case Noise:
      if (m_inputNoise)
        seq = setSky;
      if (m_pixelNoise)
        seq = pixelize;
      if (m_transNoise)
        seq = transform;
      if (m_spectData)
        seq = powerSpectrum;
      if (m_ensembleSpectData)
        seq = DONE;
      break;
    case Filter:
      if (m_inputFilter)
        seq = setSky;
      if (m_pixelFilter)
        seq = pixelize;
      if (m_transFilter)
        seq = transform;
      if (m_spectData)
        seq = powerSpectrum;
      if (m_ensembleSpectData)
        seq = DONE;
      break;
    case Beam:
      if (m_inputBeam)
        seq = setSky;
      if (m_pixelBeam)
        seq = pixelize;
      if (m_transBeam)
        seq = transform;
      if (m_spectData)
        seq = powerSpectrum;
      if (m_ensembleSpectData)
        seq = DONE;
      break;
    case NoGeneric:
    default:
      break;
  }

  return seq;
}

SEQUENCE association::maxDataChain(GENERICTYPE type) {
  SEQUENCE seq = noSky;

  switch (type) {
    case Data:
      if (!m_inputData)
        break;
      seq = setSky;
      if (!m_pixelData)
        break;
      seq = pixelize;
      if (!m_transData)
        break;
      seq = transform;
      if (!m_spectData)
        break;
      seq = powerSpectrum;
      if (!m_ensembleSpectData)
        break;
      seq = DONE;
      break;
    case Weights:
      if (!m_inputWeights)
        break;
      seq = setSky;
      if (!m_pixelWeights)
        break;
      seq = pixelize;
      if (!m_transWeights)
        break;
      seq = transform;
      if (!m_spectData)
        break;
      seq = powerSpectrum;
      if (!m_ensembleSpectData)
        break;
      seq = DONE;
      break;
    case Noise:
      if (!m_inputNoise)
        break;
      seq = setSky;
      if (!m_pixelNoise)
        break;
      seq = pixelize;
      if (!m_transNoise)
        break;
      seq = transform;
      if (!m_spectData)
        break;
      seq = powerSpectrum;
      if (!m_ensembleSpectData)
        break;
      seq = DONE;
      break;
    case Filter:
      if (!m_inputFilter)
        break;
      seq = setSky;
      if (!m_pixelFilter)
        break;
      seq = pixelize;
      if (!m_transFilter)
        break;
      seq = transform;
      if (!m_spectData)
        break;
      seq = powerSpectrum;
      if (!m_ensembleSpectData)
        break;
      seq = DONE;
      break;
    case Beam:
      if (!m_inputBeam)
        break;
      seq = setSky;
      if (!m_pixelBeam)
        break;
      seq = pixelize;
      if (!m_transBeam)
        break;
      seq = transform;
      if (!m_spectData)
        break;
      seq = powerSpectrum;
      if (!m_ensembleSpectData)
        break;
      seq = DONE;
      break;
    case NoGeneric:
    default:
        break;
  }

  return seq;
}

/*
  This method clears all dependent data structures in a
  "fall through" stack arrangement; e.g. calling for
  an InputData discard destroys ALL data on the Input
  Data portion of the chain.
*/
void association::discardRelation(FILETYPE type) {
  switch (type) {
    case fileType::InputData:
      if (m_inputData)
        delete m_inputData;
      m_inputData = 0;
    case fileType::PixelizedData:
      if (m_pixelData)
        delete m_pixelData;
      m_pixelData = 0;
    case fileType::TransformedData:
      if (m_transData)
        delete m_transData;
      m_transData = 0;
    case fileType::AlmData:
      if (m_almData)
        delete m_almData;
      m_almData = 0;
    case fileType::InverseData:
      if (m_invData)
        delete m_invData;
      m_invData = 0;
      break;
    /* End of fall through stack for input data */
    case fileType::InputWeights:
      if (m_inputWeights)
        delete m_inputWeights;
      m_inputWeights = 0;
    case fileType::PixelizedWeights:
      if (m_pixelWeights)
        delete m_pixelWeights;
      m_pixelWeights = 0;
    case fileType::TransformedWeights:
      if (m_transWeights)
        delete m_transWeights;
      m_transWeights = 0;
    case fileType::AlmWeights:
      if (m_almWeights)
        delete m_almWeights;
      m_almWeights = 0;
    case fileType::InverseWeights:
      if (m_invWeights)
        delete m_invWeights;
      m_invWeights = 0;
      break;
    /* End of input weights fall through stack */
    case fileType::InputFilter:
      if (m_inputFilter)
        delete m_inputFilter;
      m_inputFilter = 0;
    case fileType::PixelizedFilter:
      if (m_pixelFilter)
        delete m_pixelFilter;
      m_pixelFilter = 0;
    case fileType::TransformedFilter:
      if (m_transFilter)
        delete m_transFilter;
      m_transFilter = 0;
      break;
    case fileType::AlmFilter:
      if (m_almFilter)
        delete m_almFilter;
      m_almFilter = 0;
    case fileType::InverseFilter:
      if (m_invFilter)
        delete m_invFilter;
      m_invFilter = 0;
      break;
    /* End of filter data fall through stack */
    case fileType::InputNoise:
      if (m_inputNoise)
        delete m_inputNoise;
      m_inputNoise = 0;
    case fileType::PixelizedNoise:
      if (m_pixelNoise)
        delete m_pixelNoise;
      m_pixelNoise = 0;
    case fileType::TransformedNoise:
      if (m_transNoise)
        delete m_transNoise;
      m_transNoise = 0;
    case fileType::AlmNoise:
      if (m_almNoise)
        delete m_almNoise;
      m_almNoise = 0;
    case fileType::InverseNoise:
      if (m_invNoise)
        delete m_invNoise;
      m_invNoise = 0;
      break;
    /* End of noise data fall through stack */
    case fileType::InputBeam:
      if (m_inputBeam)
        delete m_inputBeam;
      m_inputBeam = 0;
    case fileType::PixelizedBeam:
      if (m_pixelBeam)
        delete m_pixelBeam;
      m_pixelBeam = 0;
    case fileType::TransformedBeam:
      if (m_transBeam)
        delete m_transBeam;
      m_transBeam = 0;
    case fileType::AlmBeam:
      if (m_almBeam)
        delete m_almBeam;
      m_almBeam = 0;
    case fileType::InverseBeam:
      if (m_invBeam)
        delete m_invBeam;
      m_invBeam = 0;
      break;
    /* End of beam data fall through stack */
    case fileType::PixelOccupancy:
      if (m_pixelOccupancy)
        delete m_pixelOccupancy;
      m_pixelOccupancy = 0;
      break;
    case fileType::SpectralData:
      if (m_spectData)
        delete m_spectData;
      m_spectData = 0;
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
      if (m_couplingMatrix)
        delete m_couplingMatrix;
      m_couplingMatrix = 0;
      break;
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      if (m_inverseMatrix)
        delete m_inverseMatrix;
      m_inverseMatrix = 0;
    case fileType::EnsembleData:
      if (m_ensembleSpectData)
        delete m_ensembleSpectData;
      m_ensembleSpectData = 0;
      break;
    default:
      break;
  }
  return;
}

void association::reset() {
  m_uiObject = 0;
  m_updateFunc = 0;
  m_showProgress = false;

  m_pixelAverage = 0;
  m_pixelVariance = 0;

  if (m_workSpace)
    delete m_workSpace;
  m_workSpace = 0;
  
  if(m_tmpSpace)
    delete m_tmpSpace;
  m_tmpSpace = 0;

  resetData();
  resetMaps();
  resetEngines();
}

void association::reset(ALLTYPES id) {
  switch (id) {
      case allTypes::InputData:
      if (m_inputData)
        delete m_inputData;
       m_inputData = 0;
       break;
    case allTypes::InputWeights:
      if (m_inputWeights)
        delete m_inputWeights;
      m_inputWeights = 0;
      break;
    case allTypes::InputNoise:
      if (m_inputNoise)
        delete m_inputNoise;
       m_inputNoise = 0;
       break;
    case allTypes::InputFilter:
      if (m_inputFilter)
        delete m_inputFilter;
       m_inputFilter = 0;
       break;
    case allTypes::InputBeam:
      if (m_inputBeam)
        delete m_inputBeam;
       m_inputBeam = 0;
       break;
    case allTypes::PixelizedData:
      if (m_pixelData)
        delete m_pixelData;
       m_pixelData = 0;
       break;
    case allTypes::PixelizedWeights:
      if (m_pixelWeights)
        delete m_pixelWeights;
       m_pixelWeights = 0;
       break;
    case allTypes::PixelizedNoise:
      if (m_pixelNoise)
        delete m_pixelNoise;
       m_pixelNoise = 0;
       break;
    case allTypes::PixelizedFilter:
      if (m_pixelFilter)
        delete m_pixelFilter;
       m_pixelFilter = 0;
       break;
    case allTypes::PixelizedBeam:
      if (m_pixelBeam)
        delete m_pixelBeam;
       m_pixelBeam = 0;
       break;
    case allTypes::PixelOccupancy:
      if (m_pixelOccupancy)
        delete m_pixelOccupancy;
       m_pixelOccupancy = 0;
       break;
    case allTypes::InverseData:
      if (m_invData)
        delete m_invData;
       m_invData = 0;
       break;
    case allTypes::InverseWeights:
      if (m_invWeights)
        delete m_invWeights;
       m_invWeights = 0;
       break;
    case allTypes::InverseNoise:
      if (m_invNoise)
        delete m_invNoise;
       m_invNoise = 0;
       break;
    case allTypes::InverseFilter:
      if (m_invFilter)
        delete m_invFilter;
       m_invFilter = 0;
       break;
    case allTypes::InverseBeam:
      if (m_invBeam)
        delete m_invBeam;
       m_invBeam = 0;
       break;
    case allTypes::TransformedData:
      if (m_transData)
        delete m_transData;
       m_transData = 0;
       break;
    case allTypes::TransformedWeights:
      if (m_transWeights)
        delete m_transWeights;
       m_transWeights = 0;
       break;
    case allTypes::TransformedNoise:
      if (m_transNoise)
        delete m_transNoise;
       m_transNoise = 0;
       break;
    case allTypes::TransformedFilter:
      if (m_transFilter)
        delete m_transFilter;
       m_transFilter = 0;
       break;
    case allTypes::TransformedBeam:
      if (m_transBeam)
        delete m_transBeam;
       m_transBeam = 0;
       break;
    case allTypes::SpectralData:
      if (m_spectData)
        delete m_spectData;
       m_spectData = 0;
       break;
    case allTypes::EnsembleData:
      if (m_ensembleSpectData)
        delete m_ensembleSpectData;
       m_ensembleSpectData = 0;
       break;
    case allTypes::AlmData:
      if (m_almData)
        delete m_almData;
       m_almData = 0;
       break;
    case allTypes::AlmWeights:
      if (m_almWeights)
        delete m_almWeights;
       m_almWeights = 0;
       break;
    case allTypes::AlmNoise:
      if (m_almNoise)
        delete m_almNoise;
       m_almNoise = 0;
       break;
    case allTypes::AlmFilter:
      if (m_almFilter)
        delete m_almFilter;
       m_almFilter = 0;
       break;
    case allTypes::AlmBeam:
      if (m_almBeam)
        delete m_almBeam;
       m_almBeam = 0;
       break;
    case allTypes::BinCouplingMatrix:
    case allTypes::ModeCouplingMatrix:
      if (m_couplingMatrix)
        delete m_couplingMatrix;
       m_couplingMatrix = 0;
       break;
    case allTypes::InverseBinMatrix:
    case allTypes::InverseModeMatrix:
      if (m_inverseMatrix)
        delete m_inverseMatrix;
       m_inverseMatrix = 0;
       break;
    case allTypes::InputDataMap:
      if (m_inputDataMap)
        delete m_inputDataMap;
       m_inputDataMap = 0;
       break;
    case allTypes::InputWeightsMap:
      if (m_inputWeightsMap)
        delete m_inputWeightsMap;
       m_inputWeightsMap = 0;
       break;
    case allTypes::WeightedDataMap:
      if (m_inputMap)
        delete m_inputMap;
       m_inputMap = 0;
       break;
    case allTypes::InputNoiseMap:
      if (m_inputNoiseMap)
        delete m_inputNoiseMap;
       m_inputNoiseMap = 0;
       break;
    case allTypes::InputFilterMap:
      if (m_inputFilterMap)
        delete m_inputFilterMap;
       m_inputFilterMap = 0;
       break;
    case allTypes::InputBeamMap:
      if (m_inputBeamMap)
        delete m_inputBeamMap;
       m_inputBeamMap = 0;
       break;
    case allTypes::PixelizedDataMap:
      if (m_pixelDataMap)
        delete m_pixelDataMap;
       m_pixelDataMap = 0;
       break;
    case allTypes::PixelizedWeightsMap:
      if (m_pixelWeightsMap)
        delete m_pixelWeightsMap;
       m_pixelWeightsMap = 0;
       break;
    case allTypes::WeightedPixelMap:
      if (m_pixelMap)
        delete m_pixelMap;
       m_pixelMap = 0;
       break;
    case allTypes::PixelOccupancyMap:
      if (m_pixelOccupancyMap)
        delete m_pixelOccupancyMap;
       m_pixelOccupancyMap = 0;
       break;
    case allTypes::PixelizedNoiseMap:
      if (m_pixelNoiseMap)
        delete m_pixelNoiseMap;
       m_pixelNoiseMap = 0;
       break;
    case allTypes::PixelizedFilterMap:
      if (m_pixelFilterMap)
        delete m_pixelFilterMap;
       m_pixelFilterMap = 0;
       break;
    case allTypes::PixelizedBeamMap:
      if (m_pixelBeamMap)
        delete m_pixelBeamMap;
       m_pixelBeamMap = 0;
       break;
    case allTypes::InverseDataMap:
      if (m_invDataMap)
        delete m_invDataMap;
       m_invDataMap = 0;
       break;
    case allTypes::InverseWeightsMap:
      if (m_invWeightsMap)
        delete m_invWeightsMap;
       m_invWeightsMap = 0;
       break;
    case allTypes::WeightedInverseMap:
      if (m_invMap)
        delete m_invMap;
       m_invMap = 0;
       break;
    case allTypes::InverseNoiseMap:
      if (m_invNoiseMap)
        delete m_invNoiseMap;
       m_invNoiseMap = 0;
       break;
    case allTypes::InverseBeamMap:
      if (m_invBeamMap)
        delete m_invBeamMap;
       m_invBeamMap = 0;
       break;
    case allTypes::TransformedDataSpectrum:
      if (m_transDataGraph)
        delete m_transDataGraph;
       m_transDataGraph = 0;
       break;
    case allTypes::TransformedWeightsSpectrum:
      if (m_transWeightsGraph)
        delete m_transWeightsGraph;
       m_transWeightsGraph = 0;
       break;
    case allTypes::WeightedTransformSpectrum:
      if (m_transGraph)
        delete m_transGraph;
       m_transGraph = 0;
       break;
    case allTypes::TransformedNoiseSpectrum:
      if (m_transNoiseGraph)
        delete m_transNoiseGraph;
       m_transNoiseGraph = 0;
       break;
    case allTypes::TransformedFilterSpectrum:
      if (m_transFilterGraph)
        delete m_transFilterGraph;
       m_transFilterGraph = 0;
       break;
    case allTypes::TransformedBeamSpectrum:
      if (m_transBeamGraph)
        delete m_transBeamGraph;
       m_transBeamGraph = 0;
       break;
    case allTypes::SpectralDataSpectrum:
      if (m_spectDataGraph)
        delete m_spectDataGraph;
       m_spectDataGraph = 0;
       break;
    case allTypes::EnsembleDataSpectrum:
      if (m_ensembleDataGraph)
        delete m_ensembleDataGraph;
       m_ensembleDataGraph = 0;
       break;
    case allTypes::fileIO:
      if (m_fileIOEngine)
        delete m_fileIOEngine;
       m_fileIOEngine = 0;
       break;
    case allTypes::Mapping:
      if (m_mapEngine)
        delete m_mapEngine;
      m_mapEngine = 0;
      break;
    case allTypes::Graphing:
      if (m_graphEngine)
        delete m_graphEngine;
      m_graphEngine = 0;
      break;
    case allTypes::Pixelization:
      if (m_pixelEngine)
        delete m_pixelEngine;
       m_pixelEngine = 0;
       break;
    case allTypes::Transformation:
      if (m_transformEngine)
        delete m_transformEngine;
       m_transformEngine = 0;
       break;
    case allTypes::PseudoSpectrum:
      if (m_powSpectEngine)
        delete m_powSpectEngine;
       m_powSpectEngine = 0;
       break;
    case allTypes::ALLTYPE_LIMIT:
         default:
      break;
  }
}

void association::resetData() {
  if (m_inputData)
    delete m_inputData;
  m_inputData = 0;

  if (m_inputWeights)
    delete m_inputWeights;
  m_inputWeights = 0;

  if (m_pixelData)
    delete m_pixelData;
  m_pixelData = 0;

  if (m_pixelWeights)
    delete m_pixelWeights;
  m_pixelWeights = 0;

  if (m_pixelOccupancy)
    delete m_pixelOccupancy;
  m_pixelOccupancy = 0;

  if (m_invData)
    delete m_invData;
  m_invData = 0;

  if (m_invWeights)
    delete m_invWeights;
  m_invWeights = 0;

  if (m_transData)
    delete m_transData;
  m_transData = 0;

  if (m_transWeights)
    delete m_transWeights;
  m_transWeights = 0;

  if (m_inputFilter)
    delete m_inputFilter;
  m_inputFilter = 0;
  
  if (m_pixelFilter)
    delete m_pixelFilter;
  m_pixelFilter = 0;

  if (m_transFilter)
    delete m_transFilter;
  m_transFilter = 0;

  if (m_inputNoise)
    delete m_inputNoise;
  m_inputNoise = 0;
  
  if (m_pixelNoise)
    delete m_pixelNoise;
  m_pixelNoise = 0;

  if (m_transNoise)
    delete m_transNoise;
  m_transNoise = 0;

  if (m_inputBeam)
    delete m_inputBeam;
  m_inputBeam = 0;
  
  if (m_pixelBeam)
    delete m_pixelBeam;
  m_pixelBeam = 0;

  if (m_transBeam)
    delete m_transBeam;
  m_transBeam = 0;

  if (m_spectData)
    delete m_spectData;
  m_spectData = 0;

  if (m_ensembleSpectData)
    delete m_ensembleSpectData;
  m_ensembleSpectData = 0;

  if (m_almData)
    delete m_almData;
  m_almData = 0;

  if (m_almWeights)
    delete m_almWeights;
  m_almWeights = 0;

  if (m_couplingMatrix)
    delete m_couplingMatrix;
  m_couplingMatrix = 0;

  if (m_inverseMatrix)
    delete m_inverseMatrix;
  m_inverseMatrix = 0;
}

void association::resetMaps() {
  if (m_inputDataMap)
    delete m_inputDataMap;
  m_inputDataMap = 0;

  if (m_inputWeightsMap)
    delete m_inputWeightsMap;
  m_inputWeightsMap = 0;
  
  if (m_inputMap)
    delete m_inputMap;
  m_inputMap = 0;

  if (m_pixelDataMap)
    delete m_pixelDataMap;
  m_pixelDataMap = 0;

  if (m_pixelWeightsMap)
    delete m_pixelWeightsMap;
  m_pixelWeightsMap = 0;
  
  if (m_pixelMap)
    delete m_pixelMap;
  m_pixelMap = 0;

  if (m_pixelOccupancyMap)
    delete m_pixelOccupancyMap;
  m_pixelOccupancyMap = 0;

  if (m_invDataMap)
    delete m_invDataMap;
  m_invDataMap = 0;

  if (m_invWeightsMap)
    delete m_invWeightsMap;
  m_invWeightsMap = 0;
  
  if (m_invMap)
    delete m_invMap;
  m_invMap = 0;
  
  if (m_inputNoiseMap)
    delete m_inputNoiseMap;
  m_inputNoiseMap = 0;
  
  if (m_pixelNoiseMap)
    delete m_pixelNoiseMap;
  m_pixelNoiseMap = 0;
  
  if (m_inputFilterMap)
    delete m_inputFilterMap;
  m_inputFilterMap = 0;
  
  if (m_pixelFilterMap)
    delete m_pixelFilterMap;
  m_pixelFilterMap = 0;
  
  if (m_inputBeamMap)
    delete m_inputBeamMap;
  m_inputBeamMap = 0;
  
  if (m_pixelBeamMap)
    delete m_pixelBeamMap;
  m_pixelBeamMap = 0;
}

void association::resetGraphs() {
  if (m_transDataGraph)
    delete m_transDataGraph;
  m_transDataGraph = 0;

  if (m_transWeightsGraph)
    delete m_transWeightsGraph;
  m_transWeightsGraph = 0;

  if (m_transNoiseGraph)
    delete m_transNoiseGraph;
  m_transNoiseGraph = 0;

  if (m_transFilterGraph)
    delete m_transFilterGraph;
  m_transFilterGraph = 0;

  if (m_transBeamGraph)
    delete m_transBeamGraph;
  m_transBeamGraph = 0;

  if (m_spectDataGraph)
    delete m_spectDataGraph;
  m_spectDataGraph = 0;

  if (m_ensembleDataGraph)
    delete m_ensembleDataGraph;
  m_ensembleDataGraph = 0;
}

void association::resetEngines() {
  if (m_fileIOEngine)
    delete m_fileIOEngine;
  m_fileIOEngine = 0;

  if (m_mapEngine)
    delete m_mapEngine;
  m_mapEngine = 0;

  if (m_graphEngine)
    delete m_graphEngine;
  m_graphEngine = 0;

  if (m_pixelEngine)
    delete m_pixelEngine;
  m_pixelEngine = 0;

  if (m_transformEngine)
    delete m_transformEngine;
  m_transformEngine = 0;

  if (m_powSpectEngine)
    delete m_powSpectEngine;
  m_powSpectEngine = 0;
}

// Pass in watching object uiObject and function to call when progress bar is updated.
//  Watching object will read from data set in callback fx.

/*
void association::setProgressFunc(void* uiObject,void (*func)(void*,int, const char*)) {
  m_uiObject = uiObject;
  m_updateFunc = func;
  if(m_uiObject && m_updateFunc)
    m_showProgress = true;
}
*/
