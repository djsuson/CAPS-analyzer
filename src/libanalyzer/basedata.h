/***************************************************************************
 *   basedata.h                                                            *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This class provides the basic functionality for all of the data classes *
 * used by the analyzer. It also does some basic data checking to          *
 * the appropriate data class for actual manipulation of the data.         *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#ifndef _BASEDATA_H_
#define _BASEDATA_H_

#include <vector>
#include <string>
#include <cstring>
#include <fstream>
#include <memory>
#include <CCfits/CCfits>
#include <math.h>
#include "atypes.h"

typedef void (*updateFx)(void*, int);

/* define baseData class */
class baseData {
  protected:
    struct dataVector {int x, y, z;};
    struct dataVector           m_maxIndex;
    struct dataVector           m_minIndex;
    struct dataVector           m_maxBin;
    struct dataVector           m_minBin;

  public:
    baseData();
    baseData(baseData* from);
    ~baseData() {}
  
    /**
     * print data
     */
    void print(){}

    /**
     * overload = operator
     */
     baseData& operator=(baseData& other);

    /**
     * reset base values
     */
    void reset();

    /**
     * access data file type
     */
     void dataType(FILETYPE type) {m_datatype = type;}
     FILETYPE dataType() const {return m_datatype;}
     int numDataTypes() const {return m_numFileTypes;}

    /**
     * access map type
     */
     void mapType(ASSOCIATEDMAP type) {m_maptype = type;}
     ASSOCIATEDMAP mapType() const {return m_maptype;}

    /**
     * access spectrum type
     */
     void spectrumType(ASSOCIATEDSPECTRUM type) {m_spectrumtype = type;}
     ASSOCIATEDSPECTRUM spectrumType() const {return m_spectrumtype;}

    /**
     * access data file format
     */
     void fileFormat(FORMAT type) {m_format = type;}
     FORMAT fileFormat() const {return m_format;}

    /**
     * access observatory type
     */
     void instrument(OBSERVATORY type) {m_observatory = type;}
     OBSERVATORY instrument() const {return m_observatory;}
     int numInstruments() const {return m_numObservatories;}

    /**
     * access file name
     */
     void fileName(std::string name) {m_fileName = name;}
     std::string fileName() const {return m_fileName;}

    /**
     * access dimensions
     */
     int dimensions() const {return m_nDimensions;}
     int rows() const {return m_rows;}
     int cols() const {return m_cols;}
     int slices() const {return m_slices;}
     int parts() const {return m_parts;}
     int size() {return m_cols * m_rows * m_slices;}

     /**
      * access maximum and minimum index and bin values
      */
     int maxXIndex() const {return m_maxIndex.x;}
     void maxXIndex(int value) {m_maxIndex.x = value;}
     int maxYIndex() const {return m_maxIndex.y;}
     void maxYIndex(int value) {m_maxIndex.y = value;}
     int maxZIndex() const {return m_maxIndex.z;}
     void maxZIndex(int value) {m_maxIndex.z = value;}
     const dataVector& maxIndex() const {return m_maxIndex;}
     int minXIndex() const {return m_minIndex.x;}
     void minXIndex(int value) {m_minIndex.x = value;}
     int minYIndex() const {return m_minIndex.y;}
     void minYIndex(int value) {m_minIndex.y = value;}
     int minZIndex() const {return m_minIndex.z;}
     void minZIndex(int value) {m_minIndex.z = value;}
     const dataVector& minIndex() const {return m_minIndex;}
     int maxXBin() const {return m_maxBin.x;}
     void maxXBin(int value) {m_maxBin.x = value;}
     int maxYBin() const {return m_maxBin.y;}
     void maxYBin(int value) {m_maxBin.y = value;}
     int maxZBin() const {return m_maxBin.z;}
     void maxZBin(int value) {m_maxBin.z = value;}
     const dataVector& maxBin() const {return m_maxBin;}
     int minXBin() const {return m_minBin.x;}
     void minXBin(int value) {m_minBin.x = value;}
     int minYBin() const {return m_minBin.y;}
     void minYBin(int value) {m_minBin.y = value;}
     int minZBin() const {return m_minBin.z;}
     void minZBin(int value) {m_minBin.z = value;}
     const dataVector& minBin() const {return m_minBin;}

     /**
     * access maximum and minimum values
     */
    double maxValue() const {return m_maxValue;}
    void   maxValue(double value) {m_maxValue = value;}
    double minValue() const {return m_minValue;}
    void   minValue(double value) {m_minValue = value;}

    /**
     * access other variables for copy constructor
     */
     FITSTYPE bitpix() const {return m_bitpix;}
     
    /**
     * check if data has been initialized
     */
     bool initialized() const {return m_initialized;}
     void initialized(bool value) {m_initialized = value;}
   
    /**
     * check if data has been finalized
     */
     bool finalized() const {return m_finalized;}
     void finalized(bool value) {m_finalized = value;}

   /**
    * set up progress bar callback
    */
//     void  setProgressFunc(void* uiObject,void (*func)(void*,int)); // This is called by the GUI
//     void  informProgress(int progress) { if(m_updateFunc) m_updateFunc(m_uiObject, progress);} //  This is called by data
//     void  showProgress(bool show) { m_showProgress = show;}
//     bool  showProgress() const {return m_showProgress;}
//     void* userInterface() const {return m_uiObject;}
//     updateFx updateFunction() const {return m_updateFunc;}

     /**
      * convert between degrees and radians
      */
     static double deg2rad(double deg);
     static double rad2deg(double rad);

  protected:

    FILETYPE                    m_datatype;
    ASSOCIATEDMAP               m_maptype;
    ASSOCIATEDSPECTRUM          m_spectrumtype;
    FORMAT                      m_format;
    OBSERVATORY                 m_observatory;

//    bool                        m_showProgress;
//    void*                       m_uiObject;
//    updateFx                    m_updateFunc;

    /*
      Dimensionality of data: alm data typically four
      (complex number parts + three slices).
    */
    FITSTYPE                    m_bitpix;
    int                         m_slices;
    int                         m_cols;
    int                         m_rows;
    int                         m_parts;

    std::string                 m_fileName;
    int                         m_nDimensions;
    bool                        m_initialized;
    bool                        m_finalized;

    int                         m_numFileTypes;
    int                         m_numObservatories;

    double                      m_maxValue;
    double                      m_minValue;
};

#endif
