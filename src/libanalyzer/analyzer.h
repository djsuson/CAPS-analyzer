/***************************************************************************
 *   analyzer.h                                                            *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * The analyzer module provides a C style interface into the rest of the   *
 * backend objects.                                                        *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/

/*------------------------------------------------------------------------------
            Standard C-style Interface to the Analyzer Backend
------------------------------------------------------------------------------*/
#ifndef __ANALYZER_H__
#define __ANALYZER_H__

#ifdef __cplusplus
  extern "C" {
#endif

/*------------------------------------------------------------------------------
                           Types and Declarations
------------------------------------------------------------------------------*/
#ifndef BOOL
  #define BOOL unsigned
#endif

#ifndef TRUE
  #define TRUE 1
#endif

#ifndef FALSE
  #define FALSE 0
#endif

#define ANALYZER_NULL_DATA 0

typedef enum {
  ANALYZER_FILE_UNKNOWN = 0,
  ANALYZER_FILE_FITS,
  ANALYZER_FILE_BLOCK,
  ANALYZER_FILE_CSV,
  ANALYZER_FILE_HDF5,
  ANALYZER_FILE_LIMIT
}
analyzer_file_t;

typedef enum {
  ANALYZER_SRC_UNKNOWN = 0,
  ANALYZER_SRC_ANALYZER,
  ANALYZER_SRC_EGRET,
  ANALYZER_SRC_FERMI,
  ANALYZER_SRC_SLOAN,
  ANALYZER_SRC_TELESCOPE_ARRAY,
  ANALYZER_SRC_AUGER,
  ANALYZER_SRC_KASCADE,
  ANALYZER_SRC_DELVE,
  ANALYZER_SRC_LIMIT
}
analyzer_source_t;

typedef enum {
  ANALYZER_SKY_ADD = 0,
  ANALYZER_SKY_SUBTRACT,
  ANALYZER_SKY_SCALE,
  ANALYZER_SKY_REPLACE,
  ANALYZER_SKY_INVERT,
  ANALYZER_SKY_MIRROR,
  ANALYZER_SKY_LIMIT
}
analyzer_op_t;

typedef enum {
  ANALYZER_CONTROL_EMPTY = 0,
  ANALYZER_CONTROL_UNIFORM,
  ANALYZER_CONTROL_REGIONAL,
  ANALYZER_CONTROL_DELTA,
  ANALYZER_CONTROL_GAUSSIAN,
  ANALYZER_CONTROL_CHECKER,
  ANALYZER_CONTROL_HARMONIC,
  ANALYZER_CONTROL_LIMIT
}
analyzer_cont_t;
  
typedef enum {
  ANALYZER_PROJ_FLAT = 0,
  ANALYZER_PROJ_MOLLWEIDE,
  ANALYZER_PROJ_ATOFF,
  ANALYZER_PROJ_GNOMONIC,
  ANALYZER_PROJ_LIMIT
}
analyzer_proj_t;

typedef enum {
  ANALYZER_MAP_BASELESS = 0,
  ANALYZER_MAP_ASTRONOMICAL,
  ANALYZER_MAP_TERRESTRIAL,
  ANALYZER_MAPTYPE_LIMIT
}
analyzer_map_t;

typedef enum {
  ANALYZER_COORD_NONE = 0,
  ANALYZER_COORD_RADEC,
  ANALYZER_COORD_GALLATLONG,
  ANALYZER_COORD_TERRLATLONG,
  ANALYZER_COORD_LIMIT
}
analyzer_coord_t;

typedef enum {
  ANALYZER_HSV_LUMINANCE = 0,
  ANALYZER_HSV_RGB_LINEAR,
  ANALYZER_HSV_RGB_LOG,
  ANALYZER_HSV_RGB_SUPERLOG,
  ANALYZER_HSV_RGB_LIMIT
}
analyzer_hsv_t;

typedef enum {
  ANALYZER_NONE = 0,
  ANALYZER_SKY,
  ANALYZER_SKY_WEIGHTS,
  ANALYZER_WEIGHTED_SKY,
  ANALYZER_SKY_NOISE,
  ANALYZER_SKY_FILTER,
  ANALYZER_SKY_BEAM,
  ANALYZER_PIXEL,
  ANALYZER_PIXEL_WEIGHTS,
  ANALYZER_WEIGHTED_PIXEL,
  ANALYZER_PIXEL_NOISE,
  ANALYZER_PIXEL_FILTER,
  ANALYZER_PIXEL_BEAM,
  ANALYZER_PIXEL_OCCUPANCY,
  ANALYZER_INVERSE,
  ANALYZER_INVERSE_WEIGHTS,
  ANALYZER_WEIGHTED_INVERSE,
  ANALYZER_INVERSE_NOISE,
  ANALYZER_INVERSE_FILTER,
  ANALYZER_INVERSE_BEAM,
  ANALYZER_MAP_LIMIT,
  ANALYZER_TRANSFORM,
  ANALYZER_TRANSFORM_WEIGHTS,
  ANALYZER_WEIGHTED_TRANSFORM,
  ANALYZER_TRANSFORM_NOISE,
  ANALYZER_TRANSFORM_FILTER,
  ANALYZER_TRANSFORM_BEAM,
  ANALYZER_SPECTRAL,
  ANALYZER_GRAPH_LIMIT,
  ANALYZER_ALM,
  ANALYZER_ALM_WEIGHTS,
  ANALYZER_ALM_NOISE,
  ANALYZER_ALM_FILTER,
  ANALYZER_ALM_BEAM,
  ANALYZER_TRANSFORM_LIMIT,
  ANALYZER_BIN_COUPLING_MATRIX,
  ANALYZER_MODE_COUPLING_MATRIX,
  ANALYZER_INVERSE_BIN_MATRIX,
  ANALYZER_INVERSE_MODE_MATRIX,
  ANALYZER_DATA_LIMIT
}
analyzer_data_t;

typedef enum {
  ANALYZER_PIX_NONE = 0,
  ANALYZER_PIX_HEALPIX,
  ANALYZER_PIX_LIMIT
}
analyzer_pix_t;

typedef enum {
  ANALYZER_PIX_LAYOUT_UNORDERED = 0,
  ANALYZER_PIX_LAYOUT_RINGED,
  ANALYZER_PIX_LAYOUT_NESTED,
  ANALYZER_PIX_LAYOUT_LIMIT
}
analyzer_pix_layout_t;

typedef enum {
  ANALYZER_TRANS_NONE = 0,
  ANALYZER_TRANS_RSHT,
  ANALYZER_TRANS_LIMIT
}
analyzer_trans_t;

typedef enum {
  ANALYZER_SEQ_SET_SKY = 0,
  ANALYZER_SEQ_MAP_SKY,
  ANALYZER_SEQ_PIXELIZE,
  ANALYZER_SEQ_MAP_PIXEL,
  ANALYZER_SEQ_TRANSFORM,
  ANALYZER_SEQ_GRAPH_TRANSFORM,
  ANALYZER_SEQ_POWER_SPECTRUM,
  ANALYZER_SEQ_GRAPH_POWER_SPECTRUM,
  ANALYZER_SEQ_INVERT,
  ANALYZER_MAP_INVERSE,
  ANALYZER_SEQ_DONE,
  ANALYZER_SEQ_ABORT,
  ANALYZER_SEQ_LIMIT
}
analyzer_sequence_t;

typedef enum {
  ANALYZER_NO_ERR = 0,
  ANALYZER_FUNCTION_PARAM_ERR = -1,
  ANALYZER_OBJECT_LIMIT_ERR = -2,
  ANALYZER_ALLOC_ERR = -3,
  ANALYZER_UNDEF_HDL_ERR = -4,
  ANALYZER_NO_FILE_ERR = -5,
  ANALYZER_DATA_MISMATCH = -6,
  ANALYZER_UNIMPLEMENTED_ERR = -7,
  ANALYZER_OBJECT_IN_USE_ERR = -8,
  ANALYZER_UNDEFINED_SIZE_ERR = -9,
  ANALYZER_INCOMPLETE_DATASET_ERR = -10,
  ANALYZER_DUPLICATE_DATA_ERR = -11,
  ANALYZER_MERGED_DATASETS_ERR = -12,
  ANALYZER_NO_DATAMAP_ERR = -13,
  ANALYZER_NO_MAPPER_ERR = -14,
  ANALYZER_NO_GRAPHER_ERR = -15,
  ANALYZER_NO_PIXELIZER_ERR = -16,
  ANALYZER_NO_TRANSFORMER_ERR = -17,
  ANALYZER_NO_SPECTRA_ERR = -18,
  ANALYZER_UNDEF_ERR = -99,
  ANALYZER_ERR_LIMIT
}
analyzer_err_t;

/* Tool/object handles... */
typedef int  analyzer_hdl;
typedef int  analyzer_source_hdl;
typedef int  analyzer_map_hdl;
typedef int  analyzer_pixelizer_hdl;
typedef int  analyzer_transform_hdl;
typedef int  analyzer_power_spect_hdl;
typedef int  analyzer_inverter_hdl;
typedef int  analyzer_graph_hdl;
typedef int  analyzer_progress_hdl;

/* Callback function types... */
typedef void   analyzer_progress_fn(void *ref, int normalized_progress);
typedef void   analyzer_sequence_fn(void *ref, analyzer_sequence_t do_step);

/*------------------------------------------------------------------------------
                              Functions
------------------------------------------------------------------------------*/

/* Object creation, destruction, and error check... */
void analyzer_intialize(void);
analyzer_hdl analyzer_create_instance(void);
analyzer_hdl analyzer_get_instance(void);
int analyzer_instance_release(analyzer_hdl ah);
int analyzer_get_last_data_reference_return_error(analyzer_hdl ah);
const char* analyzer_get_error(int err);
const char* analyzer_get_datatype(analyzer_data_t type);
int analyzer_compress_handles(void);
int analyzer_merge_handles(void);
BOOL analyzer_check_existence(analyzer_hdl ah, analyzer_data_t which);
unsigned int analyzer_count_datatypes(analyzer_hdl ah);

/* File data source management... */
analyzer_source_hdl analyzer_source_header_from_file(analyzer_hdl ah, const char *file_name, analyzer_data_t which);
analyzer_source_hdl analyzer_source_data_from_file(analyzer_source_hdl src);
analyzer_source_hdl analyzer_source_from_file(analyzer_hdl ah, const char *file_name, analyzer_data_t which);
int analyzer_get_source_type(analyzer_source_hdl src);
int analyzer_get_slice_count(analyzer_source_hdl src);
double analyzer_get_slice_min_energy(analyzer_source_hdl src, int slice);
double analyzer_get_slice_max_energy(analyzer_source_hdl src, int slice);
double analyzer_get_min_energy(analyzer_source_hdl src);
double analyzer_get_max_energy(analyzer_source_hdl src);
int analyzer_use_slices(analyzer_source_hdl src, int min_slice, int max_slice);
int analyzer_use_energies(analyzer_source_hdl src, float minE, float maxE);
int analyzer_source_release(analyzer_source_hdl src);

/* Sky creation*/
int analyzer_sky_from_source(analyzer_source_hdl src, analyzer_hdl ah);
int analyzer_sky_new_empty(analyzer_hdl ah, analyzer_data_t which, double ra_res, double dec_res);

/* Sky data manipulation... */
int analyzer_sky_set_empty(analyzer_hdl ah, analyzer_data_t which);
int analyzer_sky_add_uniform_all(analyzer_hdl ah, analyzer_data_t which, double level, analyzer_op_t operation);
int analyzer_sky_add_uniform_patch(analyzer_hdl ah, analyzer_data_t which, double dec_max, double dec_min, double ra_min, double ra_max, double level, analyzer_op_t operation);
int analyzer_sky_add_delta_point(analyzer_hdl ah, analyzer_data_t which, double ra_peak, double dec_peak, double level, analyzer_op_t operation);
int analyzer_sky_add_gaussian(analyzer_hdl ah, analyzer_data_t which, double ra_peak, double dec_peak, double std_dev, double level, analyzer_op_t operation);
int analyzer_sky_add_checkerboard(analyzer_hdl ah, analyzer_data_t which, double ra_stride, double dec_stride, double level, analyzer_op_t operation);
int analyzer_sky_add_harmonic(analyzer_hdl ah, analyzer_data_t which, int l_val, int m_val, double level, analyzer_op_t operation);
int analyzer_sky_get_resolution(analyzer_hdl ah, analyzer_data_t which, double &ra_res, double &dec_res);
int analyzer_sky_set_resolution(analyzer_hdl ah, analyzer_data_t which, double ra_res, double dec_res);

/* Mapper */
analyzer_map_hdl analyzer_create_mapmaker(void);
analyzer_map_hdl analyzer_get_mapmaker(void);
BOOL analyzer_check_map_existence(analyzer_hdl ah, analyzer_data_t which);
int analyzer_mapmaker_set_projection(analyzer_map_hdl mh, analyzer_proj_t projection);
int analyzer_mapmaker_set_map_resolution(analyzer_map_hdl mh, int x_res, int y_res);
int analyzer_mapmaker_get_resolution(analyzer_map_hdl mh, int &x_res, int &y_res);
int analyzer_mapmaker_set_datatype(analyzer_map_hdl mh, analyzer_data_t type);
int analyzer_mapmaker_set_map_type(analyzer_map_hdl mh, analyzer_map_t map);
int analyzer_mapmaker_set_hsv(analyzer_map_hdl mh, analyzer_hsv_t coloration);
int analyzer_mapmaker_map_rgb(analyzer_map_hdl mapmaker, analyzer_hdl ah, analyzer_data_t dataset);
int analyzer_mapmaker_to_bmp_file(analyzer_map_hdl mapmaker, analyzer_hdl ah, analyzer_data_t dataset, const char *file_name);
int analyzer_mapmaker_get_map(analyzer_map_hdl mapmaker, analyzer_hdl ah, analyzer_data_t dataset, unsigned char** data_map);
int analyzer_mapmaker_rgb_free(unsigned char *map_data);
int analyzer_mapmaker_release(analyzer_map_hdl mapmaker);

/* Pixelizer manipulation... */
analyzer_pixelizer_hdl analyzer_create_pixelizer(analyzer_pix_t pixelizer);
analyzer_pixelizer_hdl analyzer_get_pixelizer(void);
int analyzer_pixelizer_get_type(analyzer_pixelizer_hdl ph);
int analyzer_pix_set_layout(analyzer_pixelizer_hdl ph, analyzer_pix_layout_t layout);
//int analyzer_pix_get_max_modes(analyzer_pixelizer_hdl ph);
int analyzer_pix_get_sides(analyzer_pixelizer_hdl ph);
double analyzer_pix_get_resolution(analyzer_pixelizer_hdl ph);
int analyzer_pix_set_sides(analyzer_pixelizer_hdl ph, int sides);
int analyzer_pix_use_averaging(analyzer_pixelizer_hdl ph, BOOL yes);
int analyzer_pix_use_deviations(analyzer_pixelizer_hdl ph, BOOL yes);
int analyzer_pixelize(analyzer_pixelizer_hdl ph, analyzer_hdl ah, analyzer_data_t type);
int analyzer_pixelizer_release(analyzer_pixelizer_hdl ph);

/* Spectrum transformer... */
analyzer_transform_hdl analyzer_create_transformer(analyzer_trans_t trans);
analyzer_transform_hdl analyzer_get_transformer(void);
int analyzer_transformer_get_type(analyzer_transform_hdl th);
int analyzer_trans_get_min_index(analyzer_transform_hdl th);
int analyzer_trans_get_max_index(analyzer_transform_hdl th);
int analyzer_trans_set_spectral_indices(analyzer_transform_hdl th, int min, int max);
int analyzer_trans_get_iterations(analyzer_transform_hdl th);
int analyzer_trans_set_iterations(analyzer_transform_hdl th, int iterations);
int analyzer_transform(analyzer_transform_hdl th, analyzer_hdl ah, analyzer_data_t type);
int analyzer_transformer_release(analyzer_transform_hdl th);

/* Power Spectrum... */
analyzer_power_spect_hdl analyzer_create_power_spectrum(void);
analyzer_power_spect_hdl analyzer_get_power_spectrum(void);
int analyzer_ps_use_inverse_coupling_matrix(analyzer_power_spect_hdl ph, BOOL yes);
int analyzer_ps_set_spectral_indices(analyzer_power_spect_hdl ph, int min, int max);
int analyzer_ps_transfer_indices(analyzer_power_spect_hdl ph, analyzer_hdl ah);
int analyzer_ps_use_binning(analyzer_power_spect_hdl ph, BOOL yes, int indices_per_bin, BOOL weighted_bins);
int analyzer_ps_mask_l_values_below(analyzer_power_spect_hdl ph, int l_value);
int analyzer_calcuate_power_spectrum(analyzer_power_spect_hdl ph, analyzer_hdl ah);
int analyzer_power_spectrum_release(analyzer_power_spect_hdl ph);

/* Grapher... */
analyzer_graph_hdl analyzer_create_grapher();
analyzer_graph_hdl analyzer_get_grapher(void);
BOOL analyzer_check_graph_existence(analyzer_hdl ah, analyzer_data_t which);
int analyzer_grapher_set_resolution(analyzer_graph_hdl gh, int x_res, int y_res);
int analyzer_grapher_get_resolution(analyzer_graph_hdl gh, int &x_res, int &y_res);
int analyzer_grapher_set_datatype(analyzer_graph_hdl gh, analyzer_data_t type);
int analyzer_grapher_get_data_dimensions(analyzer_graph_hdl gh, analyzer_hdl ah);
int analyzer_grapher_get_data_dimension_size(analyzer_graph_hdl gh, analyzer_hdl ah, int dimension);
double *analyzer_grapher_get_data(analyzer_graph_hdl gh, analyzer_hdl ah);
int analyzer_grapher_graph_rgb(analyzer_graph_hdl gh, analyzer_hdl ah, analyzer_data_t dataset);
int analyzer_grapher_to_bmp_file(analyzer_graph_hdl gh, analyzer_hdl ah, analyzer_data_t dataset, const char *file_name);
int analyzer_grapher_get_graph(analyzer_graph_hdl gh, analyzer_hdl ah, analyzer_data_t dataset, unsigned char** data_graph);
int analyzer_grapher_rgb_free(unsigned char *graph_rgb);
int analyzer_grapher_data_free(double *graph_data);
int analyzer_grapher_release(analyzer_graph_hdl gh);

/* Inverter... */
analyzer_inverter_hdl analyzer_create_inverter(analyzer_transform_hdl th);
analyzer_inverter_hdl analyzer_get_inverter(void);
int analyzer_invert_data(analyzer_inverter_hdl ih, analyzer_hdl ah, analyzer_data_t type);
int analyzer_inverter_release(analyzer_inverter_hdl ih);

/* Save function... */
int analyzer_data_to_file(analyzer_hdl ah, analyzer_data_t d_type, analyzer_file_t f_type, const char *file_name);

/* Automation and status... */
analyzer_progress_hdl analyzer_set_progress_callback(void* uiObject, analyzer_progress_fn *callback);
analyzer_progress_hdl analyzer_get_progress_callback(const char* task);
const char* analyzer_get_operation(analyzer_progress_hdl ph);
int analyzer_progress_release(analyzer_progress_hdl);
double analyzer_get_progress(analyzer_progress_hdl ph);
int analyzer_set_progress_callback_reference(analyzer_progress_hdl ph, void *ref);

analyzer_sequence_t analyzer_get_next_step(analyzer_hdl ah);
int analyzer_set_automation_callback(analyzer_hdl ah, analyzer_sequence_fn *callback);
int analyzer_set_automation_callback_reference(analyzer_hdl ah, void *ref);

int analyzer_begin_auto_sequence(analyzer_hdl ah);
int analyzer_stop_auto_sequence(analyzer_hdl ah);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __ANALYZER_H__ */
