/***************************************************************************
 *   analyzer.cpp                                                          *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * The analyzer module provides a C style interface into the rest of the   *
 * backend objects.                                                        *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include <new>
#include <math.h>

#include "association.h"
#include "vectordata.h"
#include "matrixdata.h"
#include "cubedata.h"
#include "../libgraphics/mollweide.h"
#include "inputmatrixdata.h"
#include "../libgraphics/dataspectrum.h"
#include "../libgraphics/datamap.h"
#include "../libgraphics/mapper.h"
#include "../libgraphics/progress.h"
#include "pixelizer.h"
#include "healpix.h"
#include "transformer.h"
#include "rsht.h"
#include "spectrum.h"
#include "../libgraphics/grapher.h"
#include "../libgraphics/raster.h"
#include "filemanager.h"
#include "fitsmanager.h"
#include "csvmanager.h"

#include "analyzer.h"

/*------------------------------------------------------------------------------
                      Arrays of dataset objects and tools
------------------------------------------------------------------------------*/

#define MAX_DATA_HANDLES   20
#define MAX_TOOL_HANDLES   50

/* The s_dataset objects are "analyzer" type objects... */
static association   *s_dataset[MAX_DATA_HANDLES];
static fileManager   *s_filesource[MAX_DATA_HANDLES];

static Mapper        *s_mapmaker[MAX_TOOL_HANDLES];
static Pixelizer     *s_pixelizer[MAX_TOOL_HANDLES];
static Transformer   *s_transformer[MAX_TOOL_HANDLES];
static Spectrum      *s_power_spect[MAX_TOOL_HANDLES];
static Grapher       *s_graph[MAX_TOOL_HANDLES];
static Transformer   *s_inverter[MAX_TOOL_HANDLES];

static progress      *s_progress[MAX_DATA_HANDLES];

/*------------------------------------------------------------------------------
                   Error string table and functions
------------------------------------------------------------------------------*/
static int           s_last_data_error[MAX_DATA_HANDLES];

static const char analyzer_error[][80] = {
  "No error",
  "Invalid or missing function parameter",
  "Exceeded maximum object limit",
  "Failed to create object instance",
  "Invalid or undefined data handle",
  "Data file not found",
  "Incompatible data type",
  "Selected option is currently unimplemented",
  "Cannot free handle of object which is still bound to another tool",
  "Data objects necessary for the operation do not have a defined size",
  "Data objects necessary for the operation are missing or incomplete",
  "Data objects already exist in another handle instance",
  "Data and mask objects merged together and cannot be isolated",
  "Invalid or undefined map handle",
  "Invalid or undefined map maker handle",
  "Invalid or undefined graph manager handle",
  "Invalid or undefined pixelizer handle",
  "Invalid or undefined transformer handle",
  "Invalid or undefined power spectra handle",

  "Undefined error"
};

static const char analyzer_datatypes[][80] = {
  "No Data",
  "Raw Data",
  "Raw Data Mask",
  "Raw Masked Data",
  "Noise Sky Map",
  "Filter Sky Map",
  "Beam Sky Map",
  "Pixelized Data",
  "Pixelized Mask",
  "Pixelized Masked Data",
  "Pixelized Noise Map",
  "Pixelized Filter Map",
  "Pixelized Beam Map",
  "Number of Data Points per Pixel",
  "Inverse Data",
  "Inverse Mask",
  "Inversed Masked Data",
  "Inverse Noise Data",
  "Inverse Filter Data",
  "Inverse Beam Data",
  "End of Mappable Data",
  "Transformed Data",
  "Transformed Mask",
  "Transformed Masked Data",
  "Transformed Noise Data",
  "Transformed Filter Data",
  "Transformed Beam Data",
  "Power Spectrum",
  "End of Graphable Data",
  "Alm Matrix",
  "Mask Alm Matrix",
  "Noise Alm Matrix",
  "Filter Alm Matrix",
  "Beam Alm Matrix",
  "End of Transformed Data",
  "Bin-Bin Coupling Matrix",
  "Mode-Mode Coupling Matrix",
  "Inverse Bin-Bin Coupling Matrix",
  "Inverse Mode-Mode Coupling Matrix",
  "End of Data Types"
};

const char* analyzer_get_error(int err) {
  if (err >= 0)
    return analyzer_error[ANALYZER_NO_ERR];

  if (err <= ANALYZER_UNDEF_ERR)
    return analyzer_error[abs(ANALYZER_UNDEF_ERR)];

  return analyzer_error[abs(err)];
}

const char* analyzer_get_datatype(analyzer_data_t type) {
  return analyzer_datatypes[(int)type];
}

/* Needed for functions which return a pointer type, such as those which
return bipmap data... */
int analyzer_get_last_data_reference_return_error(analyzer_hdl ah) {
  int ret_value;

  /* Tricky...the probability is high that this was the primary error on the
  original call also, i.e. the analyzer handle is undefined. It does introduce
  the possibility of the wrong error being returned if an invalid handle
  is accidently passed to this function even though the original call handle
  was fine... */
  if (ah < 0 || !s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;

  ret_value = s_last_data_error[ah];
  s_last_data_error[ah] = ANALYZER_NO_ERR;

  return ret_value;
}

/*------------------------------------------------------------------------------
               All handle creation and destruction functions
------------------------------------------------------------------------------*/

void analyzer_intialize(void) {
  unsigned n = 0;
  
  for (n = 0; n < MAX_TOOL_HANDLES; ++n) {
    if (n < MAX_DATA_HANDLES) {
      s_dataset[n] = 0;
      s_filesource[n] = 0;
      s_progress[n] = 0;
    }
    s_mapmaker[n] = 0;
    s_pixelizer[n] = 0;
    s_transformer[n] = 0;
    s_power_spect[n] = 0;
    s_graph[n] = 0;
    s_inverter[n] = 0;
  }
}

/* Analyzer dataset collection (analyzer handle)... */
analyzer_hdl analyzer_create_instance(void) {
  unsigned n = 0;
  
  while (n < MAX_DATA_HANDLES && s_dataset[n])
    n++;

  if (n == MAX_DATA_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  s_dataset[n] = new(std::nothrow) association();

  if (s_dataset[n])
    return n;
  else
    return ANALYZER_ALLOC_ERR;
}

analyzer_hdl analyzer_get_instance(void) {
  unsigned n = 0;

  if (!s_dataset[n])
    return ANALYZER_UNDEF_HDL_ERR;

  while (n < MAX_DATA_HANDLES && s_dataset[n])
    n++;

  if (n == MAX_DATA_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_dataset[n-1])
    return ANALYZER_ALLOC_ERR;
   
  return n-1;
   
}

int analyzer_instance_release(analyzer_hdl ah) {
  if (ah < 0 || !s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;

  delete s_dataset[ah];
  s_dataset[ah] = 0;
  analyzer_compress_handles();
  return ANALYZER_NO_ERR;
}

int analyzer_compress_handles(void) {
  int n = MAX_DATA_HANDLES - 1;
  int compressed = 0;
  while(n > 0) {
    if (s_dataset[n] && !s_dataset[n-1]) {
      s_dataset[n-1]->merge(*( s_dataset[n]));
      s_dataset[n] = 0;
      compressed++;
    }
    n--;
  }
  return compressed;
}

BOOL analyzer_check_existence(analyzer_hdl ah, analyzer_data_t which) {
  if (ah < 0 || !s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;
  
  return (s_dataset[ah]->exists((FILETYPE)which));
}

unsigned int analyzer_count_datatypes(analyzer_hdl ah) {
  if (ah < 0 || s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;
  
  unsigned int count = 0;
  analyzer_data_t types = ANALYZER_NONE;
  
  while (types != ANALYZER_DATA_LIMIT) {
    if (analyzer_check_existence(ah, types))
      count |= 1 << ((int) types - 1);
    types = (analyzer_data_t)((int)types + 1);
  }
  
  return count;
}

int analyzer_merge_handles(void) {
  int hdl = analyzer_get_instance();
  int merged = 0;
  while (hdl > 0) {
    s_dataset[hdl-1]->merge(*(s_dataset[hdl]),false);
    analyzer_instance_release(hdl);
    hdl = analyzer_get_instance();
    merged++;
  }

  return merged;
}

/* Analyzer file source... */
analyzer_source_hdl analyzer_source_from_file(analyzer_hdl ah, const char *file_name, analyzer_data_t which) {
  unsigned n = 0, m = 0;

  if (!file_name)
    return ANALYZER_FUNCTION_PARAM_ERR;

  if (ah < 0 || !s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;

  while (n < MAX_DATA_HANDLES && s_filesource[n])
    n++;

  if (n == MAX_DATA_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (strstr(file_name,".fits"))
    s_filesource[n] = new(std::nothrow) fitsManager(s_dataset[ah], file_name);
  else if (strstr(file_name,".csv"))
    s_filesource[n] = new(std::nothrow) csvManager(s_dataset[ah],file_name);

  if (!s_filesource[n])
    return ANALYZER_ALLOC_ERR;

  if (s_filesource[n]->error()) {
    printf("%s\n",s_filesource[n]->errorDescription().c_str());
    delete s_filesource[n];
    s_filesource[n] = 0;
    return ANALYZER_ALLOC_ERR;
  }
  
  if ((analyzer_data_t)(s_filesource[n]->fileDataType()) != which)
    return ANALYZER_DATA_MISMATCH;

  if ((analyzer_data_t)(s_filesource[n]->fileDataType()) != ANALYZER_NONE) {
    m = analyzer_get_instance();
    if (m < 0 || !s_dataset[m]) // check that association was created without error
      return ANALYZER_UNDEF_HDL_ERR;

    // load data set into association
    s_dataset[m]->addData(s_filesource[n]->data());
    analyzer_source_release(n);
    return n;
  }
  else {
    delete s_filesource[n];
    s_filesource[n] = 0;
    return ANALYZER_NO_FILE_ERR;
  }
}

analyzer_source_hdl analyzer_source_header_from_file(analyzer_hdl ah, const char* file_name, analyzer_data_t which) {
  unsigned n = 0;

  if (!file_name)
    return ANALYZER_FUNCTION_PARAM_ERR;

  if (ah < 0 || !s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;

  while (n < MAX_DATA_HANDLES && s_filesource[n])
    n++;

  if (n == MAX_DATA_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (strstr(file_name,".fits"))
    s_filesource[n] = new(std::nothrow) fitsManager(s_dataset[ah],file_name);
  else if (strstr(file_name,".csv"))
    s_filesource[n] = new(std::nothrow) csvManager(s_dataset[ah],file_name);

  if (!s_filesource[n])
    return ANALYZER_ALLOC_ERR;

  if (s_filesource[n]->error()) {
    printf("%s\n",s_filesource[n]->errorDescription().c_str());
    delete s_filesource[n];
    s_filesource[n] = 0;
    return ANALYZER_ALLOC_ERR;
  }
  
  return n;
}

analyzer_source_hdl analyzer_source_data_from_file(analyzer_source_hdl src) {
  unsigned n = 0;

  
  if ((analyzer_data_t)(s_filesource[src]->fileDataType()) != ANALYZER_NONE) {
    n = analyzer_get_instance();
    if (n < 0 || !s_dataset[n]) // check that association was created without error
      return ANALYZER_UNDEF_HDL_ERR;

    // load data set into association
    s_dataset[n]->addData(s_filesource[src]->data());
    analyzer_source_release(src);
    return n;
  }
  else {
    delete s_filesource[src];
    s_filesource[src] = 0;
    return ANALYZER_NO_FILE_ERR;
  }
}

int analyzer_source_release(analyzer_source_hdl sh) {
  if (sh < 0 || !s_filesource[sh])
    return ANALYZER_UNDEF_HDL_ERR;

  delete s_filesource[sh];
  s_filesource[sh] = 0;
  return ANALYZER_NO_ERR;
}

/* Analyzer mapper... */
analyzer_map_hdl analyzer_create_mapmaker() {
  unsigned n = 0;

  while (n < MAX_TOOL_HANDLES && s_mapmaker[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  s_mapmaker[n] = new(std::nothrow) Mapper();
  if (!s_mapmaker[n])
    return ANALYZER_ALLOC_ERR;
   
  return n;
}

analyzer_map_hdl analyzer_get_mapmaker() {
  unsigned n = 0;

  if (!s_mapmaker[n])
    return ANALYZER_NO_MAPPER_ERR;

  while (n < MAX_TOOL_HANDLES && s_mapmaker[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_mapmaker[n-1])
   return ANALYZER_ALLOC_ERR;
   
  return n - 1;
}

BOOL analyzer_check_map_existence(analyzer_hdl ah, analyzer_data_t which) {
  if (ah < 0 || !s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;
  
  return (s_dataset[ah]->exists((ASSOCIATEDMAP)which));
}

int analyzer_mapmaker_set_projection(analyzer_map_hdl mh, analyzer_proj_t projection) {
  if (mh < 0 || !s_mapmaker[mh])
    return ANALYZER_UNDEF_HDL_ERR;
   
  switch(projection) {
    case ANALYZER_PROJ_MOLLWEIDE:
      analyzer_mapmaker_release(mh);
      s_mapmaker[mh] = 0;
      s_mapmaker[mh] = new(std::nothrow) MollweideMapper();
      if (!s_mapmaker[mh])
        return ANALYZER_ALLOC_ERR;
      break;
    case ANALYZER_PROJ_FLAT:
    case ANALYZER_PROJ_ATOFF:
    case ANALYZER_PROJ_GNOMONIC:
    default:
     return ANALYZER_UNIMPLEMENTED_ERR;
  }
  return ANALYZER_UNIMPLEMENTED_ERR;
}

int analyzer_mapmaker_release(analyzer_map_hdl mh) {
  if (mh < 0 || !s_mapmaker[mh])
    return ANALYZER_UNDEF_HDL_ERR;

  delete s_mapmaker[mh];
  s_mapmaker[mh] = 0;
  return ANALYZER_NO_ERR;
}

/* Analyzer pixelizer... */
analyzer_pixelizer_hdl analyzer_create_pixelizer(analyzer_pix_t pixelizer) {
  unsigned n = 0;

  while (n < MAX_TOOL_HANDLES && s_pixelizer[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  switch (pixelizer) {
    case ANALYZER_PIX_HEALPIX:
      s_pixelizer[n] = new(std::nothrow) HealPIXPixelizer();
      if (!s_pixelizer[n])
        return ANALYZER_ALLOC_ERR;
      break;
    default:
      return ANALYZER_UNIMPLEMENTED_ERR;
  }

  return n;
}

analyzer_pixelizer_hdl analyzer_get_pixelizer(void) {
  unsigned n = 0;

  if (!s_pixelizer[n])
    return ANALYZER_NO_PIXELIZER_ERR;

  while (n < MAX_TOOL_HANDLES && s_pixelizer[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_pixelizer[n-1])
    return ANALYZER_ALLOC_ERR;

  return n-1;
}

int analyzer_pixelizer_release(analyzer_pixelizer_hdl ph) {
  if (ph < 0 || !s_pixelizer[ph])
    return ANALYZER_UNDEF_HDL_ERR;

  delete s_pixelizer[ph];
  s_pixelizer[ph] = 0;
  return ANALYZER_NO_ERR;
}

/* Analyzer transformer... */
analyzer_transform_hdl analyzer_create_transformer(analyzer_trans_t trans) {
  unsigned n = 0;

  while (n < MAX_TOOL_HANDLES && s_transformer[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  switch (trans) {
    case ANALYZER_TRANS_RSHT:
      s_transformer[n] = new(std::nothrow) RshtTransformer();
      if (!s_transformer[n])
        return ANALYZER_ALLOC_ERR;
      break;
    default:
      return ANALYZER_UNIMPLEMENTED_ERR;
  }

  return n;
}

analyzer_transform_hdl analyzer_get_transformer(void) {
  unsigned n = 0;

  if (!s_transformer[n])
    return ANALYZER_NO_TRANSFORMER_ERR;

  while (n < MAX_TOOL_HANDLES && s_transformer[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_transformer[n-1])
    return ANALYZER_ALLOC_ERR;

  return n - 1;
}

int analyzer_transformer_release(analyzer_transform_hdl th) {
  unsigned n = 0;

  if (th < 0 || !s_transformer[th])
    return ANALYZER_UNDEF_HDL_ERR;

  while (n < MAX_TOOL_HANDLES && s_inverter[n] != s_transformer[th])
    n++;

  if (n != MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_IN_USE_ERR;

  delete s_transformer[th];
  s_transformer[th] = 0;
  return ANALYZER_NO_ERR;
}

/* Analyzer power spectrum... */
analyzer_power_spect_hdl analyzer_create_power_spectrum(void) {
  unsigned n = 0;

  while (n < MAX_TOOL_HANDLES && s_power_spect[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  s_power_spect[n] = new(std::nothrow) Spectrum();
  if (!s_power_spect[n])
    return ANALYZER_ALLOC_ERR;

  return n;
}

analyzer_power_spect_hdl analyzer_get_power_spectrum(void) {
  unsigned n = 0;

  if (!s_power_spect[n])
    return ANALYZER_NO_SPECTRA_ERR;

  while (n < MAX_TOOL_HANDLES && s_power_spect[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_power_spect[n-1])
    return ANALYZER_ALLOC_ERR;

  return n - 1;
}

int analyzer_power_spectrum_release(analyzer_power_spect_hdl ph) {
  if (ph < 0 || !s_power_spect[ph])
    return ANALYZER_UNDEF_HDL_ERR;

  delete s_power_spect[ph];
  s_power_spect[ph] = 0;
  return ANALYZER_NO_ERR;
}

/*Analyzer grapher... */
analyzer_graph_hdl analyzer_create_grapher() {
  unsigned n = 0;

  while (n < MAX_TOOL_HANDLES && s_graph[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  s_graph[n] = new(std::nothrow) Grapher();
  if (!s_graph[n])
    return ANALYZER_ALLOC_ERR;

  return n;
}

analyzer_graph_hdl analyzer_get_grapher(void) {
  unsigned n = 0;

  if (!s_graph[n])
    return ANALYZER_NO_GRAPHER_ERR;

  while (n < MAX_TOOL_HANDLES && s_graph[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_graph[n-1])
    return ANALYZER_ALLOC_ERR;

  return n - 1;
}

BOOL analyzer_check_graph_existence(analyzer_hdl ah, analyzer_data_t which) {
  if (ah < 0 || !s_dataset[ah])
    return ANALYZER_UNDEF_HDL_ERR;
  
  return (s_dataset[ah]->exists((ASSOCIATEDSPECTRUM)which));
}

int analyzer_grapher_release(analyzer_graph_hdl gh) {
  if (gh < 0 || !s_graph[gh])
    return ANALYZER_UNDEF_HDL_ERR;

  delete s_graph[gh];
  s_graph[gh] = 0;
  return ANALYZER_NO_ERR;
}

/* Analyzer inverse data: currently just an alias for an existing transformer,
but that may change... */
analyzer_inverter_hdl analyzer_create_inverter(analyzer_transform_hdl th) {
  unsigned n = 0;

  if (th < 0 || !s_transformer[th])
    return ANALYZER_FUNCTION_PARAM_ERR;

  while (n < MAX_TOOL_HANDLES && s_inverter[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  s_inverter[n] = s_transformer[th];
  return n;
}

analyzer_inverter_hdl analyzer_get_inverter(void) {
  unsigned n = 0;

  while (n < MAX_TOOL_HANDLES && s_inverter[n])
    n++;

  if (n == MAX_TOOL_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_inverter[n-1])
    return ANALYZER_ALLOC_ERR;
   
  return n - 1;
}

int analyzer_inverter_release(analyzer_inverter_hdl ih) {
  if (ih < 0 || !s_inverter[ih])
    return ANALYZER_UNDEF_HDL_ERR;

  s_inverter[ih] = 0;
  return ANALYZER_NO_ERR;
}

/*------------------------------------------------------------------------------
                   Handle object configuration functions
------------------------------------------------------------------------------*/
/* File source functions... */
int analyzer_get_source_type(analyzer_source_hdl sh) {
  if (sh < 0 || !s_filesource[sh])
    return ANALYZER_SRC_UNKNOWN;

  return (int)s_filesource[sh]->observatory();
}

int analyzer_get_slice_count(analyzer_source_hdl sh) {
  if (sh < 0 || !s_filesource[sh])
    return ANALYZER_UNDEF_HDL_ERR;

  return s_filesource[sh]->slices();
}

/* These are a problem: I want to be able to view slice information BEFORE the
entire data set is loaded into memory... Probabaly need to implement an
"inputFile class. */
double analyzer_get_slice_min_energy(analyzer_source_hdl sh, int slice) {
  fileManager *fm = 0;

  if (sh < 0 || !(fm = s_filesource[sh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (slice < 0 || slice >= fm->slices())
    return ANALYZER_FUNCTION_PARAM_ERR;

  return (double)fm->sliceEnergyMin(slice);
}

double analyzer_get_slice_max_energy(analyzer_source_hdl sh, int slice) {
  fileManager *fm = 0;

  if (sh < 0 || !(fm = s_filesource[sh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (slice < 0 || slice >= fm->slices())
    return ANALYZER_FUNCTION_PARAM_ERR;

  return (double)fm->sliceEnergyMax(slice);
}

double analyzer_get_min_energy(analyzer_source_hdl sh) {
  fileManager *fm = 0;
  
  if (sh < 0 || !(fm = s_filesource[sh]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  return (double)fm->min_energy();
}

double analyzer_get_max_energy(analyzer_source_hdl sh) {
  fileManager *fm = 0;
  
  if (sh < 0 || !(fm = s_filesource[sh]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  return (double)fm->max_energy();
}

int analyzer_use_slices(analyzer_source_hdl sh, int minSlice, int maxSlice) {
  fileManager *fm = 0;

  if (sh < 0 || !(fm = s_filesource[sh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (minSlice >= maxSlice)
    return ANALYZER_FUNCTION_PARAM_ERR;

  if (minSlice < 0 || maxSlice - minSlice > fm->slices())
    return ANALYZER_FUNCTION_PARAM_ERR;

  fm->minSlice(minSlice);
  fm->maxSlice(maxSlice);

  return ANALYZER_NO_ERR;
}

int analyzer_use_energies(analyzer_source_hdl sh, float minE, float maxE) {
  fileManager *fm = 0;

  if (sh < 0 || !(fm = s_filesource[sh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (minE >= maxE)
    return ANALYZER_FUNCTION_PARAM_ERR;

  if (minE < 0 || maxE < 0 || minE > maxE)
    return ANALYZER_FUNCTION_PARAM_ERR;

  fm->min_energy(minE);
  fm->max_energy(maxE);

  return ANALYZER_NO_ERR;
}

int analyzer_sky_from_source(analyzer_source_hdl sh, analyzer_hdl ah) {
  association        *collection = 0;
  fileManager        *fm = 0;
  matrixData<double> *md = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (sh < 0 || !(fm = s_filesource[sh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (fm->fileDataType() != fileType::InputData)
    return ANALYZER_FUNCTION_PARAM_ERR;

  md = (matrixData<double>*)fm->data();
  if (!md)
    return ANALYZER_ALLOC_ERR;

  collection->addData(md);

  return ANALYZER_NO_ERR;
}

/* Sky functions (inputMatrix) */
int analyzer_sky_new_empty(analyzer_hdl ah, analyzer_data_t which, double ra_res, double dec_res) {
  association *collection = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (ra_res <= 0 || dec_res <= 0)
    return ANALYZER_FUNCTION_PARAM_ERR;

  /* convert resolutions to number of bins
     copy from inputMatrixdata */
  if (ra_res < 0.000001 || dec_res < 0.000001)
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  int x = (int)(360.0 / ra_res);
  int y = (int)(180.0 / dec_res);

  collection->createEmptyDataSet(FILETYPE(which),ra_res,dec_res);
  
  /* set up callback information, if available */
//  if (collection->showProgress()) {
//    collection->getData(FILETYPE(which))->setProgressFunc(collection->userInterface(),collection->updateFunction());
//    collection->getData(FILETYPE(which))->showProgress(true);
//  }
  
  /* initialize angular resolution */
  ((matrixData<double>*)(collection->getData(FILETYPE(which))))->RARes(ra_res);
  ((matrixData<double>*)(collection->getData(FILETYPE(which))))->DecRes(dec_res);;
  
  /* initialize the data set to zero */
  ((matrixData<double>*)(collection->getData(FILETYPE(which))))->initialize();

  return ANALYZER_NO_ERR;
}

int analyzer_sky_set_empty(analyzer_hdl ah, analyzer_data_t which) {
  association        *collection = 0;
  matrixData<double> *current = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current = (matrixData<double>*)collection->getData(fileType::InputData);
      collection->workSpace(current->RARes(),current->DecRes());
      collection->workSpaceTo(fileType::InputData,Replace);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current = (matrixData<double>*)collection->getData(fileType::InputWeights);
      collection->workSpace(current->RARes(),current->DecRes());
      collection->workSpaceTo(fileType::InputWeights,Replace);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_sky_add_uniform_all(analyzer_hdl ah, analyzer_data_t which, double level, analyzer_op_t operation) {
  association        *collection = 0;
  inputMatrixData    *workspace = 0;
  matrixData<double> *current = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputData);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(level);
      collection->workSpaceTo(fileType::InputData,(M_OP)operation);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputWeights);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(level);
      collection->workSpaceTo(fileType::InputWeights,(M_OP)operation);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_sky_add_uniform_patch (analyzer_hdl ah, analyzer_data_t which, double dec_max, double dec_min, double ra_min, double ra_max, double level, analyzer_op_t operation) {
  association        *collection = 0;
  inputMatrixData    *workspace = 0;
  matrixData<double> *current = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputData);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(dec_max,dec_min,ra_max,ra_min,level);
      collection->workSpaceTo(fileType::InputData,(M_OP)operation);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputWeights);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(dec_max,dec_min,ra_max,ra_min,level);
      collection->workSpaceTo(fileType::InputWeights,(M_OP)operation);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_sky_add_delta_point(analyzer_hdl ah, analyzer_data_t which, double ra_peak, double dec_peak, double level, analyzer_op_t operation) {
  association        *collection = 0;
  inputMatrixData    *workspace = 0;
  matrixData<double> *current = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputData);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(ra_peak,dec_peak,0,level);
      collection->workSpaceTo(fileType::InputData,(M_OP)operation);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputWeights);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(ra_peak,dec_peak,0,level);
      collection->workSpaceTo(fileType::InputWeights,(M_OP)operation);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_sky_add_gaussian(analyzer_hdl ah, analyzer_data_t which, double ra_peak, double dec_peak, double std_dev, double level, analyzer_op_t operation) {
  association        *collection = 0;
  inputMatrixData    *workspace = 0;
  matrixData<double> *current = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputData);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(ra_peak,dec_peak,std_dev,level);
      collection->workSpaceTo(fileType::InputData,(M_OP)operation);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputWeights);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(ra_peak,dec_peak,level,std_dev);
      collection->workSpaceTo(fileType::InputWeights,(M_OP)operation);
      break;
    default:
       return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_sky_add_checkerboard(analyzer_hdl ah, analyzer_data_t which, double ra_stride, double dec_stride, double level, analyzer_op_t operation) {
  association        *collection = 0;
  inputMatrixData    *workspace = 0;
  matrixData<double> *current = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputData);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(ra_stride, dec_stride, level);
      collection->workSpaceTo(fileType::InputData,(M_OP)operation);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputWeights);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(ra_stride, dec_stride, level);
      collection->workSpaceTo(fileType::InputWeights,(M_OP)operation);
      break;
    default:
       return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_sky_add_harmonic(analyzer_hdl ah, analyzer_data_t which, int l_val, int m_val, double level, analyzer_op_t operation) {
  association        *collection = 0;
  inputMatrixData    *workspace = 0;
  matrixData<double> *current = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputData);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(l_val,m_val,level);
      collection->workSpaceTo(fileType::InputData,(M_OP)operation);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;

      current   = (matrixData<double>*)collection->getData(fileType::InputWeights);
      workspace = collection->workSpace(current->RARes(),current->DecRes());
      workspace->create(l_val,m_val,level);
      collection->workSpaceTo(fileType::InputWeights,(M_OP)operation);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_sky_get_resolution(analyzer_hdl ah, analyzer_data_t which, double &ra_res, double &dec_res) {
  association *collection = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      ra_res = collection->inputData()->RARes();
      dec_res = collection->inputData()->DecRes();
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      ra_res = collection->inputWeights()->RARes();
      dec_res = collection->inputWeights()->DecRes();
      break;
    case ANALYZER_SKY_NOISE:
      if (!collection->exists(fileType::InputNoise))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      ra_res = collection->inputNoise()->RARes();
      dec_res = collection->inputNoise()->DecRes();
      break;
    case ANALYZER_SKY_FILTER:
      if (!collection->exists(fileType::InputFilter))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      ra_res = collection->inputFilter()->RARes();
      dec_res = collection->inputFilter()->DecRes();
      break;
    case ANALYZER_SKY_BEAM:
      if (!collection->exists(fileType::InputBeam))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      ra_res = collection->inputBeam()->RARes();
      dec_res = collection->inputBeam()->DecRes();
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }
   
  return ANALYZER_NO_ERR;
}

int analyzer_sky_set_resolution(analyzer_hdl ah, analyzer_data_t which, double ra_res, double dec_res)
{
  association *collection = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (which) {
    case ANALYZER_SKY:
      if (!collection->exists(fileType::InputData))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      collection->inputData()->RARes(ra_res);
      collection->inputData()->DecRes(dec_res);
      break;
    case ANALYZER_SKY_WEIGHTS:
      if (!collection->exists(fileType::InputWeights))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      collection->inputWeights()->RARes(ra_res);
      collection->inputWeights()->DecRes(dec_res);
      break;
    case ANALYZER_SKY_NOISE:
      if (!collection->exists(fileType::InputNoise))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      collection->inputNoise()->RARes(ra_res);
      collection->inputNoise()->DecRes(dec_res);
      break;
    case ANALYZER_SKY_FILTER:
      if (!collection->exists(fileType::InputFilter))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      collection->inputFilter()->RARes(ra_res);
      collection->inputFilter()->DecRes(dec_res);
      break;
    case ANALYZER_SKY_BEAM:
      if (!collection->exists(fileType::InputBeam))
        return ANALYZER_UNDEFINED_SIZE_ERR;
       
      collection->inputBeam()->RARes(ra_res);
      collection->inputBeam()->DecRes(dec_res);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }
   
  return ANALYZER_NO_ERR;

}

/* Mapper functions... */
int analyzer_mapmaker_set_map_resolution(analyzer_map_hdl mh, int x_res, int y_res) {
  Mapper *mapmaker = 0;

  if (mh < 0 || !(mapmaker = s_mapmaker[mh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (!x_res || ! y_res)
    return ANALYZER_FUNCTION_PARAM_ERR;

  mapmaker->width(x_res);
  mapmaker->height(y_res);

  return ANALYZER_NO_ERR;
}

int analyzer_mapmaker_get_resolution(analyzer_map_hdl mh, int &x_res, int &y_res) {
  Mapper *mapmaker = 0;
   
  if (mh < 0 || !(mapmaker = s_mapmaker[mh]))
    return ANALYZER_UNDEF_HDL_ERR;

  x_res = mapmaker->width();
  y_res = mapmaker->height();
  
  return ANALYZER_NO_ERR;
}

int analyzer_mapmaker_set_datatype(analyzer_map_hdl mh, analyzer_data_t type) {
  Mapper *mapmaker = 0;
   
  if (mh < 0 || !(mapmaker = s_mapmaker[mh]))
    return ANALYZER_UNDEF_HDL_ERR;
   
  mapmaker->display((FILETYPE)type);
   
  return 0;
}

int analyzer_mapmaker_set_map_type(analyzer_map_hdl mh, analyzer_map_t map) {
  Mapper *mapmaker = 0;

  if (mh < 0 || !(mapmaker = s_mapmaker[mh]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (map) {
    case ANALYZER_MAP_BASELESS:
      return ANALYZER_UNIMPLEMENTED_ERR;
    case ANALYZER_MAP_ASTRONOMICAL:
      mapmaker->orientation(Astronomical);
      break;
    case ANALYZER_MAP_TERRESTRIAL:
      mapmaker->orientation(Terrestrial);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }

  return ANALYZER_NO_ERR;
}

int analyzer_mapmaker_set_hsv(analyzer_map_hdl mh, analyzer_hsv_t coloration) {
  Mapper *mapmaker = 0;

  if (mh < 0 || !(mapmaker = s_mapmaker[mh]))
    return ANALYZER_UNDEF_HDL_ERR;

  switch (coloration) {
    case ANALYZER_HSV_LUMINANCE:
      return ANALYZER_UNIMPLEMENTED_ERR;
    case ANALYZER_HSV_RGB_LINEAR:
      mapmaker->colorScheme(Linear);
      break;
    case ANALYZER_HSV_RGB_LOG:
      mapmaker->colorScheme(Log);
      break;
    case ANALYZER_HSV_RGB_SUPERLOG:
      mapmaker->colorScheme(SuperLog);
      break;
    default:
      return ANALYZER_FUNCTION_PARAM_ERR;
  }

 return ANALYZER_NO_ERR;
}

int analyzer_mapmaker_get_map(analyzer_map_hdl mh, analyzer_hdl ah, analyzer_data_t dataset, unsigned char** data_map) {
  association *collection = 0;
  Mapper *mapmaker = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;
   
  if (mh < 0 || !(mapmaker = s_mapmaker[mh]))
    return ANALYZER_UNDEF_HDL_ERR;

  *data_map = 0;
  switch (dataset) {
    case ANALYZER_SKY:
      *data_map = collection->inputDataMap()->transferRGBData();
      break;
    case ANALYZER_SKY_WEIGHTS:
      *data_map = collection->inputWeightsMap()->transferRGBData();
      break;
    case ANALYZER_WEIGHTED_SKY:
      *data_map = collection->inputMap()->transferRGBData();
      break;
    case ANALYZER_PIXEL:
      *data_map = collection->pixelDataMap()->transferRGBData();
      break;
    case ANALYZER_PIXEL_WEIGHTS:
      *data_map = collection->pixelWeightsMap()->transferRGBData();
      break;
    case ANALYZER_WEIGHTED_PIXEL:
      *data_map = collection->pixelMap()->transferRGBData();
      break;
    case ANALYZER_PIXEL_OCCUPANCY:
      *data_map = collection->pixelOccupancyMap()->transferRGBData();
      break;
    case ANALYZER_INVERSE:
      *data_map = collection->invDataMap()->transferRGBData();
      break;
    case ANALYZER_INVERSE_WEIGHTS:
      *data_map = collection->invWeightsMap()->transferRGBData();
      break;
    case ANALYZER_WEIGHTED_INVERSE:
      *data_map = collection->invMap()->transferRGBData();
      break;
    case ANALYZER_PIXEL_NOISE:
      *data_map = collection->pixelNoiseMap()->transferRGBData();
      break;
    case ANALYZER_PIXEL_FILTER:
      *data_map = collection->pixelFilterMap()->transferRGBData();
      break;
    case ANALYZER_PIXEL_BEAM:
      *data_map = collection->pixelBeamMap()->transferRGBData();
      break;
    default:
     *data_map = 0;
  }
   
  if (*data_map == 0)
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  return ANALYZER_NO_ERR;
}

int analyzer_mapmaker_to_bmp_file(analyzer_map_hdl mh, analyzer_hdl ah, analyzer_data_t dataset, const char *file_name) {
  association *collection = 0;
  Mapper *mapmaker = 0;
  unsigned char *bitmap = 0;
  Raster *rast = 0;

  if (!file_name)
    return ANALYZER_FUNCTION_PARAM_ERR;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;
   
  if (mh < 0 || !(mapmaker = s_mapmaker[mh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (analyzer_mapmaker_get_map(mh, ah, dataset, &bitmap) < 0)
   return ANALYZER_NO_DATAMAP_ERR;
   
  rast = new(std::nothrow) Raster(mapmaker->width(),mapmaker->height(),3,bitmap);
  if (!rast)
    return ANALYZER_ALLOC_ERR;

  rast->toBitmapFile(file_name);

  delete rast;
  delete[] bitmap;

  return ANALYZER_NO_ERR;
}

int analyzer_mapmaker_map_rgb(analyzer_map_hdl mh, analyzer_hdl ah, analyzer_data_t dataset) {
  association   *collection = 0;
  Mapper        *mapmaker = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (mh < 0 || !(mapmaker = s_mapmaker[mh])) {
    s_last_data_error[ah] = ANALYZER_UNDEF_HDL_ERR;
    return ANALYZER_UNDEF_HDL_ERR;
  }

  if (!dataset || dataset >= ANALYZER_MAP_LIMIT) {
    s_last_data_error[ah] = ANALYZER_FUNCTION_PARAM_ERR;
    return ANALYZER_FUNCTION_PARAM_ERR;
  }

  if (!collection->exists((FILETYPE)dataset)) {
    s_last_data_error[ah] = ANALYZER_INCOMPLETE_DATASET_ERR;
    return  ANALYZER_INCOMPLETE_DATASET_ERR;
  }

  try {
  collection->generateMap((FILETYPE)dataset);
  }
  catch (ERRORCODES error) {
    s_last_data_error[ah] = ANALYZER_NO_FILE_ERR;
    return ANALYZER_NO_FILE_ERR;
  }
   
  return ANALYZER_NO_ERR;
}

int analyzer_mapmaker_rgb_free(unsigned char *map_data) {
  if (!map_data)
    return ANALYZER_FUNCTION_PARAM_ERR;

  delete[] map_data;

  return ANALYZER_NO_ERR;
}

/* Pixelizer functions... */
int analyzer_pixelizer_get_type(analyzer_pixelizer_hdl ph) {
  Pixelizer *pix = 0;
  
  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  return (int)pix->pixelizerScheme();
}

int analyzer_pix_set_layout(analyzer_pixelizer_hdl ph, analyzer_pix_layout_t layout) {
  Pixelizer *pix = 0;

  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (analyzer_pixelizer_get_type(ph) == ANALYZER_PIX_HEALPIX) {
    switch (layout) {
      case ANALYZER_PIX_LAYOUT_UNORDERED:
        pix->pixelLayout(Unordered);
        break;
      case ANALYZER_PIX_LAYOUT_NESTED:
        pix->pixelLayout(Nest);
        break;
      case ANALYZER_PIX_LAYOUT_RINGED:
        pix->pixelLayout(Ring);
        break;
      default:
        return ANALYZER_UNIMPLEMENTED_ERR;
    }
  }

 return ANALYZER_NO_ERR;
}

int analyzer_pix_get_sides(analyzer_pixelizer_hdl ph) {
  Pixelizer *pix = 0;
  
  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  return pix->scale();
}

double analyzer_pix_get_resolution(analyzer_pixelizer_hdl ph) {
  Pixelizer *pix = 0;
  
  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

 return 360.0/(pix->scale() * sqrt(12.0 * M_PI));
}

int analyzer_pix_set_sides(analyzer_pixelizer_hdl ph, int sides) {
  Pixelizer *pix = 0;

  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (sides < 0)
    return ANALYZER_FUNCTION_PARAM_ERR;

  pix->scale(sides);

  return ANALYZER_NO_ERR;
}

int analyzer_pix_use_averaging(analyzer_pixelizer_hdl ph, BOOL yes) {
  Pixelizer *pix = 0;

  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  pix->average(yes);

 return ANALYZER_NO_ERR;
}

int analyzer_pix_use_deviations(analyzer_pixelizer_hdl ph, BOOL yes) {
  Pixelizer *pix = 0;

  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  pix->variance(yes);

  return ANALYZER_NO_ERR;
}

int analyzer_pixelize(analyzer_pixelizer_hdl ph, analyzer_hdl ah, analyzer_data_t type) {
  association *collection = 0;
  Pixelizer   *pix = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (ph < 0 || !(pix = s_pixelizer[ph]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  if (!collection->exists((FILETYPE)type))
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  try {
  collection->generatePixelData(pix,(FILETYPE) type);
  }
  catch (ERRORCODES error) {
    return ANALYZER_INCOMPLETE_DATASET_ERR;
  }

  return ANALYZER_NO_ERR;
}

/* Spectrum transformer... */
/* Values from transformerdlg.ui... */
#define MAX_TRANSFORMER_INDICES        12287
#define MAX_TRANSFORMER_INTERATIONS    6

int analyzer_transformer_get_type(analyzer_transform_hdl th) {
  Transformer *trans = 0;
  
  if (th < 0 || !(trans = s_transformer[th]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  return (int)trans->transformerScheme();
}

int analyzer_trans_get_min_index(analyzer_transform_hdl th) {
  Transformer *trans = 0;
  
  if (th < 0 || !(trans = s_transformer[th]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  return trans->minIndex();
}

int analyzer_trans_get_max_index(analyzer_transform_hdl th) {
  Transformer *trans = 0;
  
  if (th < 0 || !(trans = s_transformer[th]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  return trans->maxIndex();
}

/* Default values from QT3 gui: (0, 3 * pixelizer sides) */
int analyzer_trans_set_spectral_indices(analyzer_transform_hdl th, int min, int max) {
  Transformer *trans = 0;

  if (th < 0 || !(trans = s_transformer[th]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (min < 0 || max > MAX_TRANSFORMER_INDICES || max < min)
    return ANALYZER_FUNCTION_PARAM_ERR;

  trans->maxIndex(max);
  trans->minIndex(min);

  return ANALYZER_NO_ERR;
}

int analyzer_trans_get_iterations(analyzer_transform_hdl th) {
  Transformer *trans = 0;

  if (th < 0 || !(trans = s_transformer[th]))
    return ANALYZER_UNDEF_HDL_ERR;

 return trans->iterations();
}

int analyzer_trans_set_iterations(analyzer_transform_hdl th, int iterations) {
  Transformer *trans = 0;

  if (th < 0 || !(trans = s_transformer[th]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (iterations <= 0 || iterations > MAX_TRANSFORMER_INTERATIONS)
    return ANALYZER_FUNCTION_PARAM_ERR;

  trans->iterations(iterations);

  return ANALYZER_NO_ERR;
}

int analyzer_transform(analyzer_transform_hdl th, analyzer_hdl ah, analyzer_data_t type) {
  association *collection = 0;
  Transformer *trans = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (th < 0 || !(trans = s_transformer[th]))
    return ANALYZER_UNDEF_HDL_ERR;
  
  if (!collection->exists((FILETYPE)type))
    return ANALYZER_UNDEF_HDL_ERR;

  if (!collection->generateTransformedData(trans,(FILETYPE) type))
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  return ANALYZER_NO_ERR;
}

/* Power Spectrum... */
#define MAX_INDICES_PER_BIN   100
#define MAX_MASK_INDICES      20

int analyzer_ps_use_inverse_coupling_matrix(analyzer_power_spect_hdl ph, BOOL yes) {
  Spectrum *spect = 0;

  if (ph < 0 || !(spect = s_power_spect[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  spect->computeInverse(yes);

  return ANALYZER_NO_ERR;
}

int analyzer_ps_set_spectral_indices(analyzer_power_spect_hdl ph, int min, int max) {
  Spectrum *spect = 0;

  if (ph < 0 || !(spect = s_power_spect[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (min < 0 || max > MAX_TRANSFORMER_INDICES || max < min)
    return ANALYZER_FUNCTION_PARAM_ERR;

  spect->maxIndex(max);
  spect->minIndex(min);

  return ANALYZER_NO_ERR;
}

int analyzer_ps_transfer_indices(analyzer_power_spect_hdl ph, analyzer_hdl ah)
{
  Spectrum *spect = 0;
  association *collection = 0;
  
  if (ph < 0 || !(spect = s_power_spect[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;
   
 spect->maxIndex(collection->transformedData()->maxYIndex());
 spect->minIndex(collection->transformedData()->minYIndex());
 
 return ANALYZER_NO_ERR;
}

int analyzer_ps_use_binning(analyzer_power_spect_hdl ph, BOOL yes, int indices_per_bin, BOOL weighted_bins) {
  Spectrum *spect = 0;

  if (ph < 0 || !(spect = s_power_spect[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (indices_per_bin <= 0 || indices_per_bin > MAX_INDICES_PER_BIN)
    return ANALYZER_FUNCTION_PARAM_ERR;

  spect->binning(yes);
  spect->indices(indices_per_bin);
  spect->weight(weighted_bins);

  return ANALYZER_NO_ERR;
}

int analyzer_ps_mask_l_values_below(analyzer_power_spect_hdl ph, int l_value) {
  Spectrum *spect = 0;

  if (ph < 0 || !(spect = s_power_spect[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (l_value < 0 || l_value > MAX_MASK_INDICES)
    return ANALYZER_FUNCTION_PARAM_ERR;

  spect->maskIndex(l_value);

  return ANALYZER_NO_ERR;
}

int analyzer_calcuate_power_spectrum(analyzer_power_spect_hdl ph, analyzer_hdl ah) {
  association *collection = 0;
  Spectrum    *spect = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (ph < 0 || !(spect = s_power_spect[ph]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (!collection->generatePowerSpectrumData(spect))
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  return ANALYZER_NO_ERR;
}

/* Grapher functions */
#define MAX_ALLOWED_DIMENSIONS 4

int analyzer_grapher_set_resolution(analyzer_graph_hdl gh, int x_res, int y_res) {
  Grapher *graphmaker = 0;

  if (gh < 0 || !(graphmaker = s_graph[gh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (!x_res || ! y_res)
    return ANALYZER_FUNCTION_PARAM_ERR;

  graphmaker->width(x_res);
  graphmaker->height(y_res);

  return ANALYZER_NO_ERR;
}

int analyzer_grapher_get_resolution(analyzer_graph_hdl gh, int& x_res, int& y_res) {
  Grapher *graphmaker = 0;
   
  if (gh < 0 || !(graphmaker = s_graph[gh]))
    return ANALYZER_UNDEF_HDL_ERR;

 x_res = graphmaker->width();
 y_res = graphmaker->height();
  
 return ANALYZER_NO_ERR;
}

int analyzer_grapher_set_datatype(analyzer_graph_hdl gh, analyzer_data_t type) {
  Grapher *graphmaker = 0;
   
  if (gh < 0 || !(graphmaker = s_graph[gh]))
   return ANALYZER_UNDEF_HDL_ERR;
   
  graphmaker->dataType((FILETYPE)type);
   
  return 0;
}

int analyzer_grapher_get_data_dimensions(analyzer_graph_hdl gh, analyzer_hdl ah) {
  association *collection = 0;
  Grapher     *graph = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (gh < 0 || !(graph = s_graph[gh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (!collection->exists(graph->dataType()))
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  return graph->dataDimensions(collection);
}

int analyzer_grapher_get_data_dimension_size(analyzer_graph_hdl gh, analyzer_hdl ah, int dimension) {
  association *collection = 0;
  Grapher     *graph = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (gh < 0 || !(graph = s_graph[gh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (dimension <= 0 || dimension > MAX_ALLOWED_DIMENSIONS)
    return ANALYZER_FUNCTION_PARAM_ERR;

  if (!collection->exists(graph->dataType()))
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  return graph->dataDimensionSize(collection,dimension);
}

int analyzer_grapher_to_bmp_file(analyzer_graph_hdl gh, analyzer_hdl ah, analyzer_data_t dataset, const char* file_name) {
  association *collection = 0;
  Grapher *graphmaker = 0;
  unsigned char *bitmap = 0;
  Raster *rast = 0;

  if (!file_name)
    return ANALYZER_FUNCTION_PARAM_ERR;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;
   
  if (gh < 0 || !(graphmaker = s_graph[gh]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (analyzer_grapher_get_graph(gh, ah, dataset, &bitmap) < 0)
    return ANALYZER_NO_DATAMAP_ERR;
   
  rast = new(std::nothrow) Raster(graphmaker->width(),graphmaker->height(),3,bitmap);
  if (!rast)
    return ANALYZER_ALLOC_ERR;

  rast->toBitmapFile(file_name);

  delete rast;
  delete[] bitmap;

  return ANALYZER_NO_ERR;
}

double *analyzer_grapher_get_data(analyzer_graph_hdl gh, analyzer_hdl ah) {
  association *collection = 0;
  Grapher     *graph = 0;
  double      *ret_data = 0;
  int n, data_sz = 1;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_NULL_DATA;

  if (gh < 0 || !(graph = s_graph[gh])) {
    s_last_data_error[ah] = ANALYZER_UNDEF_HDL_ERR;
    return ANALYZER_NULL_DATA;
  }

  if (!collection->exists(graph->dataType())) {
    s_last_data_error[ah] = ANALYZER_INCOMPLETE_DATASET_ERR;
    return ANALYZER_NULL_DATA;
  }

  n = 1;
  while (n <= MAX_ALLOWED_DIMENSIONS)
    data_sz *= graph->dataDimensionSize(collection,n++);

  if (data_sz <= 0) {
    s_last_data_error[ah] = ANALYZER_INCOMPLETE_DATASET_ERR;
    return ANALYZER_NULL_DATA;
  }

  ret_data = new(std::nothrow) double[data_sz];
  if (!ret_data) {
    s_last_data_error[ah] = ANALYZER_ALLOC_ERR;
    return ANALYZER_NULL_DATA;
  }

  /* Need to figure out a data copy scheme--probably should be defined
  in the data classes; i.e. need special considerations if complex numbers
  are involved... */

  return ret_data;
}

int analyzer_grapher_graph_rgb(analyzer_graph_hdl gh, analyzer_hdl ah, analyzer_data_t dataset) {
  association *collection = 0;
  Grapher     *graph = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
     return ANALYZER_NULL_DATA;

  if (gh < 0 || !(graph = s_graph[gh])) {
    s_last_data_error[ah] = ANALYZER_UNDEF_HDL_ERR;
    return ANALYZER_NULL_DATA;
  }
   
  if (!dataset || dataset <= ANALYZER_MAP_LIMIT || dataset >= ANALYZER_GRAPH_LIMIT) {
    s_last_data_error[ah] = ANALYZER_FUNCTION_PARAM_ERR;
    return ANALYZER_FUNCTION_PARAM_ERR;
  }

  if (!collection->exists((FILETYPE)dataset)) {
    s_last_data_error[ah] = ANALYZER_INCOMPLETE_DATASET_ERR;
    return ANALYZER_NULL_DATA;
  }

  try {
    collection->generateGraph((FILETYPE)dataset);
  }
  catch (ERRORCODES error) {
    s_last_data_error[ah] = ANALYZER_NO_FILE_ERR;
    return ANALYZER_NO_FILE_ERR;
  }
   
  return ANALYZER_NO_ERR;
}

int analyzer_grapher_get_graph(analyzer_graph_hdl gh, analyzer_hdl ah, analyzer_data_t dataset, unsigned char** data_graph) {
  association *collection = 0;
  Grapher *graphmaker = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;
   
  if (gh < 0 || !(graphmaker = s_graph[gh]))
    return ANALYZER_UNDEF_HDL_ERR;

  *data_graph = 0;
  switch (dataset) {
    case ANALYZER_TRANSFORM:
      *data_graph = collection->transDataGraph()->transferRGBData();
      break;
    case ANALYZER_TRANSFORM_WEIGHTS:
      *data_graph = collection->transWeightsGraph()->transferRGBData();
      break;
    case ANALYZER_WEIGHTED_TRANSFORM:
      *data_graph = collection->transGraph()->transferRGBData();
      break;
    case ANALYZER_SPECTRAL:
      *data_graph = collection->spectrumGraph()->transferRGBData();
      break;
    case ANALYZER_TRANSFORM_NOISE:
      *data_graph = collection->transNoiseGraph()->transferRGBData();
      break;
    case ANALYZER_TRANSFORM_FILTER:
      *data_graph = collection->transFilterGraph()->transferRGBData();
      break;
    case ANALYZER_TRANSFORM_BEAM:
      *data_graph = collection->transBeamGraph()->transferRGBData();
      break;
    default:
      *data_graph = 0;
  }
   
  if (*data_graph == 0)
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  return ANALYZER_NO_ERR;
}

int analyzer_grapher_rgb_free(unsigned char *graph_rgb) {
  if (!graph_rgb)
    return ANALYZER_FUNCTION_PARAM_ERR;

  delete[] graph_rgb;

  return ANALYZER_NO_ERR;
}

int analyzer_grapher_data_free(double *graph_data) {
  if (!graph_data)
    return ANALYZER_FUNCTION_PARAM_ERR;

  delete[] graph_data;

  return ANALYZER_NO_ERR;
}

/* Inverse Data.. */
int analyzer_invert_data(analyzer_inverter_hdl ih, analyzer_hdl ah, analyzer_data_t type) {
  association *collection = 0;
  Transformer *inverter = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (ih < 0 || !(inverter = s_inverter[ih]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (!collection->exists((FILETYPE)type))
    return ANALYZER_INCOMPLETE_DATASET_ERR;
  
  if (!collection->generateInverseData(inverter,(FILETYPE)type))
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  return ANALYZER_NO_ERR;
}

/* Save function... */
int analyzer_data_to_file(analyzer_hdl ah, analyzer_data_t d_type, analyzer_file_t f_type, const char *file_name) {
  association *collection = 0;
  baseData    *data = 0;
  fileManager *fm = 0;

  if (ah < 0 || !(collection = s_dataset[ah]))
    return ANALYZER_UNDEF_HDL_ERR;

  if (!(data = collection->getData((FILETYPE)d_type)))
    return ANALYZER_INCOMPLETE_DATASET_ERR;

  if (!file_name)
    return ANALYZER_FUNCTION_PARAM_ERR;

  switch (f_type) {
    case ANALYZER_FILE_FITS:
      fm = new(std::nothrow) fitsManager(s_dataset[ah],file_name,data);
      if (!fm)
        return ANALYZER_ALLOC_ERR;

      if (fm->error()) {
        delete fm;
        return ANALYZER_ALLOC_ERR;
      }

      break;
    case ANALYZER_FILE_CSV:
      fm = new(std::nothrow) csvManager(s_dataset[ah], file_name,data);
      if (!fm)
        return ANALYZER_ALLOC_ERR;

      if (fm->error()) {
        delete fm;
        return ANALYZER_ALLOC_ERR;
      }

      break;
    case ANALYZER_FILE_BLOCK:
    default:
      return ANALYZER_UNIMPLEMENTED_ERR;
  }

  if (fm)
    delete fm;

  return ANALYZER_NO_ERR;
}

/* Automation and status... */
double analyzer_get_progress(analyzer_progress_hdl ph) {
  unsigned n = 0;

  if (!s_progress[n])
    return ANALYZER_UNDEF_HDL_ERR;

  while (n < MAX_DATA_HANDLES && s_progress[n])
    n++;

  if (n == MAX_DATA_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_progress[n-1])
    return ANALYZER_ALLOC_ERR;
  
  return s_progress[n]->informProgress();
}

analyzer_progress_hdl analyzer_set_progress_callback(void* uiObject, analyzer_progress_fn *callback) {
  unsigned n = 0;
  
  while (n < MAX_DATA_HANDLES && s_progress[n])
    n++;

  if (n == MAX_DATA_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  s_progress[n] = new(std::nothrow) progress(uiObject, callback);

  if (s_progress[n])
    return n;
  else
    return ANALYZER_ALLOC_ERR;
}

analyzer_progress_hdl analyzer_get_progress_callback(const char* task) {
  unsigned n = 0;

  if (!s_progress[n])
    return ANALYZER_UNDEF_HDL_ERR;

  while (n < MAX_DATA_HANDLES && s_progress[n])
    n++;

  if (n == MAX_DATA_HANDLES)
    return ANALYZER_OBJECT_LIMIT_ERR;

  if (!s_progress[n-1])
    return ANALYZER_ALLOC_ERR;
  
  s_progress[n-1]->operation((std::string) task);
  
  return n-1;
   
}

int analyzer_progress_release(analyzer_progress_hdl ph) {
  if (ph < 0 || !s_progress[ph])
    return ANALYZER_UNDEF_HDL_ERR;

  delete s_progress[ph];
  s_progress[ph] = 0;
  return ANALYZER_NO_ERR;
}

int analyzer_set_progress_callback_reference(analyzer_hdl ah, void *ref) {
  return ANALYZER_NO_ERR;
}

analyzer_sequence_t analyzer_get_next_step(analyzer_hdl ah) {
  return ANALYZER_SEQ_ABORT;
}

int analyzer_set_automation_callback(analyzer_hdl ah, analyzer_sequence_fn *callback) {
  return ANALYZER_NO_ERR;
}

int analyzer_set_automation_callback_reference(analyzer_hdl ah, void *ref) {
  return ANALYZER_NO_ERR;
}

int analyzer_begin_auto_sequence(analyzer_hdl ah) {
  return ANALYZER_NO_ERR;
}

int analyzer_stop_auto_sequence(analyzer_hdl ah) {
  return ANALYZER_NO_ERR;
}
