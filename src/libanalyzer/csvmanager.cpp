/***************************************************************************
 *   csvmanager.cpp                                                        *
 *   Copyright (C) 2014 by Daniel Suson                                    *
 *   daniel.suson@purduecal.edu                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   In addition, as a special exception, the copyright holders give       *
 *   permission to link the code of this program with any edition of       *
 *   the Qt library by Trolltech AS, Norway (or with modified versions     *
 *   of Qt that use the same license as Qt), and distribute linked         *
 *   combinations including the two.  You must obey the GNU General        *
 *   Public License in all respects for all of the code used other than    *
 *   Qt.  If you modify this file, you may extend this exception to        *
 *   your version of the file, but you are not obligated to do so.  If     *
 *   you do not wish to do so, delete this exception statement from        *
 *   your version.                                                         *
 ***************************************************************************
 * Description:                                                            *
 *                                                                         *
 * This header provides the definitions for various enumerated lists used  *
 * by the data classes.                                                    *
 * ----------------------- Change Log ------------------------------------ *
 * Date    Name         Description                                        *
 *                                                                         *
 ***************************************************************************
 * This software evolved from work that was done by Eric Hivon at the      *
 * California Institute of Technology on the MASTER algorithm (Hivon, E.,  *
 * et al., ApJ, vol 567, p 2).  It adapts or interfaces with these         *
 * packages:                                                               *
 *                                                                         *
 * HealPix         (http://www.eso.org/science/healpix/)                   *
 * FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)  *
 *                                                                         *
 * Any publications or presentations that use results generated by this    *
 * program must reference the fact that it was developed by Daniel Suson   *
 ***************************************************************************/
#include "csvmanager.h"
#include "basedata.h"
#include <string.h>
#include <algorithm>

csvManager::csvManager(association *dataMgr, const char *filename, FILETYPE dataType, RWMode mode)
          : fileManager() {
  m_err = noErrors;
  s_association = dataMgr;

  if (!filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  try {
    if (mode == Read)
      m_ptr = new std::fstream(filename, std::fstream::in);
    else
      m_ptr = new std::fstream(filename, std::fstream::out);
  }
  catch (const char* str) {
    m_err = fileCsvError;
    snprintf(csv_err,CSV_ERR_LEN,"%s",str);
    m_errDetail = errorText[abs(m_err)] + ": " + std::string(csv_err);
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    throw m_err;
  }

  m_fileDataType = dataType;
  m_filename = filename;
  m_fileFormat = CSV;
}

csvManager::csvManager(association *dataMgr, const char *filename,baseData *data)
          : fileManager() {
  m_err     = noErrors;
  s_association = dataMgr;

  if (!data || !filename) {
    m_err = fileInvalidError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  m_filename     = filename;
  m_fileDataType = data->dataType();
  m_fileFormat   = CSV;
  m_observatory  = Analyzer;
  m_cols         = data->cols();
  m_rows         = data->rows();
  m_slices       = data->slices();

  switch (m_fileDataType) {
      case fileType::Null:
      m_err = fileInvalidError;
      s_association->errorValue(m_err);
      throw m_err;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_dimensions = 2;
      m_parts = 1;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        throw m_err;
      }
      if (!saveMatrixD((matrixData<double>*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      m_dimensions = 4;
      m_parts = 2;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      if (!saveCubeCD((cubeData<complex<double> >*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
    case fileType::PixelOccupancy:
      m_dimensions = 1;
      m_parts = 1;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      if (!saveVectorI((vectorData<int>*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
    default:
      m_dimensions = 1;
      m_parts = 1;
      if (!saveBase(filename)) {
        m_err = fileCreateError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      if (!saveVectorD((vectorData<double>*)data)) {
        m_err = fileWriteError;
        s_association->errorValue(m_err);
        throw m_err;
      }
      break;
  }
}

csvManager::csvManager(csvManager* from)
          : fileManager(from) {
  m_ptr         = from->filePtr();
  m_headerData  = from->headerData();
}

csvManager::~csvManager() {
  if (m_ptr) {
    m_ptr->close();
    delete m_ptr;
    m_ptr = 0;
  }
}

void csvManager::open() {
  m_err = noErrors;

  if (!getHeaders()) {
    m_err = fileReadError;
    m_ptr->close();
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }

  if (!getDataType()) {
    m_err = fileReadError;
    m_ptr->close();
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }

  if (!getDimensions()) {
    m_err = fileReadError;
    m_ptr->close();
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }

  if (!getDimensions()) {
    m_err = fileReadError;
    m_ptr->close();
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }

  if (!getEnergy()) {
    m_err = fileReadError;
    m_ptr->close();
    delete m_ptr;
    m_ptr = 0;
    throw m_err;
  }
  m_fileFormat = CSV;

  return;
}

void csvManager::save(FILETYPE dataType) {
  baseData *data = 0;
  m_err     = noErrors;

  if (!(data = s_association->getData(dataType))) {
    m_err = incompleteDatasetError;
    s_association->errorValue(m_err);
    throw m_err;
  }

  m_fileDataType = data->dataType();
  m_fileFormat   = CSV;
  m_observatory  = Analyzer;
  m_cols         = data->cols();
  m_rows         = data->rows();
  m_slices       = data->slices();

  switch (m_fileDataType) {
      case fileType::Null:
      m_err = fileInvalidError;
      s_association->errorValue(m_err);
      throw m_err;
    case fileType::InputData:
    case fileType::InputWeights:
    case fileType::WeightedData:
    case fileType::InputNoise:
    case fileType::InputFilter:
    case fileType::InputBeam:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      m_dimensions = 2;
      m_parts = 1;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveMatrixD((matrixData<double>*)data))
        throw m_err;
      break;
    case fileType::AlmData:
    case fileType::AlmWeights:
    case fileType::AlmNoise:
    case fileType::AlmFilter:
    case fileType::AlmBeam:
      m_dimensions = 4;
      m_parts = 2;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveCubeCD((cubeData<complex<double> >*)data))
        throw m_err;
      break;
    case fileType::PixelOccupancy:
      m_dimensions = 1;
      m_parts = 1;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveVectorI((vectorData<int>*)data))
        throw m_err;
      break;
    default:
      m_dimensions = 1;
      m_parts = 1;
      if (!saveBase(m_filename))
        throw m_err;
      if (!saveVectorD((vectorData<double>*)data))
        throw m_err;
      break;
  }
  return;

}

void csvManager::save(ASSOCIATEDMAP map) {

}

void csvManager::save(ASSOCIATEDSPECTRUM spect) {

}

bool csvManager::getHeaders(int hdrNum) {
  std::string headerStr, key, value;
  std::string delimiter = "] == ";
  int count = 0;

  int linePos = m_ptr->tellg();  // store current position in file
  std::getline(*m_ptr, headerStr);
  headerStr = convertString(headerStr);
  
  while (headerStr[0] == '[' || headerStr[0] == '#') {
    if (headerStr[0] == '[') {
      key = headerStr.substr(1,headerStr.find(delimiter)-1);
      value = headerStr.substr(headerStr.find(delimiter) + delimiter.length(),headerStr.length());
      m_headerData[key] = value;
      count++;
    }
    linePos = m_ptr->tellg();  // get new position in file
    std::getline(*m_ptr,headerStr);
    headerStr = convertString(headerStr);
  }
  m_ptr->seekg(linePos);  // return to start of previous line since it's not a header line
  if (count > 0)
    return true;
  else
    return false;
}

bool csvManager::getDimensions() {
  m_dimensions = 0;
  m_rows       = 1;
  m_cols       = 1;
  m_slices     = 1;
  m_parts      = 1;
  m_minSlice  = 0;
  m_maxSlice  = 0;

  int          *dim[4]     = {&m_cols, &m_rows, &m_slices, &m_parts};
  std::string  keyname[4] = {"NAXIS1", "NAXIS2", "NAXIS3", "NAXIS4"};

  if (m_headerData.find("NAXIS") == m_headerData.end()) {
    m_err = fileNoKeyError;
    return false;
  }
  else
    m_dimensions = std::stoi(m_headerData["NAXIS"]);

  if (m_dimensions > 4)
    return false;

  for (int i = 0; i < m_dimensions; i++) {
    if (m_headerData.find(keyname[i]) == m_headerData.end()) {
      m_err = fileNoKeyError;
      return false;
    }
    else
      *dim[i] = std::stoi(m_headerData[keyname[i]]);
  }

  m_maxSlice = m_slices - 1;

  return true;
}

bool csvManager::getDataType() {
  FILETYPE type = fileType::Null;
  std::string instrument = "";
  std::string telescope  = "";

  telescope = m_headerData["TELESCOPE"];
  std::transform(telescope.begin(),telescope.end(),telescope.begin(),::toupper);

  OBSERVATORY obsType = Unknown;
  int obsValue = (int)Unknown;
  while (obsType < OBSERVATORY_LIMIT) {
    obsType = static_cast<OBSERVATORY>(obsValue);
    std::string ucObsName = observatoryNames[obsValue];
    std::transform(ucObsName.begin(),ucObsName.end(),ucObsName.begin(),::toupper);
    if (telescope == ucObsName)
      break;
    obsValue++;
  }
  m_observatory = obsType;
  m_fileDataType = fileType::InputData;
  if (m_observatory == Analyzer) {
    instrument = m_headerData["INSTRUMENT"];
    for (int dataNamesList = 0; dataNamesList < (int)fileType::FILETYPE_LIMIT; ++ dataNamesList)
      if (dataTypeNames[dataNamesList] == instrument)
        type = static_cast<FILETYPE>(dataNamesList);
    if (type != fileType::FILETYPE_LIMIT)
      m_fileDataType = type;
  }
  if (m_observatory == OBSERVATORY_LIMIT) {
    m_err = fileNoKeyError;
    m_errDetail = errorText[abs(m_err)] + ": Observatory not recognized";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  return true;
}

bool csvManager::getEnergy() {
  int n;
  std::string maxE, minE;

  switch (m_observatory) {
    case Egret:
      n = 0;

      while (n < m_slices) {
        maxE = "MAXENG" + std::to_string(n);
        minE = "MINENG" + std::to_string(n);
        if (m_headerData.find(maxE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_maxE[n] = std::stoi(m_headerData[maxE]);
        if (m_headerData.find(minE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_minE[n] = std::stoi(m_headerData[minE]);
        n++;
      }
      break;
    case Fermi:
      n = 0;

      while (n < m_slices) {
        maxE = "E_MAX" + std::to_string(n);
        minE = "E_MIN" + std::to_string(n);
        if (m_headerData.find(maxE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_maxE[n] = std::stof(m_headerData[maxE]);
        if (m_headerData.find(minE) == m_headerData.end()) {
          m_err = fileNoKeyError;
          return false;
        }
        else
          m_minE[n] = std::stof(m_headerData[minE]);
        n++;
      }
      break;
    case Telescope_Array:
    case Auger:
    case Kascade:
      n = 0;
      if (m_headerData.find("E_MAX") == m_headerData.end()) {
        m_err = fileNoKeyError;
        return false;
      }
      else
        m_maxE[n] = std::stof(m_headerData["E_MAX"]);
      if (m_headerData.find("E_MIN") == m_headerData.end()) {
        m_err = fileNoKeyError;
        return false;
      }
      else
        m_minE[n] = std::stof(m_headerData["E_MIN"]);
    case Analyzer:
      n = 0;
      m_minE[n] = 0.0;
      m_maxE[n] = 0.0;
      break;
    default:
      return false;
  }

  return true;
}

baseData *csvManager::data() {
  if (!m_ptr)
    return 0;

  switch (m_fileDataType) {
      case fileType::Null:
      return 0;
    case fileType::InputData:
    case fileType::InputWeights:
      if (m_observatory == Egret || m_observatory == Fermi)
//      if (m_observatory != Analyzer && m_observatory != Telescope_Array && m_observatory != Auger && m_observatory != Kascade)
        return data(m_minSlice,m_maxSlice);
      if (m_observatory == Telescope_Array || m_observatory == Auger || m_observatory == Kascade)
        return data(m_minE[0],m_maxE[0]);
    case fileType::WeightedData:
    case fileType::BinCouplingMatrix:
    case fileType::ModeCouplingMatrix:
    case fileType::InverseBinMatrix:
    case fileType::InverseModeMatrix:
      return getMatrixD();
    case fileType::AlmData:
    case fileType::AlmWeights:
      return getCubeCD();
    case fileType::PixelOccupancy:
      return getVectorI();
    default:
      return getVectorD();
  }
  return 0;
}

inputMatrixData *csvManager::data(int slice_min, int slice_max) {
  inputMatrixData* in_mat = 0;
  long span, begin;
  unsigned long long int numOps, updateUnit, currOp;

  if (!m_ptr) {
    m_err = noFileError;
    m_errDetail = errorText[abs(m_err)] + ": No file stream pointer";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (!(m_observatory == Egret || m_observatory == Fermi)) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": No slices in file";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min < 0 || slice_max < 0) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number or maximum slice number less than 0";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > m_slices || slice_max > m_slices) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Slice number is greater than the available slices";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }
  if (slice_min > slice_max) {
    m_err = fileSliceError;
    m_errDetail = errorText[abs(m_err)] + ": Minimum slice number greater than maximum slice number";
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  span  = slice_max - slice_min + 1;
  begin = slice_min * m_rows;
  numOps = span * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, colDescriptor, colName, field;
  long x, y;
  int EnergyNo = -1, decNo = -1, RANo = -1, ValueNo = -1;
  std::vector<double> colData;
  
  // go to start of slice in data
  int slice = 0;
  for (slice = 0; slice < begin; ++slice)
    std::getline(*m_ptr,dataStr);

  in_mat = new inputMatrixData(m_cols,m_rows,m_fileDataType);
  in_mat->initialize();

  int col = 0;
  while (col < m_cols) {
    colDescriptor = "COL" + std::to_string(col);
    if (m_headerData.find(colDescriptor) == m_headerData.end()) {
      m_err = fileNoKeyError;
      delete in_mat;
      in_mat = 0;
      return 0;
    }
    else {
      colName = m_headerData[colDescriptor];
      std::transform(colName.begin(),colName.end(),colName.begin(),::toupper);
      if (colName == "ENERGY")
        EnergyNo = col;
      else if (colName == "DEC" || colName == "LAT")
        decNo = col;
      else if (colName == "RA" || colName == "LONG")
        RANo = col;
      else if (colName == "VALUE")
        ValueNo = col;
      else {
        m_err = fileNoKeyError;
        return 0;
      }
    }
    col++;
  }
  if (decNo == -1 || RANo == -1) {
    m_err = fileNoKeyError;
    delete in_mat;
    in_mat = 0;
    return 0;
  }

  while (currOp < numOps) {
    std::getline(*m_ptr,dataStr);
    std::stringstream line(dataStr);
    while (line.good()) {
      std::getline(line,field, ',');
      colData.push_back(std::stod(field));
    }
    
    in_mat->angle2bin(colData[decNo],colData[RANo],x,y);
    if (ValueNo >= 0)
      (*in_mat)[x][y] += colData[ValueNo];
    else
      (*in_mat)[x][y] += colData[EnergyNo];
    
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
    colData.clear();
  }
  
  return in_mat;
}

inputMatrixData *csvManager::data(float minE, float maxE) {
  inputMatrixData* in_mat = 0;
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;

  if (!m_ptr) {
    m_err = noFileError;
    return 0;
  }
  if (minE < 0 || maxE < 0) {
    m_err = fileEnergyError;
    return 0;
  }
  if (minE > maxE) {
    m_err = fileEnergyError;
    return 0;
  }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, colDescriptor, colName, field;
  long x, y;
  int EnergyNo = -1, decNo = -1, RANo = -1, ValueNo = -1;
  std::vector<std::string> colData;
  
  if (m_headerData.find("RA_RES") != m_headerData.end())
    ra_res = std::stod(m_headerData["RA_RES"]);
  else if (m_cols > 0)
    ra_res = 360.0/(double)m_cols;
  else {
    m_err = fileResError;
    return 0;
  }
  
  if (m_headerData.find("DEC_RES") != m_headerData.end())
    dec_res = std::stod(m_headerData["DEC_RES"]);
  else if (m_rows > 0)
    dec_res = 180.0/(double)m_rows;
  else {
    m_err = fileResError;
    return 0;
  }

  in_mat = new inputMatrixData((int)(360.0/ra_res),(int)(180.0/dec_res),m_fileDataType);
  in_mat->initialize();

  int col = 0;
  while (col < m_cols) {
    colDescriptor = "COL" + std::to_string(col+1);
    if (m_headerData.find(colDescriptor) == m_headerData.end()) {
      m_err = fileNoKeyError;
      delete in_mat;
      in_mat = 0;
      return 0;
    }
    else {
      colName = m_headerData[colDescriptor];
      std::transform(colName.begin(),colName.end(),colName.begin(),::toupper);
      if (colName == "ENERGY")
        EnergyNo = col;
      else if (colName == "DEC" || colName == "LAT")
        decNo = col;
      else if (colName == "RA" || colName == "LONG")
        RANo = col;
      else if (colName == "VALUE")
        ValueNo = col;
    }
    col++;
  }
  if (decNo == -1 || RANo == -1 || (EnergyNo == -1 && ValueNo == -1)) {
    m_err = fileNoKeyError;
    delete in_mat;
    in_mat = 0;
    return 0;
  }

  while (currOp < numOps) {
    std::getline(*m_ptr,dataStr);
    dataStr = convertString(dataStr);
    std::stringstream line(dataStr);
    while (line.good()) {
      std::getline(line,field, ',');
      colData.push_back(field);
    }
    if(std::stof(colData[EnergyNo]) >= minE && std::stof(colData[EnergyNo]) <= maxE) {
      if (std::stod(m_headerData["MIN_RA"]) == 0.0)
        in_mat->angle2bin(std::stod(colData[decNo]),std::stod(colData[RANo])-180.0,x,y);
      else
        in_mat->angle2bin(std::stod(colData[decNo]),std::stod(colData[RANo]),x,y);
      if (ValueNo >= 0)
        (*in_mat)[x][y] += std::stod(colData[ValueNo]);
      else
        (*in_mat)[x][y] += std::stod(colData[EnergyNo]);
    }
    
    currOp++;
    if (!(currOp % updateUnit))
      updateProgress((currOp*100)/numOps);
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
    colData.clear();
  }
  
  return in_mat;
}

baseData *csvManager::getVectorI() {
  vectorData<int> *i_vec = 0;
  std::string layout = "";
  std::string scheme = "";
  int sides = 0;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  if (m_headerData.find("NSIDES") == m_headerData.end())
      m_err = fileNoKeyError;
  else
      sides = std::stoi(m_headerData["NSIDES"]);
  if (m_headerData.find("PIXLAYOUT") == m_headerData.end())
      m_err = fileNoKeyError;
  else
      layout = m_headerData["PIXLAYOUT"];
  if (m_headerData.find("PIXSCHEME") == m_headerData.end())
      m_err = fileNoKeyError;
  else
      scheme = m_headerData["PIXSCHEME"];

  if (m_err != noErrors) {
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  i_vec = new vectorData<int>(m_rows,m_fileDataType);
  i_vec->sides(sides);

  if (layout == "Ring")
    i_vec->layout(Ring);
  else if (layout == "Nest")
    i_vec->layout(Nest);
  else
    i_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    i_vec->pixelScheme(HealPIX);
    i_vec->numberOfPixels(12 * sides * sides);
  }
  else {
    i_vec->pixelScheme(NotPixelized);
    i_vec->numberOfPixels(0);
  }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, field;
  std::vector<int> colData;
  int row = 0;
  
  std::getline(*m_ptr,dataStr);
  dataStr = convertString(dataStr);
  std::stringstream line(dataStr);
  while (line.good()) {
    std::getline(line,field, ',');
    colData.push_back(std::stoi(field));
  }
  for (row = 0; row < m_rows; ++row) {
    (*i_vec)[row] = colData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return (baseData*)i_vec;
}

baseData *csvManager::getVectorD() {
  vectorData<double> *d_vec = 0;
  std::string layout = "", scheme = "",trans  = "";
  int sides = 0, maxIndex = 0, minIndex = 0, mask = 0;
  double maxValue = 0, minValue = 0;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  switch (m_fileDataType) {
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::InverseData:
    case fileType::InverseWeights:
      if (m_headerData.find("NSIDES") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        sides = std::stoi(m_headerData["NSIDES"]);
      if (m_headerData.find("PIXLAYOUT") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        layout = (m_headerData["PIXLAYOUT"]);
      if (m_headerData.find("PIXSCHEME") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        scheme = m_headerData["PIXSCHEME"];
      break;
    case fileType::TransformedData:
    case fileType::TransformedWeights:
      if (m_headerData.find("MAXINDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        maxIndex = std::stoi(m_headerData["MAXINDEX"]);
      if (m_headerData.find("MININDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        minIndex = std::stoi(m_headerData["MININDEX"]);
      if (m_headerData.find("TRANSFORMERSCHEME") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        trans = m_headerData["TRANSFORMERSCHEME"];
      break;
    case fileType::SpectralData:
      if (m_headerData.find("MAXINDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        maxIndex = std::stoi(m_headerData["MAXINDEX"]);
      if (m_headerData.find("MININDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        minIndex = std::stoi(m_headerData["MININDEX"]);
      if (m_headerData.find("MAXVALUE") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        maxValue = std::stod(m_headerData["MAXVALUE"]);
      if (m_headerData.find("MINVALUE") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        minValue = std::stod(m_headerData["MINVALUE"]);
      if (m_headerData.find("MASKINDEX") == m_headerData.end())
        m_err = fileNoKeyError;
      else
        mask = std::stoi(m_headerData["MASKINDEX"]);
      break;
    default:
      break;
  }

  if (m_err != noErrors) {
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  d_vec = new vectorData<double>(m_rows,m_fileDataType);
  d_vec->initialize();
  d_vec->sides(sides);
  d_vec->maxYIndex(maxIndex);
  d_vec->minYIndex(minIndex);
  d_vec->maxValue(maxValue);
  d_vec->minValue(minValue);
  d_vec->mask(mask);

  if (layout == "Ring")
    d_vec->layout(Ring);
  else if (layout == "Nest")
    d_vec->layout(Nest);
  else
    d_vec->layout(Unordered);

  if (scheme == "HealPIX") {
    d_vec->pixelScheme(HealPIX);
    d_vec->numberOfPixels(12 * sides * sides);
  }
  else {
    d_vec->pixelScheme(NotPixelized);
    d_vec->numberOfPixels(0);
  }

  if (trans == "Rsht")
    d_vec->transformerScheme(Rsht);
  else
    d_vec->transformerScheme(NotTransformed);

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, field;
  std::vector<double> colData;
  int row = 0;

  std::getline(*m_ptr,dataStr);
  dataStr = convertString(dataStr);
  std::stringstream line(dataStr);
  while (line.good()) {
    std::getline(line,field, ',');
    colData.push_back(std::stod(field));
  }
  for (row = 0; row < m_rows; ++row) {
    (*d_vec)[row] = colData[row];
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }

  return (baseData*)d_vec;
}

baseData *csvManager::getMatrixD() {
  matrixData<double> *d_mat = 0;
  double ra_res = 0, dec_res = 0;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  if (m_headerData.find("RA_RES") != m_headerData.end())
    ra_res = std::stod(m_headerData["RA_RES"]);
  else if (m_cols > 0)
    ra_res = 360.0/(double)m_cols;
  else
    m_err = fileResError;

  if (m_headerData.find("DEC_RES") != m_headerData.end())
    dec_res = std::stod(m_headerData["DEC_RES"]);
  else if (m_rows > 0)
    dec_res = 180.0/(double)m_rows;
  else
    m_err = fileResError;

  if (m_err != noErrors) {
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  d_mat = new matrixData<double>((int)(360.0/ra_res),(int)(180.0/dec_res),m_fileDataType);
  d_mat->initialize();
  d_mat->RARes(ra_res);
  d_mat->DecRes(dec_res);

  /* assume that the data is a flat matrix where the rows are dec/lat,
   * the columns are RA/long, and the contents is the value at that point
   */

  numOps = m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  std::string dataStr, field;
  std::vector<double> colData;
  int col = 0, row = 0;

  while (col < m_cols) {
    std::getline(*m_ptr,dataStr);
    dataStr = convertString(dataStr);
    std::stringstream line(dataStr);
    while (line.good()) {
      std::getline(line,field, ',');
      colData.push_back(std::stod(field));
    }

    for (int row = 0; row < m_rows; ++row) {
      (*d_mat)[col][row] = colData[row];
      currOp++;
//      if(m_showProgress && !(currOp % updateUnit))
//        informProgress(currOp / updateUnit);
    }
    col++;
    colData.clear();
  }

  return (baseData*)d_mat;
}

baseData *csvManager::getCubeCD() {
  cubeData<std::complex<double> > *dc_cube = 0;
  std::vector<std::vector<std::vector<std::complex<double> > > > data;
  int polarization = 0, index = 0, offset;
  unsigned long long int numOps, updateUnit, currOp;
  m_err = noErrors;

  if (m_headerData.find("POLARIZATION") == m_headerData.end())
    m_err = fileNoKeyError;
  else
    polarization = std::stoi(m_headerData["POLARIZATION"]);
  if (m_headerData.find("INDEX") == m_headerData.end())
    m_err = fileNoKeyError;
  else
    index = std::stoi(m_headerData["INDEX"]);

  if (m_err != noErrors) {
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return 0;
  }

  dc_cube = new cubeData<std::complex<double> >(m_cols,m_rows,m_slices,m_fileDataType);
  data    = dc_cube->rwAccess();
  dc_cube->polarization(polarization);
  dc_cube->index(index);

  numOps = m_slices * m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  
  std::string dataStr, field;
  std::vector<double> colData;
  std::complex<double> value;
  int slice = 0, col = 0, row = 0;
  
  while (slice < m_slices) {
    while (col < m_cols) {
      std::getline(*m_ptr,dataStr);
      dataStr = convertString(dataStr);
      std::stringstream line(dataStr);
      while (line.good()) {
        std::getline(line,field, ',');
        colData.push_back(std::stod(field));
      }

      for (int row = 0; row < m_rows; ++row) {
        value = (colData[2*row],colData[2*row+1]);
        data[slice][col][row] = value;
        currOp++;
//        if(m_showProgress && !(currOp % updateUnit))
//          informProgress(currOp / updateUnit);
      }
      col++;
      colData.clear();
    }
    slice++;
  }

  return (baseData*)dc_cube;
}

dataMap* csvManager::getMap() {
  return 0;
}

dataSpectrum* csvManager::getSpectrum() {
  return 0;
}


bool csvManager::saveBase(const char* filename) {
  std::string text, comment;
  
  if (!filename) {
    m_err = fileInvalidError;
    m_errDetail = errorText[abs(m_err)];
    s_association->errorValue(m_err);
    s_association->errorDetails(m_errDetail);
    return false;
  }

  if (m_ptr == 0) {
    try {
      m_ptr = new std::fstream(filename, std::fstream::out);
    }
    catch (const char* str) {
      m_err = fileCsvError;
      snprintf(csv_err,CSV_ERR_LEN,"%s",str);
      m_errDetail = errorText[abs(m_err)] + ": " + std::string(csv_err);
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      throw m_err;
    }

    if (!m_ptr) {
      m_err = fileCreateError;
      m_errDetail = errorText[abs(m_err)];
      s_association->errorValue(m_err);
      s_association->errorDetails(m_errDetail);
      return false;
    }
  }
  
  /* All data saved will be tagged as "Analyzer" data. In memory
     data generated from other observatories will be noted as such in
     a comment */
  if (m_observatory != Analyzer) {
    text = observatoryNames[(int)m_observatory];
    comment  = "# Compiled from ";
    comment += text;
    comment += " data file.";
    m_observatory = Analyzer;
  }
  
  *m_ptr << "[TELESCOPE] == Analyzer\n";
  if (comment.length() > 0)
    *m_ptr << comment << "\n";
  text = dataTypeNames[(int)m_fileDataType];
  *m_ptr << "[INSTRUMENT] == " << text << '\n';

  // save the dimensionality
  *m_ptr << "[NAXIS] == " << m_dimensions <<'\n';
  *m_ptr << "[NAXIS1] == " << m_cols << '\n';
  if (m_dimensions > 1)
    *m_ptr << "[NAXIS2] == " << m_rows <<'\n';
  if (m_dimensions > 2)
    *m_ptr << "[NAXIS3] == " << m_slices << '\n';
  if (m_dimensions > 3)
    *m_ptr << "[NAXIS4] == " << m_parts << '\n';

  return true;
}

bool csvManager::saveVectorI(vectorData<int> *v) {
  std::string layout, scheme;
  unsigned long long int numOps, updateUnit, currOp;

  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  *m_ptr << "[NSIDES] == " << v->sides() << '\n';
  *m_ptr << "[PIXLAYOUT] == " << layout << '\n';
  *m_ptr << "[PIXSCHEME] == " << scheme << '\n';
  
  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  
  int row = 0;
  for (row = 0; row < m_rows; ++row) {
    *m_ptr << (*v)[row];
    if (row < m_rows - 1)
      *m_ptr << ',';
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
  *m_ptr << '\n';

  m_ptr->close();
  return true;
}

bool csvManager::saveVectorD(vectorData<double> *v) {
  std::string layout, scheme, trans;
  unsigned long long int numOps, updateUnit, currOp;

  if (v->layout() == Ring)
    layout = std::string("Ring");
  else if (v->layout() == Nest)
    layout = std::string("Nest");
  else
    layout = std::string("Unordered");

  if (v->pixelScheme() == HealPIX)
    scheme = std::string("HealPIX");
  else
    scheme = std::string("NotPixelized");

  if (v->transformerScheme() == Rsht)
    trans = std::string("Rsht");
  else
    trans = std::string("NotTransformed");

  switch (m_fileDataType) {
    case fileType::PixelizedData:
    case fileType::PixelizedWeights:
    case fileType::WeightedPixel:
    case fileType::InverseData:
    case fileType::InverseWeights:
      *m_ptr << "[NSIDES] == " << v->sides() << '\n';
      *m_ptr << "[PIXLAYOUT] == " << layout <<'\n';
      * m_ptr << "[PIXSCHEME] == " << scheme <<'\n';
      break;
    case fileType::TransformedData:
    case fileType::TransformedWeights:
      *m_ptr << "[TRANSFORMERSCHEME] == " << trans << '\n';
      *m_ptr << "[MAXINDEX] == " << v->maxYIndex() << '\n';
      *m_ptr << "[MININDEX] == " << v->minYIndex() << '\n';
      break;
    case fileType::SpectralData:
      *m_ptr << "[MAXINDEX] == " << v->maxYIndex() << '\n';
      *m_ptr << "[MININDEX] == " << v->minYIndex() << '\n';
      *m_ptr << "[MAXVALUE] == " << v->maxValue() << '\n';
      *m_ptr << "[MINVALUE] == " << v->minValue() << '\n';
      *m_ptr << "[MASKINDEX] == " << v->mask() << '\n';
      break;
    default:
      break;
    }

  numOps = m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;

  int row = 0;
  for (row = 0; row < m_rows; ++row) {
    *m_ptr << (*v)[row];
    if (row < m_rows - 1)
      *m_ptr << ',';
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
  *m_ptr << '\n';

  m_ptr->close();

  return true;
}

bool csvManager::saveMatrixD(matrixData<double> *m) {
  unsigned long long int numOps, updateUnit, currOp;

  *m_ptr << "[RA_RES] == " << m->RARes() << '\n';
  *m_ptr << "[DEC_RES] == " << m->DecRes() << '\n';

  numOps = m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  int col = 0, row = 0;
  for (col = 0; col < m_cols; ++col) {
    for (row = 0; row < m_rows; ++row) {
      *m_ptr << (*m)[col][row];
      if (row < m_rows - 1)
        *m_ptr << ',';
    }
    *m_ptr << '\n';
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
    
  m_ptr->close();

  return true;
}

bool csvManager::saveCubeCD(cubeData<complex<double> > *c) {
  std::vector<std::vector<std::vector<complex<double> > > > data = c->roAccess();
  unsigned long long int numOps, updateUnit, currOp;

  *m_ptr << "[POLARIZATION] == " << c->polarization() <<'\n';
  *m_ptr << "[INDEX] == " << c->index() << '\n';

  numOps = m_slices * m_cols * m_rows;
  updateUnit = numOps / 100;
  if(updateUnit < 1) updateUnit = 1;
  currOp = 0;
  int slice = 0, col = 0, row = 0;

  for (slice = 0; slice < m_slices; ++slice) {
    for (col = 0; col < m_cols; ++col)
      for (row = 0; row < m_rows; ++row) {
        *m_ptr << data[slice][col][row].real() << ',' << data[slice][col][row].imag();
        if (row < m_rows - 1)
          *m_ptr << ',';
      }
    *m_ptr << '\n';
    currOp++;
//    if(m_showProgress && !(currOp % updateUnit))
//      informProgress(currOp / updateUnit);
  }
  
  m_ptr->close();

  return true;
}

bool csvManager::saveMap(dataMap* map) {
  return true;
}

bool csvManager::saveSpectrum(dataSpectrum* spect) {
  return true;
}

std::string csvManager::convertString(std::string inString)
{
  std::string unixString, cr = "\r";

  // check for windows-style crlf and convert to unix-style lf
  if (inString.find(cr))
    unixString = inString.substr(0,inString.find(cr));
  else
    unixString = inString;
  
  return unixString;
  
}
