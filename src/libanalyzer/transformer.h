/****************************************************************************
                              \transformer.h
Description:\brief (put short description here)

Begin    : Wed Jun 8 2005
Copyright: (C) 2005 by Daniel Suson
email    : daniel.suson@tamuk.edu

-----------------------------------------------------------------------------
                                Change Log
Date       Name                Description

-----------------------------------------------------------------------------

This program was developed at Texas A&M University-Kingsville by Daniel Suson.
It is free software; you may redistribute and/or modify it under the terms
of the GNU General License as published by the Free Software Foundation;
either version 2 of the License. or (at your option) any later version.

This software evolved from work that was done by Eric Hivon at the
California Institute of Technology on the MASTER algorithm (Hivon, E.,
et al., ApJ, vol 567, p 2).  It adapts or interfaces with these packages:

HealPix         (http://www.eso.org/science/healpix/)
FTOOLS & FITSIO (http://heasarc.gsfc.nasa.gov/docs/corp/software.html)

Any publications or presentations that use results generated by this program
must reference the fact that it was developed at Texas A&M
University-Kingsville by Daniel Suson
***************************************************************************/
#ifndef _TRANSFORMER_H_
#define _TRANSFORMER_H_

#include <string>
#include "atypes.h"
#include "cubedata.h"
#include "vectordata.h"
#include "basedata.h"

class association;

class Transformer {
  public:
    Transformer();
    Transformer(Transformer* from);
    virtual ~Transformer() {}

    /**
     * virtual functions that must be defined by inherited classes
     */
    virtual int initialize(association* dataClasses, FILETYPE type) = 0;
    virtual int initialize(association* dataClasses) = 0;
    virtual std::string name() = 0;
    virtual int loadMap(association* dataClasses, FILETYPE type) = 0;

    virtual int loadAlmMap(association* dataClasses, FILETYPE type) = 0;
    virtual int storeAlmMap(association* dataClasses, FILETYPE type) = 0;

    virtual void transform(association* dataClasses, FILETYPE type) = 0;
   
    virtual void invert(association* dataClasses, FILETYPE type) = 0;

    /**
     * access to transformation type
     */
    TRANSFORMERTYPES type() {return m_type;}
    void type(TRANSFORMERTYPES type) {m_type = type;}

    /**
     *  Introspective tranformer type identifier
     */
    TRANSFORMERSCHEME scheme() { return m_scheme; }
    void scheme(TRANSFORMERSCHEME s) { m_scheme = s; }

    /**
     * flag for determining if transformer is configured
     */
    bool configured() {return m_configured;}
    void configured(bool flag) {m_configured = flag;}

    /**
     * flag for determining if transformer is active
     */
    bool active() {return m_active;}
    void active(bool flag) {m_active = flag;}

    /**
     * power spectrum minimum and maximum index values
     */
    int minIndex() {return m_minIndex;}
    void minIndex(int value) {m_minIndex = value;}
    int maxIndex() {return m_maxIndex;}
    void maxIndex(int value) {m_maxIndex = value;}

    /**
     * polarization indicator
     */
    int polarization() {return m_polarization;}
    void polariation(int value) {m_polarization = value;}

    /**
     * number of iterations
     */
    int iterations() {return m_iterations;}
    void iterations(int value) {m_iterations = value;}

    /**
     * get size of transformed arrays
     */
//    int size() {return m_data->size();}

    /**
     * access to input size
     */
    int dataSize() {return m_dataSize;}
    void dataSize(int value) {m_dataSize = value;}
/*
    vectorData<double>* data() {return m_data;}
    void data(vectorData<double>* ptr) {m_data = ptr;}
    vectorData<double>* weights() {return m_weights;}
    void weights(vectorData<double>* ptr) {m_weights = ptr;}
    cubeData<complex<double> >* dataAlms() {return m_almData;}
    void dataAlms(cubeData<complex<double> >* ptr) {m_almData = ptr;}
    cubeData<complex<double> >* weightAlms() {return m_almWeights;}
    void weightsAlms(cubeData<complex<double> >* ptr) {m_almWeights = ptr;}
    vectorData<double>* inverseData() {return m_invData;}
    void inverseData(vectorData<double>* ptr) {m_invData = ptr;}
    vectorData<double>* inverseWeights() {return m_invWeights;}
    void inverseWeights(vectorData<double>* ptr) {m_invWeights = ptr;}
*/
    /**
     * clear the transformed arrays
     */
    virtual void clearData(association* dataclasses, FILETYPE ft) = 0;
    virtual void clearMaps() = 0;
    virtual void clearAlms() = 0;
    virtual void clearArrays(association* dataClasses) = 0;
    virtual void clear(association* dataClasses) = 0;

    /**
     * transformer scheme used
     */
    void transformerScheme(TRANSFORMERSCHEME type) {m_scheme = type;}
    TRANSFORMERSCHEME transformerScheme() {return m_scheme;}


  protected:
    bool                           m_configured;
    bool                           m_active;
    unsigned long                  m_minIndex;
    unsigned long                  m_maxIndex;
    int                            m_polarization;
    int                            m_iterations;
    int                            m_dataSize;
    TRANSFORMERTYPES               m_type;
    TRANSFORMERSCHEME              m_scheme;
};

#endif
